{"version":3,"sources":["pages/ObjectDetectionCamera.js"],"names":["withWidth","props","useState","locData","setLocData","messages","setMessages","model","setModel","modelLoaded","setModelLoaded","cameraReady","setCameraReady","objectDetectionOccuring","setObjectDetectionOccuring","objectDetectionEnvironment","setObjectDetectionEnvironment","videoRef","useRef","canvasRef","localizationService","LocalizationService","useEffect","a","locCode","getUserLocale","getLocalizedTextSet","locDataLoaded","loadLocalization","tf","then","loadModel","initWebCam","detectFromVideoFrame","current","navigator","mediaDevices","getUserMedia","webkitGetUserMedia","video","facingMode","audio","stream","window","srcObject","Promise","resolve","onloadedmetadata","error","console","cocoSsd","log","detect","predictions","showDetections","requestAnimationFrame","ctx","getContext","clearRect","canvas","width","height","font","outlineColor","textBaseline","forEach","prediction","left","bbox","top","strokeStyle","lineWidth","strokeRect","fillStyle","textWidth","measureText","class","textHeight","parseInt","fillRect","fillText","score","toFixed","performImageObjectDetection","toggleWebCamStream","activate","getTracks","track","start","play","stop","pause","CameraActionButton","color","onClick","className","CameraEnvironmentButton","calcVideoWidth","isWidthUp","innerWidth","calcVideoHeight","h","Math","ceil","Instructions","objectdetectioninstructionscamera","Messages","container","spacing","item","xs","sm","md","lg","xl","elevation","objectdetectioncamera","ref","style","position","zIndex","autoPlay","muted","playsInline"],"mappings":"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","file":"static/js/3.73f419f1.chunk.js","sourcesContent":["import React, { useEffect, useState, useRef } from 'react';\n// Tensorflow\nimport * as tf from '@tensorflow/tfjs';\nimport '@tensorflow/tfjs-backend-cpu';\nimport '@tensorflow/tfjs-backend-webgl';\nimport * as cocoSsd from '@tensorflow-models/coco-ssd';\n// material-ui\nimport Alert from '@material-ui/lab/Alert';\nimport Button from '@material-ui/core/Button';\nimport Card from '@material-ui/core/Card';\nimport CardActions from '@material-ui/core/CardActions';\nimport CardContent from '@material-ui/core/CardContent';\nimport Grid from '@material-ui/core/Grid';\nimport withWidth, { isWidthUp } from '@material-ui/core/withWidth';\n// Services\nimport LocalizationService from 'services/LocalizationService';\n\nfunction ObjectDetectionCamera(props) {\n  const [locData, setLocData] = useState({});\n  const [messages, setMessages] = useState('');\n  const [model, setModel] = useState();\n  const [modelLoaded, setModelLoaded] = useState(false);\n  const [cameraReady, setCameraReady] = useState(false);\n  const [objectDetectionOccuring, setObjectDetectionOccuring] = useState(false);\n  const [objectDetectionEnvironment, setObjectDetectionEnvironment] = useState('environment');\n\n  const videoRef = useRef(null);\n  const canvasRef = useRef(null);\n\n  const localizationService = LocalizationService();\n\n  const aspectRatioFactor = 0.75; // 0.75 = 4by3 and 0.5625 = 16by9\n\n  let videoTop = 240;\n  let videoLeft = 20;\n\n  // localization\n  useEffect(() => {\n    async function loadLocalization() {\n      const locCode = localizationService.getUserLocale();\n      const locDataLoaded = await localizationService.getLocalizedTextSet(\n        ['objectdetectioncamera', 'objectdetectiondescriptioncamera', 'objectdetectioninstructionscamera', 'moreinfo'],\n        locCode\n      );\n      setLocData(locDataLoaded);\n    }\n    loadLocalization();\n  }, []);\n\n  // model then camera initialization\n  useEffect(() => {\n    tf.ready().then(() => {\n      setMessages('Model loading...');\n      loadModel().then(() => {\n        setMessages('Model loaded...');\n        initWebCam();\n      });\n    });\n  }, []);\n\n  // camera object detection toggle\n  useEffect(() => {\n    if (objectDetectionOccuring === true) {\n      detectFromVideoFrame(model, videoRef.current, objectDetectionOccuring);\n    }\n  }, [objectDetectionOccuring]);\n\n  const initWebCam = () => {\n    if (navigator.mediaDevices.getUserMedia || navigator.mediaDevices.webkitGetUserMedia) {\n      // define a Promise that'll be used to load the webcam and read its frames\n      setMessages('Initializing web cam...');\n      const webcamPromise = navigator.mediaDevices\n        .getUserMedia({\n          video: { facingMode: objectDetectionEnvironment },\n          audio: false,\n        })\n        .then(\n          (stream) => {\n            // pass the current frame to the window.stream\n            window.stream = stream;\n            // pass the stream to the videoRef\n            videoRef.current.srcObject = stream;\n            return new Promise((resolve) => {\n              videoRef.current.onloadedmetadata = () => {\n                setMessages('Click \"Start Object Detection\" to continue');\n                setCameraReady(true);\n                resolve();\n              };\n            });\n          },\n          (error) => {\n            setMessages('Couldn\\t start the webcam');\n            console.error(error);\n          }\n        );\n      return webcamPromise;\n    }\n  };\n\n  const loadModel = async () => {\n    try {\n      const model = await cocoSsd.load();\n      setModel(model);\n      setModelLoaded(true);\n    } catch (err) {\n      setMessages('Couldn\\t load the model');\n      setModelLoaded(false);\n      console.log(err);\n    }\n  };\n\n  const detectFromVideoFrame = (model, video) => {\n    model.detect(video).then(\n      (predictions) => {\n        if (video.srcObject) {\n          showDetections(predictions);\n          requestAnimationFrame(() => {\n            detectFromVideoFrame(model, video);\n          });\n        }\n      },\n      (error) => {\n        setMessages('Couldn\\t start the webcam');\n        setCameraReady(false);\n        console.error(error);\n      }\n    );\n  };\n\n  const showDetections = (predictions) => {\n    const ctx = canvasRef.current.getContext('2d');\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    const font = '20px monospace';\n    const outlineColor = '#00e5ff';\n    ctx.font = font;\n    ctx.textBaseline = 'top';\n\n    predictions.forEach((prediction) => {\n      const left = prediction.bbox[0];\n      const top = prediction.bbox[1];\n      const width = prediction.bbox[2];\n      const height = prediction.bbox[3];\n      // Draw the bounding box.\n      ctx.strokeStyle = outlineColor;\n      ctx.lineWidth = 1;\n      ctx.strokeRect(left, top, width, height);\n      // Draw the label background.\n      ctx.fillStyle = outlineColor;\n      const textWidth = ctx.measureText(prediction.class).width;\n      const textHeight = parseInt(font, 10);\n      // draw top left rectangle\n      ctx.fillRect(left, top, textWidth + 10, textHeight + 10);\n      // draw bottom left rectangle\n      ctx.fillRect(left, top + height - textHeight, textWidth + 15, textHeight + 10);\n\n      // Draw the text last to ensure it's on top.\n      ctx.fillStyle = '#000000';\n      ctx.fillText(prediction.class, left, top);\n      ctx.fillText(prediction.score.toFixed(2), left, top + height - textHeight);\n    });\n  };\n\n  const startImageObjectDetection = () => {\n    performImageObjectDetection();\n  };\n\n  const performImageObjectDetection = () => {\n    toggleWebCamStream(true);\n    setObjectDetectionOccuring(true);\n    setMessages('Detecting objects...');\n  };\n\n  const stopImageObjectDetection = () => {\n    setObjectDetectionOccuring(false);\n    toggleWebCamStream(false);\n    setMessages('Stopped detecting objects...');\n  };\n\n  const toggleWebCamStream = (activate) => {\n    return navigator.mediaDevices\n      .getUserMedia({\n        video: true,\n        audio: false,\n      })\n      .then((stream) => {\n        stream.getTracks().forEach((track) => {\n          if (activate) {\n            if (track.start) track.start();\n            videoRef.current.play();\n          } else {\n            if (track.stop) track.stop();\n            videoRef.current.pause();\n          }\n        });\n      });\n  };\n\n  const toggleWebCamEnvironment = () => {\n    if (objectDetectionEnvironment === 'environment') {\n      setObjectDetectionEnvironment('user');\n    } else {\n      setObjectDetectionEnvironment('environment');\n    }\n  };\n\n  const CameraActionButton = () => {\n    if (modelLoaded && cameraReady && !objectDetectionOccuring) {\n      return (\n        <Button color=\"primary\" onClick={() => startImageObjectDetection()}>\n          Start Object Detection\n        </Button>\n      );\n    }\n    if (modelLoaded && cameraReady && objectDetectionOccuring) {\n      return (\n        <Button color=\"primary\" className=\"p-2\"onClick={() => stopImageObjectDetection()}>\n          Stop Detection\n        </Button>\n      );\n    }\n    return <></>;\n  };\n\n  const CameraEnvironmentButton = () => {\n    if (modelLoaded && cameraReady && objectDetectionOccuring) {\n      return (\n        <Button color=\"primary\" className=\"p-2\" onClick={() => toggleWebCamEnvironment()}>\n          Change Camera\n        </Button>\n      );\n    }\n    return <></>;\n  };\n\n  const calcVideoWidth = () => {\n    if (isWidthUp('md', props.width)) {\n      return 720;\n    } else {\n      return window.innerWidth - 40;\n    }\n  };\n\n  const calcVideoHeight = () => {\n    let h = calcVideoWidth();\n    return Math.ceil(h * aspectRatioFactor);      \n  };\n  \n  const Instructions = () => {\n    if (!modelLoaded && !cameraReady) {\n      return <div className=\"pb-2\">{locData.objectdetectioninstructionscamera}</div>;\n    }\n    return <></>;\n  };\n  \n  const Messages = ({ messages }) => {\n    return <Alert>{messages}</Alert>;\n  };\n\n  return (\n    <Grid container spacing={0}>\n      <Grid item xs={12} sm={12} md={6} lg={4} xl={4}>\n        <Card className=\"card white-bg-color\" elevation={0}>\n          <CardContent className=\"p-1\">\n            <h2>{locData.objectdetectioncamera}</h2>\n            <Instructions />\n            <Messages messages={messages} />\n          </CardContent>\n          <CardActions className=\"p-1\">\n            <CameraActionButton />\n            <CameraEnvironmentButton />\n          </CardActions>\n        </Card>\n      </Grid>\n      <Grid item xs={12} sm={12} md={6} lg={8} xl={8}>\n        <video\n          ref={videoRef}\n          style={{\n            position: 'fixed',\n            top: videoTop,\n            left: videoLeft,\n            zIndex: 6000,\n          }}\n          width={calcVideoWidth()}\n          height={calcVideoHeight()}\n          autoPlay\n          muted\n          playsInline\n        />\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'fixed',\n            top: videoTop,\n            left: videoLeft,\n            zIndex: 7000,\n          }}\n          width={calcVideoWidth()}\n          height={calcVideoHeight()}\n        />\n      </Grid>\n    </Grid>\n  );\n}\n\nexport default withWidth()(ObjectDetectionCamera);\n"],"sourceRoot":""}