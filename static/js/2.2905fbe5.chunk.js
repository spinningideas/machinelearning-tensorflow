/*! For license information please see 2.2905fbe5.chunk.js.LICENSE.txt */
(this["webpackJsonpmachinelearning-tensorflow"]=this["webpackJsonpmachinelearning-tensorflow"]||[]).push([[2],{506:function(e,n,t){var a=t(507),r=t(22),o=t(513),i=t(514),c=t(515);!function(e,n,t){"use strict";var s={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}},u=function(){function e(n,t){i(this,e),this.modelPath=t||"https://storage.googleapis.com/tfjs-models/savedmodel/".concat(this.getPrefix(n),"/model.json")}return c(e,[{key:"getPrefix",value:function(e){return"lite_mobilenet_v2"===e?"ssd"+e:"ssd_"+e}},{key:"load",value:function(){var e=o(r.mark((function e(){var a,o;return r.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,n.loadGraphModel(this.modelPath);case 2:return this.model=e.sent,a=t.zeros([1,300,300,3],"int32"),e.next=6,this.model.executeAsync(a);case 6:return o=e.sent,e.next=9,Promise.all(o.map((function(e){return e.data()})));case 9:o.map((function(e){return e.dispose()})),a.dispose();case 11:case"end":return e.stop()}}),e,this)})));function a(){return e.apply(this,arguments)}return a}()},{key:"infer",value:function(){var e=o(r.mark((function e(n,o,i){var c,s,u,l,d,p,h,f,v,m,g,b,x;return r.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return c=t.tidy((function(){return n instanceof t.Tensor||(n=t.browser.fromPixels(n)),n.expandDims(0)})),s=c.shape[1],u=c.shape[2],e.next=5,this.model.executeAsync(c);case 5:return l=e.sent,d=l[0].dataSync(),p=l[1].dataSync(),c.dispose(),t.dispose(l),h=this.calculateMaxScores(d,l[0].shape[1],l[0].shape[2]),f=a(h,2),v=f[0],m=f[1],g=t.getBackend(),"webgl"===t.getBackend()&&t.setBackend("cpu"),b=t.tidy((function(){var e=t.tensor2d(p,[l[1].shape[1],l[1].shape[3]]);return t.image.nonMaxSuppression(e,v,o,i,i)})),x=b.dataSync(),e.abrupt("return",(b.dispose(),g!==t.getBackend()&&t.setBackend(g),this.buildDetectedObjects(u,s,p,v,x,m)));case 13:case"end":return e.stop()}}),e,this)})));function n(n,t,a){return e.apply(this,arguments)}return n}()},{key:"buildDetectedObjects",value:function(e,n,t,a,r,o){for(var i=r.length,c=[],u=0;u<i;u++){for(var l=[],d=0;d<4;d++)l[d]=t[4*r[u]+d];var p=l[0]*n,h=l[1]*e,f=l[2]*n,v=l[3]*e;l[0]=h,l[1]=p,l[2]=v-h,l[3]=f-p,c.push({bbox:l,class:s[o[r[u]]+1].displayName,score:a[r[u]]})}return c}},{key:"calculateMaxScores",value:function(e,n,t){for(var a=[],r=[],o=0;o<n;o++){for(var i=Number.MIN_VALUE,c=-1,s=0;s<t;s++)e[o*t+s]>i&&(i=e[o*t+s],c=s);a[o]=i,r[o]=c}return[a,r]}},{key:"detect",value:function(){var e=o(r.mark((function e(n){var t,a,o=arguments;return r.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return t=o.length>1&&void 0!==o[1]?o[1]:20,a=o.length>2&&void 0!==o[2]?o[2]:.5,e.abrupt("return",this.infer(n,t,a));case 3:case"end":return e.stop()}}),e,this)})));function n(n){return e.apply(this,arguments)}return n}()},{key:"dispose",value:function(){null!=this.model&&this.model.dispose()}}]),e}();e.ObjectDetection=u,e.load=o(r.mark((function e(){var n,a,o,i,c=arguments;return r.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(n=c.length>0&&void 0!==c[0]?c[0]:{},null!=t){e.next=3;break}throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");case 3:if(a=n.base||"lite_mobilenet_v2",o=n.modelUrl,-1!==["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(a)){e.next=6;break}throw new Error("ObjectDetection constructed with invalid base model "+a+". Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.");case 6:return i=new u(a,o),e.next=9,i.load();case 9:return e.abrupt("return",i);case 10:case"end":return e.stop()}}),e)}))),e.version="2.2.1",Object.defineProperty(e,"__esModule",{value:!0})}(n,t(277),t(169))},507:function(e,n,t){var a=t(508),r=t(509),o=t(510),i=t(512);e.exports=function(e,n){return a(e)||r(e,n)||o(e,n)||i()}},508:function(e,n){e.exports=function(e){if(Array.isArray(e))return e}},509:function(e,n){e.exports=function(e,n){if("undefined"!==typeof Symbol&&Symbol.iterator in Object(e)){var t=[],a=!0,r=!1,o=void 0;try{for(var i,c=e[Symbol.iterator]();!(a=(i=c.next()).done)&&(t.push(i.value),!n||t.length!==n);a=!0);}catch(s){r=!0,o=s}finally{try{a||null==c.return||c.return()}finally{if(r)throw o}}return t}}},510:function(e,n,t){var a=t(511);e.exports=function(e,n){if(e){if("string"===typeof e)return a(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);return"Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(e,n):void 0}}},511:function(e,n){e.exports=function(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,a=new Array(n);t<n;t++)a[t]=e[t];return a}},512:function(e,n){e.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}},513:function(e,n){function t(e,n,t,a,r,o,i){try{var c=e[o](i),s=c.value}catch(u){return void t(u)}c.done?n(s):Promise.resolve(s).then(a,r)}e.exports=function(e){return function(){var n=this,a=arguments;return new Promise((function(r,o){var i=e.apply(n,a);function c(e){t(i,r,o,c,s,"next",e)}function s(e){t(i,r,o,c,s,"throw",e)}c(void 0)}))}}},514:function(e,n){e.exports=function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}},515:function(e,n){function t(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}e.exports=function(e,n,a){return n&&t(e.prototype,n),a&&t(e,a),e}},520:function(e,n,t){"use strict";var a,r,o,i=t(169),c=t(57),s=t(22),u=t.n(s),l=t(181),d=t(36),p=t(66),h=t(67),f=t(70),v=t(68),m=t(69),g={},b={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function x(e){if(!(e in g)){var n=function(e){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var n=function(e){if("undefined"!==typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(e);if(n.addEventListener("webglcontextlost",(function(n){n.preventDefault(),delete g[e]}),!1),1===e)return n.getContext("webgl",b)||n.getContext("experimental-webgl",b);return n.getContext("webgl2",b)}(e);if(null===n)return console.log("Could not get context for WebGL version",e),null;g[e]=n}var t=g[e];return t.isContextLost()?(delete g[e],x(e)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),g[e])}function k(e,n){return[n,e]}function I(e){var n=i.util.sizeFromShape(e),t=Math.ceil(n/4);return i.util.sizeToSquarishShape(t)}function y(e,n){return[Math.max(1,Math.ceil(n/2)),Math.max(1,Math.ceil(e/2))]}function C(e,n){var t,a,r,o,c,s,u,l,d,p=e;return 2===Object(i.env)().getNumber("WEBGL_VERSION")?(t=p.R32F,a=p.R16F,r=p.RGBA16F,o=p.RGBA32F,c=p.RED,s=4,u=1,l=p.HALF_FLOAT,d=p.FLOAT):(t=e.RGBA,a=e.RGBA,r=e.RGBA,o=p.RGBA,c=e.RGBA,s=4,u=4,l=null!=n?n.HALF_FLOAT_OES:null,d=e.FLOAT),{internalFormatFloat:t,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:o,textureFormatFloat:c,downloadTextureFormat:e.RGBA,downloadUnpackNumChannels:s,defaultNumChannels:u,textureTypeHalfFloat:l,textureTypeFloat:d}}function N(e,n){var t=n();return Object(i.env)().getBool("DEBUG")&&function(e){var n=e.getError();if(n!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,n){switch(n){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(n)}}(e,n))}(e),t}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(a||(a={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(r||(r={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(o||(o={}));function T(e){return!!(Object(i.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function R(e,n){return W(e,(function(){return e.getExtension(n)}),'Extension "'+n+'" not supported on this browser.')}function w(e,n){var t=W(e,(function(){return e.createShader(e.FRAGMENT_SHADER)}),"Unable to create fragment WebGLShader.");if(N(e,(function(){return e.shaderSource(t,n)})),N(e,(function(){return e.compileShader(t)})),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw function(e,n){var t=F.exec(n);if(null==t)return console.log("Couldn't parse line number in error: ".concat(n)),void console.log(e);for(var a=+t[1],r=e.split("\n"),o=r.length.toString().length+2,c=r.map((function(e,n){return i.util.rightPad((n+1).toString(),o)+e})),s=0,u=0;u<c.length;u++)s=Math.max(c[u].length,s);var l=c.slice(0,a-1),d=c.slice(a-1,a),p=c.slice(a);console.log(l.join("\n")),console.log(n.split("\n")[0]),console.log("%c ".concat(i.util.rightPad(d[0],s)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join("\n"))}(n,e.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var S,O,F=/ERROR: [0-9]+:([0-9]+):/g;function A(e,n){if(N(e,(function(){return e.validateProgram(n)})),!1===e.getProgramParameter(n,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Shader program validation failed.")}function E(e,n,t,a,r,o,i){var c=e.getAttribLocation(n,t);return-1!==c&&(N(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,a)})),N(e,(function(){return e.vertexAttribPointer(c,r,e.FLOAT,!1,o,i)})),N(e,(function(){return e.enableVertexAttribArray(c)})),!0)}function _(e,n,t){return W(e,(function(){return e.getUniformLocation(n,t)}),'uniform "'+t+'" not present in program.')}function D(e,n,t){return e.getUniformLocation(n,t)}function P(e,n,t,a){N(e,(function(){return function(e,n,t){j(e,t),N(e,(function(){return e.activeTexture(e.TEXTURE0+t)})),N(e,(function(){return e.bindTexture(e.TEXTURE_2D,n)}))}(e,n,a)})),N(e,(function(){return e.uniform1i(t,a)}))}function M(e,n,t){N(e,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,t)})),N(e,(function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0)}))}function L(e,n){N(e,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,n)})),N(e,(function(){return e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)}))}function B(e){var n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,n){switch(n){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(n)}}(e,n))}function W(e,n,t){var a=N(e,(function(){return n()}));if(null==a)throw new Error(t);return a}function j(e,n){var t=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=n+e.TEXTURE0;if(a<e.TEXTURE0||a>t){var r="[gl.TEXTURE0, gl.TEXTURE".concat(t,"]");throw new Error("textureUnit must be in ".concat(r,"."))}}function V(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return i.util.sizeFromShape(e.slice(0,e.length-n))}function z(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function G(e){var n=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(n=[V(e)].concat(Object(l.a)(z(e)))),n}function U(e){return e%2===0}function H(e,n){if(e=e.slice(-2),n=n.slice(-2),i.util.arraysEqual(e,n))return!0;if(!e.length||!n.length)return!0;if(0===e[0]||0===e[1]||0===n[0]||0===n[1])return!0;if(e.length!==n.length){var t=e.slice(-1)[0],a=n.slice(-1)[0];if(t===a)return!0;if(U(t)&&U(a)&&(1===e[0]||1===n[0]))return!0}return e[1]===n[1]&&U(e[0])&&U(n[0])}function X(e,n){return null!=e.getExtension(n)}function q(e){try{if(null!=x(e))return!0}catch(n){return console.log("Error when getting WebGL context: ",n),!1}return!1}function K(e){if(0===e)return!1;var n=x(e);if(1!==e){if(X(n,"EXT_color_buffer_float"))return Y(n);var t="EXT_color_buffer_half_float";if(X(n,t)){var a=n.getExtension(t);return function(e,n){var t=C(e,n),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);var r=1,o=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatHalfFloat,r,o,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);var i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);var c=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(i),c}(n,a)}return!1}return!!X(n,"OES_texture_float")&&(!!X(n,"WEBGL_color_buffer_float")&&Y(n))}function Y(e){var n=C(e),t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatFloat,1,1,0,n.textureFormatFloat,n.textureTypeFloat,null);var a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);var r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(a),r}function Q(e,n){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&i.util.assert("complex64"!==e.dtype,(function(){return"".concat(n," does not support complex64 tensors ")+"in the WebGL backend."}))}))}var Z=Object(i.env)();function J(){var e,n,t,a,r,o,c,s,u,l;return 2===Object(i.env)().getNumber("WEBGL_VERSION")?(e="#version 300 es",n="in",t="out",a="in",r="texture",o="outputColor",c="out vec4 outputColor;",s="\n      bool isnan_custom(float val) {\n        return (val > 0.0 || val < 0.0) ? false : val != 0.0;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ",u="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",n="attribute",t="varying",a="varying",r="texture2D",o="gl_FragColor",c="",s="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:n,varyingVs:t,varyingFs:a,texture2D:r,output:o,defineOutput:c,defineSpecialNaN:s,defineSpecialInf:u,defineRound:l}}function $(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index",a=i.util.computeStrides(n);return a.map((function(n,r){var o="int ".concat(e[r]," = ").concat(t," / ").concat(n),i=r===a.length-1?"int ".concat(e[r+1]," = ").concat(t," - ").concat(e[r]," * ").concat(n):"index -= ".concat(e[r]," * ").concat(n);return"".concat(o,"; ").concat(i,";")})).join("")}function ee(e){var n=i.util.computeStrides(e).map((function(e){return e.toString()}));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(n[0]," + coords.y * ").concat(n[1]," + coords.z;\n  }\n")}Z.registerFlag("HAS_WEBGL",(function(){return Z.getNumber("WEBGL_VERSION")>0})),Z.registerFlag("WEBGL_VERSION",(function(){return q(2)?2:q(1)?1:0})),Z.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(function(){return!1})),Z.registerFlag("WEBGL_BUFFER_SUPPORTED",(function(){return 2===Z.get("WEBGL_VERSION")})),Z.registerFlag("WEBGL_CPU_FORWARD",(function(){return!0})),Z.registerFlag("WEBGL_FORCE_F16_TEXTURES",(function(){return!1})),Z.registerFlag("WEBGL_PACK",(function(){return Z.getBool("HAS_WEBGL")})),Z.registerFlag("WEBGL_PACK_NORMALIZATION",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_CLIP",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_DEPTHWISECONV",(function(){return!1})),Z.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_PACK_REDUCE",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_LAZILY_UNPACK",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_CONV_IM2COL",(function(){return Z.getBool("WEBGL_PACK")})),Z.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(function(){return function(e){if(null==S){var n=x(e);S=n.getParameter(n.MAX_TEXTURE_SIZE)}return S}(Z.getNumber("WEBGL_VERSION"))})),Z.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(function(){return function(e){if(null==O){var n=x(e);O=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,O)}(Z.getNumber("WEBGL_VERSION"))})),Z.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(function(){var e=Z.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;var n=x(e);return X(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:X(n,"EXT_disjoint_timer_query")?1:0}(e)})),Z.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(function(){return Z.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!i.device_util.isMobile()})),Z.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(function(){return function(e){if(0===e)return!1;var n=x(e);if(1===e){if(!X(n,"OES_texture_float"))return!1}else if(!X(n,"EXT_color_buffer_float"))return!1;return Y(n)}(Z.getNumber("WEBGL_VERSION"))})),Z.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(function(){return!Z.getBool("WEBGL_FORCE_F16_TEXTURES")&&Z.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")})),Z.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(function(){return K(Z.getNumber("WEBGL_VERSION"))})),Z.registerFlag("WEBGL_FENCE_API_ENABLED",(function(){return 2===(e=Z.getNumber("WEBGL_VERSION"))&&null!=x(e).fenceSync;var e})),Z.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(function(){return Z.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0})),Z.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(function(){return-1}),(function(e){if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))}));var ne="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",te=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=a.DENSE;var t=I(n),r=J();this.outputShape=n,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat($(["r","c","d"],n),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0],", ").concat(t[1],"));\n        int index = 4 * (resTexRC.x * ").concat(t[1]," + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(r.output," = result;\n      }\n    ")},ae=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=a.DENSE;var t=I(n),r=J();this.outputShape=n,this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat($(["r","c","d"],n),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n          vec2(").concat(t[0],", ").concat(t[1],"));\n        int index = 4 * (resTexRC.x * ").concat(t[1]," + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(r.output," = result;\n      }\n    ")},re=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.outTexUsage=r.DOWNLOAD;var t=J();this.outputShape=n,this.userCode="\n      ".concat(ne,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")},oe=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=r.DOWNLOAD;var t=J();this.outputShape=n,this.userCode="\n      ".concat(ne,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")},ie=function e(n,t){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Object(p.a)(this,e),this.variableNames=["A"];var r=J(),o=Object(c.a)(t,2),i=o[0],s=o[1];this.outputShape=n;var u="result";a&&(u="floor(result * 255. + 0.5)"),this.userCode="\n      ".concat(ee(n),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        int flatIndex = getFlatIndex(coords);\n        int offset = imod(flatIndex, 4);\n\n        flatIndex = idiv(flatIndex, 4, 1.);\n\n        int r = flatIndex / ").concat(s,";\n        int c = imod(flatIndex, ").concat(s,");\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(").concat(s,".0, ").concat(i,".0);\n        vec4 values = ").concat(r.texture2D,"(A, uv);\n\n        float result;\n\n        if(offset == 0) {\n          result = values[0];\n        } else if(offset == 1) {\n          result = values[1];\n        } else if(offset == 2) {\n          result = values[2];\n        } else {\n          result = values[3];\n        }\n\n        ").concat(r.output," = vec4(").concat(u,", 0., 0., 0.);\n      }\n    ")},ce=function e(n,t){var a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=J(),o=Object(c.a)(t,2),i=o[0],s=o[1];this.outputShape=n;var u="",l="result";a&&(l="floor(result * 255. + 0.5)");for(var d=0;d<=1;d++)for(var h=0;h<=1;h++){var f=2*d+h;u+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(h," < ").concat(n[2],") {\n            localCoords[2] += ").concat(h,";\n            if(localCoords[1] + ").concat(d," < ").concat(n[1],") {\n              localCoords[1] += ").concat(d,";\n\n              flatIndex = getFlatIndex(localCoords);\n              offset = imod(flatIndex, 4);\n\n              flatIndex = idiv(flatIndex, 4, 1.);\n\n              r = flatIndex / ").concat(s,";\n              c = imod(flatIndex, ").concat(s,");\n              uv = (vec2(c, r) + halfCR) / vec2(").concat(s,".0, ").concat(i,".0);\n              values = ").concat(r.texture2D,"(A, uv);\n\n              if(offset == 0) {\n                result[").concat(f,"] = values[0];\n              } else if(offset == 1) {\n                result[").concat(f,"] = values[1];\n              } else if(offset == 2) {\n                result[").concat(f,"] = values[2];\n              } else {\n                result[").concat(f,"] = values[3];\n              }\n            }\n          }\n        ")}this.userCode="\n      ".concat(ee(n),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n\n        vec4 result = vec4(0.);\n        int flatIndex, r, c, offset;\n        ivec3 localCoords;\n        vec2 uv;\n        vec4 values;\n\n        ").concat(u,"\n\n        ").concat(r.output," = ").concat(l,";\n      }\n    ")};function se(e){var n=J();return function(e,n){var t=W(e,(function(){return e.createShader(e.VERTEX_SHADER)}),"Unable to create vertex WebGLShader.");if(N(e,(function(){return e.shaderSource(t,n)})),N(e,(function(){return e.compileShader(t)})),!1===e.getShaderParameter(t,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}(e,"".concat(n.version,"\n    precision highp float;\n    ").concat(n.attribute," vec3 clipSpacePos;\n    ").concat(n.attribute," vec2 uv;\n    ").concat(n.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function ue(e){return function(e,n){var t=W(e,(function(){return e.createBuffer()}),"Unable to create WebGLBuffer");return N(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,t)})),N(e,(function(){return e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW)})),t}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function le(e){return function(e,n){var t=W(e,(function(){return e.createBuffer()}),"Unable to create WebGLBuffer");return N(e,(function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,t)})),N(e,(function(){return e.bufferData(e.ELEMENT_ARRAY_BUFFER,n,e.STATIC_DRAW)})),t}(e,new Uint16Array([0,1,2,2,1,3]))}function de(e,n,t,a,r,o){!function(e,n){var t=Object(i.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||n<=0){var a="[".concat(e,"x").concat(n,"]");throw new Error("Requested texture size "+a+" is invalid.")}if(e>t||n>t){var r="[".concat(e,"x").concat(n,"]"),o="[".concat(t,"x").concat(t,"]");throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+o+".")}}(n,t);var c=function(e){return W(e,(function(){return e.createTexture()}),"Unable to create WebGLTexture.")}(e),s=e.TEXTURE_2D;return N(e,(function(){return e.bindTexture(s,c)})),N(e,(function(){return e.texParameteri(s,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)})),N(e,(function(){return e.texParameteri(s,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)})),N(e,(function(){return e.texParameteri(s,e.TEXTURE_MIN_FILTER,e.NEAREST)})),N(e,(function(){return e.texParameteri(s,e.TEXTURE_MAG_FILTER,e.NEAREST)})),N(e,(function(){return e.texImage2D(s,0,a,n,t,0,r,o,null)})),N(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)})),c}function pe(e){return e.internalFormatFloat}function he(e){return e.internalFormatHalfFloat}function fe(e){return e.downloadTextureFormat}function ve(e){return e.internalFormatPackedFloat}function me(e){return e.internalFormatPackedHalfFloat}function ge(e,n,t,a,r,o,i,s){var u=e,l=new Float32Array(function(e,n){var t=y(e,n),a=Object(c.a)(t,2);return a[0]*a[1]*4}(o,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,n),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}var be=function(){function e(n){Object(p.a)(this,e),this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var t=Object(i.env)().getNumber("WEBGL_VERSION");null!=n?(this.gl=n,function(e,n){g[e]=n}(t,n)):this.gl=x(t);var a="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(1===Object(i.env)().getNumber("WEBGL_VERSION")){var o="OES_texture_half_float";if(this.textureFloatExtension=R(this.gl,"OES_texture_float"),X(this.gl,o))this.textureHalfFloatExtension=R(this.gl,o);else if(Object(i.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(a),X(this.gl,r))this.colorBufferHalfFloatExtension=R(this.gl,r);else if(Object(i.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(a="EXT_color_buffer_float",X(this.gl,a))this.colorBufferFloatExtension=this.gl.getExtension(a);else{if(!X(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=ue(this.gl),this.indexBuffer=le(this.gl),this.framebuffer=function(e){return W(e,(function(){return e.createFramebuffer()}),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=C(this.gl,this.textureHalfFloatExtension)}return Object(h.a)(e,[{key:"dispose",value:function(){var e=this;if(!this.disposed){null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var n=this.gl;N(n,(function(){return n.finish()})),N(n,(function(){return n.bindFramebuffer(n.FRAMEBUFFER,null)})),N(n,(function(){return n.deleteFramebuffer(e.framebuffer)})),N(n,(function(){return n.bindBuffer(n.ARRAY_BUFFER,null)})),N(n,(function(){return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,null)})),N(n,(function(){return n.deleteBuffer(e.indexBuffer)})),this.disposed=!0}}},{key:"createFloat32MatrixTexture",value:function(e,n){return this.throwIfDisposed(),function(e,n,t,a){var r=k(n,t),o=Object(c.a)(r,2);return de(e,o[0],o[1],pe(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,n,this.textureConfig)}},{key:"createFloat16MatrixTexture",value:function(e,n){return this.throwIfDisposed(),function(e,n,t,a){var r=k(n,t),o=Object(c.a)(r,2);return de(e,o[0],o[1],he(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,n,this.textureConfig)}},{key:"createUnsignedBytesMatrixTexture",value:function(e,n){return this.throwIfDisposed(),function(e,n,t,a){var r=k(n,t),o=Object(c.a)(r,2);return de(e,o[0],o[1],fe(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,n,this.textureConfig)}},{key:"uploadPixelDataToTexture",value:function(e,n){this.throwIfDisposed(),function(e,n,t){N(e,(function(){return e.bindTexture(e.TEXTURE_2D,n)})),t.data instanceof Uint8Array?N(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t.width,t.height,0,e.RGBA,e.UNSIGNED_BYTE,t.data)})):N(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t)})),N(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)}))}(this.gl,e,n)}},{key:"uploadDenseMatrixToTexture",value:function(e,n,t,a){this.throwIfDisposed(),function(e,n,t,a,r,o){var i,c,s;N(e,(function(){return e.bindTexture(e.TEXTURE_2D,n)})),r instanceof Uint8Array?(i=new Uint8Array(t*a*4),c=e.UNSIGNED_BYTE,s=e.RGBA):(i=new Float32Array(t*a*4),c=e.FLOAT,s=o.internalFormatPackedFloat),i.set(r),N(e,(function(){return e.texImage2D(e.TEXTURE_2D,0,s,t,a,0,e.RGBA,c,i)})),N(e,(function(){return e.bindTexture(e.TEXTURE_2D,null)}))}(this.gl,e,n,t,a,this.textureConfig)}},{key:"createFloat16PackedMatrixTexture",value:function(e,n){return this.throwIfDisposed(),function(e,n,t,a){var r=y(n,t),o=Object(c.a)(r,2);return de(e,o[0],o[1],me(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,n,this.textureConfig)}},{key:"createPackedMatrixTexture",value:function(e,n){return this.throwIfDisposed(),function(e,n,t,a){var r=y(n,t),o=Object(c.a)(r,2);return de(e,o[0],o[1],ve(a),e.RGBA,e.FLOAT)}(this.gl,e,n,this.textureConfig)}},{key:"deleteMatrixTexture",value:function(e){var n=this;this.throwIfDisposed(),this.outputTexture===e&&(L(this.gl,this.framebuffer),this.outputTexture=null),N(this.gl,(function(){return n.gl.deleteTexture(e)}))}},{key:"downloadByteEncodedFloatMatrixFromOutputTexture",value:function(e,n,t){var a=this;return this.downloadMatrixDriver(e,(function(){return function(e,n,t,a){var r=k(n,t),o=Object(c.a)(r,2),i=o[0],s=o[1],u=new Uint8Array(n*t*4);return N(e,(function(){return e.readPixels(0,0,i,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,u)})),new Float32Array(u.buffer)}(a.gl,n,t,a.textureConfig)}))}},{key:"downloadPackedMatrixFromBuffer",value:function(e,n,t,a,r,o){return ge(this.gl,e,0,0,0,r,o,this.textureConfig)}},{key:"downloadFloat32MatrixFromBuffer",value:function(e,n){return function(e,n,t){var a=e,r=new Float32Array(t);return a.bindBuffer(a.PIXEL_PACK_BUFFER,n),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,n)}},{key:"createBufferFromTexture",value:function(e,n,t){this.bindTextureToFrameBuffer(e);var a=function(e,n,t,a){var r=e.createBuffer();N(e,(function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,r)}));var o=16*n*t;return N(e,(function(){return e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)})),N(e,(function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,0)})),N(e,(function(){return e.bindBuffer(e.PIXEL_PACK_BUFFER,null)})),r}(this.gl,n,t,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}},{key:"createAndWaitForFence",value:function(){var e=this.createFence(this.gl);return this.pollFence(e)}},{key:"createFence",value:function(e){var n,t,a=this;if(Object(i.env)().getBool("WEBGL_FENCE_API_ENABLED")){var r=e,o=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),t=function(){var e=r.clientWaitSync(o,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},n=o}else Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),t=function(){return a.isQueryAvailable(n,Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):t=function(){return!0};return{query:n,isFencePassed:t}}},{key:"downloadMatrixFromPackedTexture",value:function(e,n,t){var a=this;return this.downloadMatrixDriver(e,(function(){return function(e,n,t){var a=new Float32Array(n*t*4);return N(e,(function(){return e.readPixels(0,0,t,n,e.RGBA,e.FLOAT,a)})),a}(a.gl,n,t)}))}},{key:"createProgram",value:function(e){this.throwIfDisposed();var n=this.gl,t=w(n,e),a=se(n),r=function(e){return W(e,(function(){return e.createProgram()}),"Unable to create WebGLProgram.")}(n);return N(n,(function(){return n.attachShader(r,a)})),N(n,(function(){return n.attachShader(r,t)})),function(e,n){if(N(e,(function(){return e.linkProgram(n)})),!1===e.getProgramParameter(n,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(n)),new Error("Failed to link vertex and fragment shaders.")}(n,r),this.debug&&A(n,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=function(e,n,t){return N(e,(function(){return e.bindBuffer(e.ARRAY_BUFFER,t)})),E(e,n,"clipSpacePos",t,3,20,0)&&E(e,n,"uv",t,2,20,12)}(n,this.program,this.vertexBuffer)),r}},{key:"deleteProgram",value:function(e){var n=this;this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&N(this.gl,(function(){return n.gl.deleteProgram(e)}))}},{key:"setProgram",value:function(e){var n=this;this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&A(this.gl,this.program),N(this.gl,(function(){return n.gl.useProgram(e)}))}},{key:"getUniformLocation",value:function(e,n){var t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),t?_(this.gl,e,n):D(this.gl,e,n)}},{key:"getAttributeLocation",value:function(e,n){var t=this;return this.throwIfDisposed(),N(this.gl,(function(){return t.gl.getAttribLocation(e,n)}))}},{key:"getUniformLocationNoThrow",value:function(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}},{key:"setInputMatrixTexture",value:function(e,n,t){this.throwIfDisposed(),this.throwIfNoProgram(),P(this.gl,e,n,t)}},{key:"setOutputMatrixTexture",value:function(e,n,t){this.setOutputMatrixTextureDriver(e,t,n)}},{key:"setOutputPackedMatrixTexture",value:function(e,n,t){this.throwIfDisposed();var a=y(n,t),r=Object(c.a)(a,2),o=r[0],i=r[1];this.setOutputMatrixTextureDriver(e,o,i)}},{key:"setOutputMatrixWriteRegion",value:function(e,n,t,a){this.setOutputMatrixWriteRegionDriver(t,e,a,n)}},{key:"setOutputPackedMatrixWriteRegion",value:function(e,n,t,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}},{key:"debugValidate",value:function(){null!=this.program&&A(this.gl,this.program),B(this.gl)}},{key:"executeProgram",value:function(){this.throwIfDisposed(),this.throwIfNoProgram();var e=this.gl;this.debug&&this.debugValidate(),N(e,(function(){return e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)}))}},{key:"blockUntilAllProgramsCompleted",value:function(){var e=this;this.throwIfDisposed(),N(this.gl,(function(){return e.gl.finish()}))}},{key:"getQueryTimerExtension",value:function(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=R(this.gl,2===Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}},{key:"getQueryTimerExtensionWebGL2",value:function(){return this.getQueryTimerExtension()}},{key:"getQueryTimerExtensionWebGL1",value:function(){return this.getQueryTimerExtension()}},{key:"beginQuery",value:function(){if(2===Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.gl,n=this.getQueryTimerExtensionWebGL2(),t=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,t),t}var a=this.getQueryTimerExtensionWebGL1(),r=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,r),r}},{key:"endQuery",value:function(){if(2!==Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){var e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}else{var n=this.gl,t=this.getQueryTimerExtensionWebGL2();n.endQuery(t.TIME_ELAPSED_EXT)}}},{key:"waitForQueryAndGetTime",value:function(){var e=Object(d.a)(u.a.mark((function e(n){var t=this;return u.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,i.util.repeatedTry((function(){return t.disposed||t.isQueryAvailable(n,Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}));case 2:return e.abrupt("return",this.getQueryTime(n,Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")));case 3:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}()},{key:"getQueryTime",value:function(e,n){if(0===n)return null;if(2===n){var t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}var a=this.getQueryTimerExtensionWebGL1();return a.getQueryObjectEXT(e,a.QUERY_RESULT_EXT)/1e6}},{key:"isQueryAvailable",value:function(e,n){if(0===n)return!0;if(2===n){var t=this.gl,a=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),r&&!this.disjoint}var o=this.getQueryTimerExtensionWebGL1(),i=o.getQueryObjectEXT(e,o.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),i&&!this.disjoint}},{key:"pollFence",value:function(e){var n=this;return new Promise((function(t){n.addItemToPoll((function(){return e.isFencePassed()}),(function(){return t()}))}))}},{key:"pollItems",value:function(){for(var e=function(e){for(var n=0;n<e.length;++n){if(!e[n]())break}return n-1}(this.itemsToPoll.map((function(e){return e.isDoneFn}))),n=0;n<=e;++n){(0,this.itemsToPoll[n].resolveFn)()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}},{key:"addItemToPoll",value:function(e,n){var t=this;this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1||i.util.repeatedTry((function(){return t.pollItems(),0===t.itemsToPoll.length}))}},{key:"bindTextureToFrameBuffer",value:function(e){this.throwIfDisposed(),M(this.gl,e,this.framebuffer),this.debug&&B(this.gl)}},{key:"unbindTextureToFrameBuffer",value:function(){null!=this.outputTexture?(M(this.gl,this.outputTexture,this.framebuffer),this.debug&&B(this.gl)):L(this.gl,this.framebuffer)}},{key:"downloadMatrixDriver",value:function(e,n){this.bindTextureToFrameBuffer(e);var t=n();return this.unbindTextureToFrameBuffer(),t}},{key:"setOutputMatrixTextureDriver",value:function(e,n,t){this.throwIfDisposed();var a=this.gl;M(a,e,this.framebuffer),this.debug&&B(a),this.outputTexture=e,N(a,(function(){return a.viewport(0,0,n,t)})),N(a,(function(){return a.scissor(0,0,n,t)}))}},{key:"setOutputMatrixWriteRegionDriver",value:function(e,n,t,a){var r=this;this.throwIfDisposed(),N(this.gl,(function(){return r.gl.scissor(e,n,t,a)}))}},{key:"throwIfDisposed",value:function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}},{key:"throwIfNoProgram",value:function(){if(null==this.program)throw new Error("No GPU program is currently set.")}},{key:"debug",get:function(){return Object(i.env)().getBool("DEBUG")}}]),e}();var xe=i.backend_util.getBroadcastDims;function ke(e,n,t,a){var r=[];e.forEach((function(e){var n=i.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?r.push("uniform float ".concat(e.name).concat(n>1?"[".concat(n,"]"):"",";")):(r.push("uniform sampler2D ".concat(e.name,";")),r.push("uniform int offset".concat(e.name,";")))}));var o,c,s=r.join("\n"),u=e.map((function(e){return function(e,n){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a="";a+=t?ye(e):Ie(e);var r=e.shapeInfo.logicalShape,o=n.logicalShape;r.length<=o.length&&(a+=t?Oe(e,n):Fe(e,n));return a}(e,n,a)})).join("\n"),l=n.texShape,d=J(),p=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(d),h=function(e){return"".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(Ce,"\n    ").concat(Ne,"\n    ").concat(Te,"\n  ")}(d);return n.isPacked?(o=function(e,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n){var t=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(1===t[0])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return 2 * (resTexRC.x * ").concat(t[1]," + resTexRC.y);\n    }\n  ")}(0,n);case 2:return function(e,n){var t=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)];if(i.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");var a=Math.ceil(e[1]/2);return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,n);case 3:return function(e,n){var t=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],a=Math.ceil(e[2]/2),r=a*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,n);default:return function(e,n){for(var t=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],a=Math.ceil(e[e.length-1]/2),r=a*Math.ceil(e[e.length-2]/2),o=r,i="",c="b, r, c",s=2;s<e.length-1;s++)o*=e[e.length-s-1],i="\n      int b".concat(s," = index / ").concat(o,";\n      index -= b").concat(s," * ").concat(o,";\n    ")+i,c="b".concat(s,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(r,";\n      index -= b * ").concat(r,";\n\n      int r = 2 * (index / ").concat(a,");\n      int c = imod(index, ").concat(a,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,n)}}(n.logicalShape,l),c=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(d)):(o=function(e,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,n){if(1===n[0])return"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(n[1],".0);\n      }\n    ");if(1===n[1])return"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(n[0],".0);\n      }\n    ");return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      return resTexRC.x * ").concat(n[1]," + resTexRC.y;\n    }\n  ")}(0,n);case 2:return function(e,n){if(i.util.arraysEqual(e,n))return"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(n[0],", ").concat(n[1],"));\n      }\n    ");if(1===e[1])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(n[0],", ").concat(n[1],"));\n        int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(n[0],", ").concat(n[1],"));\n        int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,n);case 3:return function(e,n){var t=$(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      ").concat(t,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,n);case 4:return function(e,n){var t=$(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n      ").concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,n);case 5:return function(e,n){var t=$(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(n[0],",\n                             ").concat(n[1],"));\n\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n\n      ").concat(t,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,n);case 6:return function(e,n){var t=$(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(n[0],", ").concat(n[1],"));\n      int index = resTexRC.x * ").concat(n[1]," + resTexRC.y;\n\n      ").concat(t,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,n);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(n.logicalShape,l),c=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(d)),a&&(h+=Re),[h,p,c,s,o,u,t].join("\n")}function Ie(e){var n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e){var n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(t,"() {return ").concat(n,";}");var a=Object(c.a)(e.shapeInfo.texShape,2),r=a[0],o=a[1];if(1===r&&1===o)return"\n      float ".concat(t,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");var i=Object(c.a)(e.shapeInfo.texShape,2),s=i[0],u=i[1],l=we(n);return"\n    float ".concat(t,"() {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(u,", ").concat(l,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 1:return function(e){var n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(t,"(int index) {\n        ").concat(Se(e),"\n      }\n    ");var a=e.shapeInfo.texShape,r=a[0],o=a[1];if(1===o&&1===r)return"\n      float ".concat(t,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");var i=we(n);if(1===o)return"\n      float ".concat(t,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(r,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===r)return"\n      float ".concat(t,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");return"\n    float ".concat(t,"(int index) {\n      vec2 uv = uvFromFlat(").concat(r,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 2:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape;if(null!=r&&i.util.arraysEqual(n,r)){var o=r[0],c=r[1];return"\n    float ".concat(a,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(c,".0, ").concat(o,".0);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}var s=i.util.squeezeShape(n),u=s.newShape,l=s.keptDims,d=u;if(d.length<n.length){var p=Ee(e,d),h=["row","col"];return"\n      ".concat(Ie(p),"\n      float ").concat(a,"(int row, int col) {\n        return ").concat(a,"(").concat(_e(h,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(Se(e),"\n      }\n    ");var f=r[0],v=r[1],m=we(t);if(1===v)return"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(m,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(f,".0);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ");if(1===f)return"\n    float ".concat(a,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(m,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(v,".0, 0.5);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ");return"\n  float ".concat(a,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(m,";\n    vec2 uv = uvFromFlat(").concat(f,", ").concat(v,", index);\n    return sampleTexture(").concat(t,", uv);\n  }\n")}(e);case 3:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n[1]*n[2],o=n[2],c=i.util.squeezeShape(n),s=c.newShape,u=c.keptDims,l=s;if(l.length<n.length){var d=Ee(e,l),p=["row","col","depth"];return"\n        ".concat(Ie(d),"\n        float ").concat(a,"(int row, int col, int depth) {\n          return ").concat(a,"(").concat(_e(p,u),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(r,", ").concat(o,", 1)));\n        ").concat(Se(e),"\n      }\n    ");var h=e.shapeInfo.texShape,f=h[0],v=h[1],m=e.shapeInfo.flatOffset;if(v===r&&null==m)return"\n        float ".concat(a,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(v,".0, ").concat(f,".0);\n          return sampleTexture(").concat(t,", uv);\n        }\n      ");if(v===o&&null==m)return"\n    float ".concat(a,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(v,".0, ").concat(f,".0);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ");var g=we(t);return"\n      float ".concat(a,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(r," + col * ").concat(o," + depth + ").concat(g,";\n        vec2 uv = uvFromFlat(").concat(f,", ").concat(v,", index);\n        return sampleTexture(").concat(t,", uv);\n      }\n  ")}(e);case 4:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n[3],o=n[2]*r,c=n[1]*o,s=i.util.squeezeShape(n),u=s.newShape,l=s.keptDims;if(u.length<n.length){var d=Ee(e,u),p=["row","col","depth","depth2"];return"\n      ".concat(Ie(d),"\n      float ").concat(a,"(int row, int col, int depth, int depth2) {\n        return ").concat(a,"(").concat(_e(p,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(c,", ").concat(o,", ").concat(r,", 1)));\n        ").concat(Se(e),"\n      }\n    ");var h=e.shapeInfo.flatOffset,f=e.shapeInfo.texShape,v=f[0],m=f[1];if(m===c&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(m,".0, ").concat(v,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");if(m===r&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(m,".0, ").concat(v,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");var g=we(t);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(c," + col * ").concat(o," +\n          depth * ").concat(r," + depth2;\n      vec2 uv = uvFromFlat(").concat(v,", ").concat(m,", index + ").concat(g,");\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e);case 5:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n[4],o=n[3]*r,c=n[2]*o,s=n[1]*c,u=i.util.squeezeShape(n),l=u.newShape,d=u.keptDims;if(l.length<n.length){var p=Ee(e,l),h=["row","col","depth","depth2","depth3"];return"\n      ".concat(Ie(p),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(_e(h,d),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(s,", ").concat(c,", ").concat(o,", ").concat(r,")) +\n          depth3;\n        ").concat(Se(e),"\n      }\n    ");var f=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,m=v[0],g=v[1];if(g===s&&null==f)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(c,", ").concat(o,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(g,".0, ").concat(m,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");if(g===r&&null==f)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(n[1]*n[2]*n[3],",\n               ").concat(n[2]*n[3],", ").concat(n[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(g,".0, ").concat(m,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");var b=we(t);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(s," + col * ").concat(c," + depth * ").concat(o," +\n          depth2 * ").concat(r," + depth3 + ").concat(b,";\n      vec2 uv = uvFromFlat(").concat(m,", ").concat(g,", index);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e);case 6:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=i.util.squeezeShape(n),o=r.newShape,c=r.keptDims;if(o.length<n.length){var s=Ee(e,o),u=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(Ie(s),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(_e(u,c),");\n      }\n    ")}var l=n[5],d=n[4]*l,p=n[3]*d,h=n[2]*p,f=n[1]*h;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(f,", ").concat(h,", ").concat(p,", ").concat(d,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(l,", 1)));\n        ").concat(Se(e),"\n      }\n    ");var v=e.shapeInfo.flatOffset,m=e.shapeInfo.texShape,g=m[0],b=m[1];if(b===f&&null==v)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(h,", ").concat(p,", ").concat(d,", ").concat(l,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(b,".0, ").concat(g,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");if(b===l&&null==v)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(n[1]*n[2]*n[3]*n[4],",\n               ").concat(n[2]*n[3]*n[4],",\n               ").concat(n[3]*n[4],",\n               ").concat(n[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(b,".0, ").concat(g,".0);\n        return sampleTexture(").concat(t,", uv);\n      }\n    ");var x=we(t);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(f," + col * ").concat(h," + depth * ").concat(p," +\n          depth2 * ").concat(d," + depth3 * ").concat(l," + depth4 + ").concat(x,";\n      vec2 uv = uvFromFlat(").concat(g,", ").concat(b,", index);\n      return sampleTexture(").concat(t,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function ye(e){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){var n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),a=J();return"\n    vec4 ".concat(t,"() {\n      return ").concat(a.texture2D,"(").concat(n,", halfCR);\n    }\n  ")}(e);case 1:return function(e){var n=e.name,t="get"+n.charAt(0).toUpperCase()+n.slice(1),a=e.shapeInfo.texShape,r=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],o=J();return"\n    vec4 ".concat(t,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(r[0],", ").concat(r[1],", index);\n      return ").concat(o.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e);case 2:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=r[0],c=r[1],s=J();if(null!=r&&i.util.arraysEqual(n,r))return"\n      vec4 ".concat(a,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(c,".0, ").concat(o,".0);\n\n        return ").concat(s.texture2D,"(").concat(t,", uv);\n      }\n    ");var u=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],l=Math.ceil(n[1]/2);return"\n    vec4 ".concat(a,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(l,", ").concat(u[0],", ").concat(u[1],", row, col);\n      return ").concat(s.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e);case 3:return function(e){var n=e.shapeInfo.logicalShape,t=e.name,a="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e.shapeInfo.texShape,o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(1===n[0]){var i=[1,2],c=Ee(e,n.slice(1)),s=["b","row","col"];return"\n        ".concat(ye(c),"\n        vec4 ").concat(a,"(int b, int row, int col) {\n          return ").concat(a,"(").concat(_e(s,i),");\n        }\n      ")}var u=o[0],l=o[1],d=Math.ceil(n[2]/2),p=d*Math.ceil(n[1]/2),h=J();return"\n    vec4 ".concat(a,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(u,", ").concat(l,", ").concat(p,", ").concat(d,", b, row, col);\n      return ").concat(h.texture2D,"(").concat(t,", uv);\n    }\n  ")}(e);default:return function(e){for(var n=e.shapeInfo.logicalShape,t=n.length,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=i[0],s=i[1],u=Math.ceil(n[t-1]/2),l=u*Math.ceil(n[t-2]/2),d="int b, int row, int col",p="b * ".concat(l," + (row / 2) * ").concat(u," + (col / 2)"),h=2;h<t-1;h++)d="int b".concat(h,", ")+d,l*=n[t-h-1],p="b".concat(h," * ").concat(l," + ")+p;var f=J();return"\n    vec4 ".concat(r,"(").concat(d,") {\n      int index = ").concat(p,";\n      int texR = index / ").concat(s,";\n      int texC = index - texR * ").concat(s,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(s,", ").concat(c,");\n      return ").concat(f.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e)}}var Ce="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Ne="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Te="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",Re="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function we(e){return"offset".concat(e)}function Se(e){var n=e.name,t=i.util.sizeFromShape(e.shapeInfo.logicalShape);return t<2?"return ".concat(n,";"):"\n    for (int i = 0; i < ".concat(t,"; i++) {\n      if (i == index) {\n        return ").concat(n,"[i];\n      }\n    }\n  ")}function Oe(e,n){var t,a=e.name,r=a.charAt(0).toUpperCase()+a.slice(1),o="get"+r+"AtOutCoords",c=e.shapeInfo.logicalShape.length,s=n.logicalShape.length,u=xe(e.shapeInfo.logicalShape,n.logicalShape),l=Ae(s),d=s-c,p=["x","y","z","w","u","v"];t=0===c?"":s<2&&u.length>=1?"coords = 0;":u.map((function(e){return"coords.".concat(p[e+d]," = 0;")})).join("\n");var h="";h=s<2&&c>0?"coords":e.shapeInfo.logicalShape.map((function(e,n){return"coords.".concat(p[n+d])})).join(", ");var f="return outputValue;",v=1===i.util.sizeFromShape(e.shapeInfo.logicalShape),m=1===i.util.sizeFromShape(n.logicalShape);if(1!==c||v||m){if(v&&!m)f=1===s?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(u.length){var g=c-2,b=c-1;u.indexOf(g)>-1&&u.indexOf(b)>-1?f="return vec4(outputValue.x);":u.indexOf(g)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":u.indexOf(b)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(o,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(t,"\n      vec4 outputValue = get").concat(r,"(").concat(h,");\n      ").concat(f,"\n    }\n  ")}function Fe(e,n){var t=e.name,a=t.charAt(0).toUpperCase()+t.slice(1),r="get"+a+"AtOutCoords",o=n.texShape,c=e.shapeInfo.texShape,s=e.shapeInfo.logicalShape.length,u=n.logicalShape.length;if(!e.shapeInfo.isUniform&&s===u&&null==e.shapeInfo.flatOffset&&i.util.arraysEqual(c,o))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(t,", resultUV);\n      }\n    ");var l,d=Ae(u),p=xe(e.shapeInfo.logicalShape,n.logicalShape),h=u-s,f=["x","y","z","w","u","v"];l=0===s?"":u<2&&p.length>=1?"coords = 0;":p.map((function(e){return"coords.".concat(f[e+h]," = 0;")})).join("\n");var v="";return v=u<2&&s>0?"coords":e.shapeInfo.logicalShape.map((function(e,n){return"coords.".concat(f[n+h])})).join(", "),"\n    float ".concat(r,"() {\n      ").concat(d," coords = getOutputCoords();\n      ").concat(l,"\n      return get").concat(a,"(").concat(v,");\n    }\n  ")}function Ae(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function Ee(e,n){var t=JSON.parse(JSON.stringify(e));return t.shapeInfo.logicalShape=n,t}function _e(e,n){return n.map((function(n){return e[n]})).join(", ")}function De(e,n,t,a){var r=n.userCode,o=t.map((function(e,t){var a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:n.variableNames[t],shapeInfo:a}})),c=o.map((function(e){return e.shapeInfo})),s={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},u=ke(o,s,r,n.packedInputs),l=e.createProgram(u),d=null,p=e.getUniformLocation(l,"NAN",!1);1===Object(i.env)().getNumber("WEBGL_VERSION")&&(d=e.getUniformLocation(l,"INFINITY",!1));for(var h={},f=0;f<n.variableNames.length;f++){var v=n.variableNames[f];h[v]=e.getUniformLocation(l,v,false),h["offset".concat(v)]=e.getUniformLocation(l,"offset".concat(v),false)}return{program:n,source:u,webGLProgram:l,uniformLocations:h,inShapeInfos:c,outShapeInfo:s,infLoc:d,nanLoc:p}}function Pe(e,n){if(e.length!==n.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(n.length," inputs"));e.forEach((function(e,t){var a=e.logicalShape,r=n[t],o=r.shape;if(!i.util.arraysEqual(a,o))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(o," must match"));if(!e.isUniform||!r.isUniform){var c=e.texShape,s=r.isUniform?null:r.texData.texShape;if(!i.util.arraysEqual(c,s))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(c," and ").concat(s," must match"))}}))}function Me(e,n,t,a,r){Pe(n.inShapeInfos,t),Pe([n.outShapeInfo],[a]);var o=a.texData.texture,c=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(o,c[0],c[1]):e.setOutputMatrixTexture(o,c[0],c[1]),e.setProgram(n.webGLProgram),1===Object(i.env)().getNumber("WEBGL_VERSION")&&null!==n.infLoc&&e.gl.uniform1f(n.infLoc,1/0),null!==n.nanLoc&&e.gl.uniform1f(n.nanLoc,NaN),t.forEach((function(t,a){var r=n.program.variableNames[a],o=n.uniformLocations[r],c=n.uniformLocations["offset".concat(r)];if(null!=o)if(t.isUniform)if(i.util.sizeFromShape(t.shape)<2)e.gl.uniform1f(o,t.uniformValues[0]);else{var s=t.uniformValues;s instanceof Float32Array||(s=new Float32Array(s)),e.gl.uniform1fv(o,s)}else null!=t.texData.slice&&null!=c&&e.gl.uniform1i(c,t.texData.slice.flatOffset),e.setInputMatrixTexture(t.texData.texture,o,a)})),null!=r&&r(e,n.webGLProgram),e.executeProgram()}function Le(e,n,t){var a="";n.concat(t).forEach((function(e){var n=null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0,t=e.isUniform?"uniform":e.texData.texShape;a+="".concat(e.shape,"_").concat(t,"_").concat(n)}));var r=e.userCode,o=e.constructor.name;return o+="_"+a+"_"+r}function Be(e){return function(n,t,a,r,o){var c=i.backend_util.assertAndGetBroadcastShape(n,t),s=c.length,u=i.util.computeStrides(c),l=i.util.sizeFromShape(c),d=i.util.getTypedArrayFromDType(o,l),p=n.length,h=t.length,f=i.util.computeStrides(n),v=i.util.computeStrides(t),m=i.backend_util.getBroadcastDims(n,c),g=i.backend_util.getBroadcastDims(t,c);if(m.length+g.length===0)for(var b=0;b<d.length;++b)d[b]=e(a[b%a.length],r[b%r.length]);else for(var x=function(n){var t=i.util.indexToLoc(n,s,u),o=t.slice(-p);m.forEach((function(e){return o[e]=0}));var c=i.util.locToIndex(o,p,f),l=t.slice(-h);g.forEach((function(e){return l[e]=0}));var b=i.util.locToIndex(l,h,v);d[n]=e(a[c],r[b])},k=0;k<d.length;++k)x(k);return[d,c]}}function We(e,n){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&i.util.assert("complex64"!==e.dtype,(function(){return"".concat(n," does not support complex64 tensors in the CPU backend.")}))}))}function je(e){var n=e.inputs,t=e.backend,a=n.real,r=n.imag,o=t.data.get(a.dataId).values,i=t.data.get(r.dataId).values,c=t.makeTensorInfo(a.shape,"complex64");return t.data.get(c.dataId).complexTensorInfos={real:t.makeTensorInfo(a.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",i)},c}i.Complex;function Ve(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===t){var a=Ve(e,n,"float32"),r=Ve(e,n,"float32");return je({inputs:{real:a,imag:r},backend:e})}var o=i.util.makeZerosTypedArray(i.util.sizeFromShape(n),t);return e.makeTensorInfo(n,t,o)}function ze(e){var n=e.inputs,t=e.backend,a=n.x;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}i.Identity;function Ge(e){var n=e.inputs,t=e.backend,a=n.input,r=t.data.get(a.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}i.Real;function Ue(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.dtype;if("complex64"===o){if("complex64"===r.dtype)return ze({inputs:{x:r},backend:t});var s=Ve(t,r.shape,r.dtype),u=Ue({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=je({inputs:{real:u,imag:s},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(u),l}if("complex64"===r.dtype){var d=Ge({inputs:{input:r},backend:t}),p=Ue({inputs:{x:d},backend:t,attrs:{dtype:o}});return t.disposeIntermediateTensorInfo(d),p}if(!i.util.hasEncodingLoss(r.dtype,o)){var h=ze({inputs:{x:r},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:o}}if("int32"===o){var f=t.data.get(r.dataId).values,v=Int32Array.from(f);return t.makeTensorInfo(r.shape,"int32",v)}if("bool"===o){var m=t.data.get(r.dataId).values,g=i.util.toTypedArray([0],r.dtype),b=Be((function(e,n){return e!==n?1:0}))(r.shape,[],m,g,"bool"),x=Object(c.a)(b,2),k=x[0],I=x[1];return t.makeTensorInfo(I,"bool",k)}throw new Error("Error in Cast: failed to cast ".concat(r.dtype," to ").concat(o))}i.Cast;function He(e,n,t,a){return null==t?function(t){var r=t.inputs,o=t.backend,i=r.a,s=r.b,u=o;We([i,s],e);var l=u.data.get(i.dataId).values,d=u.data.get(s.dataId).values,p=a||i.dtype,h=n(i.shape,s.shape,l,d,p),f=Object(c.a)(h,2),v=f[0],m=f[1];return u.makeTensorInfo(m,p,v)}:function(e){var r=e.inputs,o=e.backend,i=r.a,s=r.b,u=o;if("complex64"===i.dtype||"complex64"===s.dtype){var l=Ue({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(l.dataId),p=d.complexTensorInfos.real,h=d.complexTensorInfos.imag,f=u.data.get(p.dataId).values,v=u.data.get(h.dataId).values,m=Ue({inputs:{x:s},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(m.dataId),b=g.complexTensorInfos.real,x=g.complexTensorInfos.imag,k=u.data.get(b.dataId).values,I=u.data.get(x.dataId).values,y=t(i.shape,s.shape,f,v,k,I),C=Object(c.a)(y,3),N=C[0],T=C[1],R=C[2],w=u.makeTensorInfo(R,"float32",N),S=u.makeTensorInfo(R,"float32",T),O=je({inputs:{real:w,imag:S},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(w),u.disposeIntermediateTensorInfo(S),O}var F=u.data.get(i.dataId).values,A=u.data.get(s.dataId).values,E=a||i.dtype,_=n(i.shape,s.shape,F,A,E),D=Object(c.a)(_,2),P=D[0],M=D[1];return u.makeTensorInfo(M,E,P)}}function Xe(e){return function(n,t,a,r,o,c){var s=i.backend_util.assertAndGetBroadcastShape(n,t),u=i.util.sizeFromShape(s),l=s.length,d=i.util.computeStrides(s),p=i.util.getTypedArrayFromDType("float32",u),h=i.util.getTypedArrayFromDType("float32",u),f=i.backend_util.getBroadcastDims(n,s),v=i.backend_util.getBroadcastDims(t,s),m=i.backend_util.mergeRealAndImagArrays(a,r),g=i.backend_util.mergeRealAndImagArrays(o,c),b=n.length,x=i.util.computeStrides(n),k=t.length,I=i.util.computeStrides(t);if(f.length+v.length===0)for(var y=0;y<p.length;y++){var C=y%m.length,N=y%g.length,T=e(m[2*C],m[2*C+1],g[2*N],g[2*N+1]);p[y]=T.real,h[y]=T.imag}else for(var R=function(n){var t=i.util.indexToLoc(n,l,d),a=t.slice(-b);f.forEach((function(e){return a[e]=0}));var r=i.util.locToIndex(a,b,x),o=t.slice(-k);v.forEach((function(e){return o[e]=0}));var c=i.util.locToIndex(o,k,I),s=e(m[2*r],m[2*r+1],g[2*c],g[2*c+1]);p[n]=s.real,h[n]=s.imag},w=0;w<p.length;w++)R(w);return[p,h,s]}}var qe=Be((function(e,n){return e+n})),Ke=Xe((function(e,n,t,a){return{real:e+t,imag:n+a}}));He(i.Add,qe,Ke),i.Add;function Ye(e){return function(n,t,a){for(var r=i.util.getTypedArrayFromDType(t,n.length),o=0;o<n.length;++o)r[o]=e(n[o],a);return r}}function Qe(e,n,t){return function(a){var r=a.inputs,o=a.attrs,i=a.backend,c=r.x;if(We(c,e),"string"===c.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");var s=i,u=s.data.get(c.dataId).values,l=t||c.dtype,d=n(u,l,o);return s.makeTensorInfo(c.shape,l,d)}}var Ze=Ye((function(e){return Math.ceil(e)}));Qe(i.Ceil,Ze),i.Ceil;var Je=Ye((function(e){return Math.exp(e)})),$e=(Qe(i.Exp,Je),i.Exp,Ye((function(e){return Math.expm1(e)}))),en=(Qe(i.Expm1,$e),i.Expm1,Ye((function(e){return Math.floor(e)})));Qe(i.Floor,en),i.Floor;var nn=Be((function(e,n){return e>n?1:0})),tn=(He(i.Greater,nn,null,"bool"),i.Greater,Be((function(e,n){return e<n?1:0})));He(i.Less,tn,null,"bool"),i.Less;var an=Ye((function(e){return Math.log(e)}));Qe(i.Log,an),i.Log;var rn=Be((function(e,n){return Math.max(e,n)})),on=(He(i.Maximum,rn),i.Maximum,Be((function(e,n){return Math.min(e,n)}))),cn=(He(i.Minimum,on),i.Minimum,Be((function(e,n){return e*n}))),sn=Xe((function(e,n,t,a){return{real:e*t-n*a,imag:e*a+n*t}}));He(i.Multiply,cn,sn),i.Multiply;function un(e,n,t){var a=i.util.createScalarValue(-1,t);return cn([],n,a,e,t)}i.Neg;function ln(e,n,t,a,r){for(var o=n.length,c=i.util.sizeFromShape(n),s=i.util.computeStrides(n),u=i.util.computeStrides(r),l=i.util.getTypedArrayFromDType(t,i.util.sizeFromShape(r)),d=0;d<c;++d){for(var p=i.util.indexToLoc(d,o,s),h=new Array(p.length),f=0;f<h.length;f++)h[f]=p[a[f]];l[i.util.locToIndex(h,o,u)]=e[d]}return l}i.Transpose;function dn(e,n,t,a){for(var r=i.backend_util.computeOutAndReduceShapes(e,a),o=Object(c.a)(r,2),s=o[0],u=o[1],l=Object(i.upcastType)(n,"int32"),d=i.util.makeZerosTypedArray(i.util.sizeFromShape(s),l),p=i.util.sizeFromShape(u),h=0;h<d.length;++h){for(var f=h*p,v=1,m=0;m<p;++m)v*=t[f+m];d[h]=v}return{outVals:d,outShape:s,outDtype:l}}i.Prod;var pn=Ye((function(e){return 1/Math.sqrt(e)}));Qe(i.Rsqrt,pn),i.Rsqrt;function hn(e){for(var n=new Float32Array(e.length),t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n}i.Abs;function fn(e,n,t,a,r){var o=i.slice_util.isSliceContinous(a,n,t),c=i.util.sizeFromShape(t),s=i.util.computeStrides(a);if(o){var u=i.slice_util.computeFlatOffset(n,s);return"string"===r?e.slice(u,u+c):e.subarray(u,u+c)}for(var d="string"===r?i.backend_util.fromUint8ToStringArray(e):e,p=Object(i.buffer)(a,r,d),h=Object(i.buffer)(t,r),f=0;f<h.size;++f){var v=h.indexToLoc(f),m=v.map((function(e,t){return e+n[t]}));h.set.apply(h,[p.get.apply(p,Object(l.a)(m))].concat(Object(l.a)(v)))}return"string"===r?i.backend_util.fromStringArrayToUint8(h.values):h.values}i.Slice;var vn=Be((function(e,n){return e-n})),mn=Xe((function(e,n,t,a){return{real:e-t,imag:n-a}}));He(i.Sub,vn,mn),i.Sub;var gn=qe,bn=function(e,n,t,a,r){for(var o=i.util.sizeFromShape(a),c=i.util.makeZerosTypedArray(r,t),s=0;s<e.length;s++){var u=e[s];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(c[u]+=o>0?n[s]:1)}return c},xn=function(e,n,t){for(var a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=e.shape[0],o=e.shape[1],c=Object(i.buffer)([r,t],n.dtype),s=0;s<r;s++)for(var u=0;u<o;u++){var l=e.get(s,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(a?c.set(1,s,l):n.size>0?c.set(c.get(s,l)+n.get(s,u),s,l):c.set(c.get(s,l)+1,s,l))}return c},kn=Ze,In=function(e,n,t,a){var r=i.util.getArrayFromDType(t,i.util.sizeFromShape(n));if(a&&"string"!==t){var o=0;e.forEach((function(e){var n=i.util.sizeFromShape(e.shape);r.set(e.vals,o),o+=n}))}else{var c=0;e.forEach((function(e){for(var a="string"===t?i.backend_util.fromUint8ToStringArray(e.vals):e.vals,o=0,s=0;s<e.shape[0];++s)for(var u=s*n[1]+c,l=0;l<e.shape[1];++l)r[u+l]=a[o++];c+=e.shape[1]}))}return r},yn=Je,Cn=$e,Nn=en,Tn=function(e,n,t){for(var a=Object(i.buffer)(t,e.dtype),r=0;r<a.size;++r){var o=a.indexToLoc(r).slice(),c=o[0],s=o[2],u=n.locToIndex([c,s]);o[2]=n.values[u];var l=e.locToIndex(o);a.values[r]=e.values[l]}return a},Rn=nn,wn=tn,Sn=function(e,n,t){var a=(n-e)/(t-1),r=i.util.makeZerosTypedArray(t,"float32");r[0]=e;for(var o=1;o<r.length;o++)r[o]=r[o-1]+a;return r},On=an,Fn=function(e,n,t,a){for(var r=i.util.getTypedArrayFromDType(a,i.util.sizeFromShape(t)),o=0;o<r.length;++o){for(var c=o*n,s=e[c],u=0;u<n;++u){var l=e[c+u];l>s&&(s=l)}r[o]=s}return r},An=rn,En=on,_n=cn,Dn=un,Pn=dn,Mn=function(e,n,t,a){if(e===n||e<n&&t<0||n<e&&t>1)return i.util.makeZerosTypedArray(0,a);var r=Math.abs(Math.ceil((n-e)/t)),o=i.util.makeZerosTypedArray(r,a);n<e&&1===t&&(t=-1),o[0]=e;for(var c=1;c<o.length;c++)o[c]=o[c-1]+t;return o},Ln=pn,Bn=hn,Wn=fn,jn=function(e,n,t,a){for(var r=Object(i.buffer)(e,n.dtype),o=0;o<r.size;o++){for(var c=r.indexToLoc(o),s=new Array(c.length),u=0;u<s.length;u++)s[u]=c[u]*t[u]+a[u];r.set.apply(r,[n.get.apply(n,s)].concat(Object(l.a)(c)))}return r},Vn=vn,zn=function(e,n){for(var t=new Array(e.rank),a=0;a<t.length;a++)t[a]=e.shape[a]*n[a];for(var r=Object(i.buffer)(t,e.dtype),o=0;o<r.values.length;++o){for(var c=r.indexToLoc(o),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=c[u]%e.shape[u];var l=e.locToIndex(s);r.values[o]=e.values[l]}return r},Gn=function(e,n,t,a,r){for(var o=n[n.length-1],c=e.length/o,s=o,u=i.util.getTypedArrayFromDType(t,c*a),l=i.util.getTypedArrayFromDType("int32",c*a),d=0;d<c;d++){for(var p=d*s,h=e.subarray(p,p+s),f=[],v=0;v<h.length;v++)f.push({value:h[v],index:v});f.sort((function(e,n){return n.value-e.value}));for(var m=d*a,g=u.subarray(m,m+a),b=l.subarray(m,m+a),x=0;x<a;x++)g[x]=f[x].value,b[x]=f[x].index}var k=n.slice();return k[k.length-1]=a,[Object(i.buffer)(k,t,u),Object(i.buffer)(k,"int32",l)]},Un=ln,Hn=function(e,n,t,a){for(var r=i.util.parseAxisParam(n,t)[0],o=[1,t[0],1],c=0;c<r;c++)o[0]*=t[c];o[1]=t[r];for(var s=r+1;s<t.length;s++)o[2]*=t[s];for(var u={},l=new Int32Array(t[r]),d=new i.TensorBuffer(o,a,e),p=[],h=1===o[0]&&1===o[2],f=0;f<t[r];f++){var v=void 0;if(h)v=e[f].toString();else{for(var m=[],g=0;g<o[0];g++)for(var b=0;b<o[2];b++)m.push(d.get(g,f,b));v=m.join(",")}if(void 0!==u[v])l[f]=u[v];else{var x=Object.keys(u).length;u[v]=x,l[f]=x,p.push(f)}}var k=o.slice();k[1]=Object.keys(u).length;var I=new i.TensorBuffer(k,a);p.forEach((function(e,n){for(var t=0;t<o[0];t++)for(var a=0;a<o[2];a++)I.set(d.get(t,e,a),t,n,a)}));var y=t.slice();return y[r]=k[1],{outputValues:I.values,outputShape:y,indices:l}};function Xn(e,n){return["x","y","z","w","u","v"].slice(0,n).map((function(n){return"".concat(e,".").concat(n)}))}function qn(e,n){return 1===n?[e]:Xn(e,n)}var Kn=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n;var t=n.length;if(0===t)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{var a=qn("rc",t),r=Ae(t),o=function(e,n,t){if(1===e)return"rc > ".concat(n[0]);for(var a="",r=e-2;r<e;r++)a+="".concat(t[r]," >= ").concat(n[r]),r<e-1&&(a+="||");return a}(t,n,a),i=function(e,n,t,a){if(1===e)return"";var r=a.slice(-2);return"\n    int r = ".concat(r[0],";\n    int c = ").concat(r[1],";\n    int rp1 = r + 1;\n    int cp1 = c + 1;\n\n    bool cEdge = cp1 >= ").concat(n,";\n    bool rEdge = rp1 >= ").concat(t,";\n  ")}(t,n[n.length-1],n[n.length-2],a),c=function(e,n){var t=e.length,a=function(e,n){for(var t=[],a=0;a<=1;a++)for(var r=0;r<=1;r++){for(var o="".concat(0===a?"r":"rp1",", ").concat(0===r?"c":"cp1"),i=2;i<e;i++)o="".concat(n[n.length-1-i],",")+o;t.push(o)}return t}(t,n);if(1===t)return"getA(rc),\n            rc + 1 >= ".concat(e[0]," ? 0. : getA(rc + 1),\n            0, 0");return"getA(".concat(a[0],"),\n          cEdge ? 0. : getA(").concat(a[1],"),\n          rEdge ? 0. : getA(").concat(a[2],"),\n          rEdge || cEdge ? 0. : getA(").concat(a[3],")")}(n,a);this.userCode="\n        void main() {\n          ".concat(r," rc = getOutputCoords();\n\n          if(").concat(o,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(i,"\n\n            setOutput(vec4(").concat(c,"));\n          }\n        }\n      ")}};var Yn=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;for(var a="",r=0;r<4;r++){var o="thisRC = rc;";r%2===1&&(o+="thisRC.z += 1;"),r>1&&(o+="thisRC.y += 1;"),a+="\n        ".concat(o,"\n        ").concat(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(r,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(r>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e){var n=$(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t),"\n      ").concat(ee(n),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(n[1],";\n        int cols = ").concat(n[2],";\n\n        ").concat(a,"\n\n        setOutput(result);\n      }\n    ")};var Qn=function(){function e(n){Object(p.a)(this,e),this.gpgpu=n,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return Object(h.a)(e,[{key:"acquireTexture",value:function(e,n,t){var a=Jn(n,t),r=$n(e,a,t);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);var i,c=Zn(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,t);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=c,this.log();var s=this.freeTextures[r].shift();return this.usedTextures[r].push(s),s}return a===o.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===o.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===o.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===o.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===o.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(i),this.numUsedTextures++,this._numBytesAllocated+=c,this.log(),i}},{key:"releaseTexture",value:function(e,n,t,a){if(null!=this.freeTextures){var r=Jn(t,a),o=$n(n,r,a);o in this.freeTextures||(this.freeTextures[o]=[]);var c=Zn(n,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),s=Object(i.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==s&&this._numBytesAllocated>s?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=c):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=c),this.numUsedTextures--;var u=this.usedTextures[o],l=u.indexOf(e);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u.splice(l,1),this.log()}}},{key:"log",value:function(){if(this.logEnabled){var e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));var n=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*n),"%)"))}}},{key:"getNumUsedTextures",value:function(){return this.numUsedTextures}},{key:"getNumFreeTextures",value:function(){return this.numFreeTextures}},{key:"dispose",value:function(){var e=this;if(null!=this.freeTextures){for(var n in this.freeTextures)this.freeTextures[n].forEach((function(n){e.gpgpu.deleteMatrixTexture(n)}));for(var t in this.usedTextures)this.usedTextures[t].forEach((function(n){e.gpgpu.deleteMatrixTexture(n)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}},{key:"numBytesAllocated",get:function(){return this._numBytesAllocated}},{key:"numBytesFree",get:function(){return this._numBytesFree}}]),e}();function Zn(e,n,t,a,r){var i,s=function(e,n){switch(e){case o.PACKED_2X2_FLOAT32:return ve(n);case o.PACKED_2X2_FLOAT16:return me(n);case o.UNPACKED_FLOAT32:return pe(n);case o.UNPACKED_FLOAT16:return he(n);case o.PACKED_4X1_UNSIGNED_BYTE:return fe(n);default:throw new Error("Unknown physical texture type ".concat(e))}}(n,a);if(r){var u=y(e[0],e[1]),l=Object(c.a)(u,2);i=l[0]*l[1]}else{var d=k(e[0],e[1]),p=Object(c.a)(d,2);i=p[0]*p[1]}return i*function(e,n){var t=e;if(n===t.R32F)return 4;if(n===t.R16F)return 2;if(n===t.RGBA32F)return 16;if(n===e.RGBA)return 16;if(n===t.RGBA16F)return 8;throw new Error("Unknown internal format ".concat(n))}(t,s)}function Jn(e,n){if(e===r.UPLOAD)return o.PACKED_2X2_FLOAT32;if(e===r.RENDER||null==e)return function(e){return Object(i.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?o.PACKED_2X2_FLOAT32:o.UNPACKED_FLOAT32:e?o.PACKED_2X2_FLOAT16:o.UNPACKED_FLOAT16}(n);if(e===r.DOWNLOAD||e===r.PIXELS)return o.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function $n(e,n,t){return"".concat(e[0],"_").concat(e[1],"_").concat(n,"_").concat(t)}var et=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"],this.outputShape=n,this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")},nt="if (isnan(x)) return x;",tt="return x;",at="return abs(x);";var rt="return (x >= 0.0) ? x : (exp(x) - 1.0);",ot=nt+"\n  return (x < 0.0) ? 0.0 : x;\n",it=nt+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",ct="return x;",st="return x;",ut="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",lt="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",dt="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",pt=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")},ht=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n;var t=n.length,a=qn("rc",t),r=Ae(t),o=function(e,n){if(1===e)return"rc";for(var t="",a=0;a<e;a++)t+=n[a],a<e-1&&(t+=",");return t}(t,a),i=a.slice(-2),c=t<=1?"rc":"vec2(".concat(i.join(","),")");this.userCode="\n      void main() {\n        ".concat(r," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(o,");\n\n        setOutput(getChannel(packedInput, ").concat(c,"));\n      }\n    ")},ft=i.kernel_impls.whereImpl,vt={};var mt=function(e){Object(v.a)(t,e);var n=Object(m.a)(t);function t(e){var a,r;if(Object(p.a)(this,t),(a=n.call(this)).pendingRead=new WeakMap,a.pendingDisposal=new WeakSet,a.dataRefCount=new WeakMap,a.numBytesInGPU=0,a.uploadWaitMs=0,a.downloadWaitMs=0,a.warnedAboutMemory=!1,a.warnedAboutCPUBackend=!1,a.pendingDeletes=0,a.disposed=!1,!Object(i.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(null==e){var o=x(Object(i.env)().getNumber("WEBGL_VERSION"));a.binaryCache=((r=Object(i.env)().getNumber("WEBGL_VERSION"))in vt||(vt[r]={}),vt[r]),a.gpgpu=new be(o),a.canvas=o.canvas,a.gpgpuCreatedLocally=!0}else a.gpgpu=e,a.binaryCache={},a.gpgpuCreatedLocally=!1,a.canvas=e.gl.canvas;return a.textureManager=new Qn(a.gpgpu),a.numMBBeforeWarning=null==Object(i.env)().global.screen?1024:Object(i.env)().global.screen.height*Object(i.env)().global.screen.width*window.devicePixelRatio*600/1024/1024,a.texData=new i.DataStorage(Object(f.a)(a),Object(i.engine)()),a}return Object(h.a)(t,[{key:"numDataIds",value:function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}},{key:"write",value:function(e,n,t){if((Object(i.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Object(i.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===t&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var a={};return this.texData.set(a,{shape:n,dtype:t,values:e,usage:r.UPLOAD,refCount:1,complexParentRefCount:0}),a}},{key:"incRef",value:function(e){this.texData.get(e).refCount++}},{key:"decRef",value:function(e){this.texData.has(e)&&this.texData.get(e).refCount--}},{key:"decComplexRef",value:function(e){if(this.texData.has(e)){var n=this.texData.get(e);n.complexParentRefCount>0&&n.refCount--}}},{key:"move",value:function(e,n,t,a){if(Object(i.env)().getBool("DEBUG")&&this.checkNumericalProblems(n),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:t,dtype:a,values:n,usage:r.UPLOAD,refCount:1,complexParentRefCount:0})}},{key:"disposeIntermediateTensorInfo",value:function(e){var n=e.dataId;if(this.texData.has(n)){var t=this.texData.get(n);t.refCount--,t.refCount<1&&this.disposeData(n)}}},{key:"readSync",value:function(e){var n=this.texData.get(e),t=n.values,a=n.dtype,r=n.complexTensorInfos,o=n.slice,c=n.shape,s=n.isPacked;if(null!=o){var u;u=s?new pt(c,ct):new et(c,ct);var l=this.runWebGLProgram(u,[{dataId:e,shape:c,dtype:a}],a),d=this.readSync(l.dataId);return this.disposeIntermediateTensorInfo(l),d}if(null!=t)return this.convertAndCacheOnCPU(e);if("string"===a)return t;var p,h,f=null!=this.activeTimers;if(f&&(p=i.util.now()),"complex64"===a){var v=this.readSync(r.real.dataId),m=this.readSync(r.imag.dataId);h=i.backend_util.mergeRealAndImagArrays(v,m)}else h=this.getValuesFromTexture(e);return f&&(this.downloadWaitMs+=i.util.now()-p),this.convertAndCacheOnCPU(e,h)}},{key:"read",value:function(){var e=Object(d.a)(u.a.mark((function e(n){var t,a,r,o,c,s,d,p,h,f,v,m,g,b,x,k,y,C,N,T,R,w;return u.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!this.pendingRead.has(n)){e.next=3;break}return t=this.pendingRead.get(n),e.abrupt("return",new Promise((function(e){return t.push(e)})));case 3:if(a=this.texData.get(n),r=a.values,o=a.shape,c=a.slice,s=a.dtype,d=a.complexTensorInfos,p=a.isPacked,null==c){e.next=11;break}return h=p?new pt(o,ct):new et(o,ct),f=this.runWebGLProgram(h,[{dataId:n,shape:o,dtype:s}],s),v=this.read(f.dataId),this.disposeIntermediateTensorInfo(f),e.abrupt("return",v);case 11:if(null==r){e.next=13;break}return e.abrupt("return",this.convertAndCacheOnCPU(n));case 13:if(Object(i.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")||2!==Object(i.env)().getNumber("WEBGL_VERSION")){e.next=15;break}throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");case 15:if(m=null,"complex64"!==s&&Object(i.env)().get("WEBGL_BUFFER_SUPPORTED")&&(g=this.decode(n),x=this.texData.get(g.dataId),m=(b=this.gpgpu).createBufferFromTexture.apply(b,[x.texture].concat(Object(l.a)(I(o))))),this.pendingRead.set(n,[]),"complex64"===s){e.next=21;break}return e.next=21,this.gpgpu.createAndWaitForFence();case 21:if("complex64"!==s){e.next=30;break}return e.next=24,Promise.all([this.read(d.real.dataId),this.read(d.imag.dataId)]);case 24:y=e.sent,C=y[0],N=y[1],k=i.backend_util.mergeRealAndImagArrays(C,N),e.next=31;break;case 30:null==m?k=this.getValuesFromTexture(n):(T=i.util.sizeFromShape(o),k=this.gpgpu.downloadFloat32MatrixFromBuffer(m,T));case 31:return null!=g&&this.disposeIntermediateTensorInfo(g),R=this.convertAndCacheOnCPU(n,k),w=this.pendingRead.get(n),this.pendingRead.delete(n),w.forEach((function(e){return e(R)})),this.pendingDisposal.has(n)&&(this.pendingDisposal.delete(n),this.disposeData(n),this.pendingDeletes--),e.abrupt("return",R);case 38:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}()},{key:"bufferSync",value:function(e){var n=this.readSync(e.dataId),t=n;if("string"===e.dtype)try{t=n.map((function(e){return i.util.decodeString(e)}))}catch(a){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(i.buffer)(e.shape,e.dtype,t)}},{key:"checkNumericalProblems",value:function(e){if(null!=e)for(var n=0;n<e.length;n++){var t=e[n];if(!T(t)){if(Object(i.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(t," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(t," cannot be represented on this device."))}}}},{key:"getValuesFromTexture",value:function(e){var n=this.texData.get(e),t=n.shape,a=n.dtype,r=n.isPacked,o=i.util.sizeFromShape(t);if(Object(i.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var c,s=this.decode(e),u=this.texData.get(s.dataId),d=(c=this.gpgpu).downloadMatrixFromPackedTexture.apply(c,[u.texture].concat(Object(l.a)(I(t)))).subarray(0,o);return this.disposeIntermediateTensorInfo(s),d}var p=Object(i.env)().getBool("WEBGL_PACK")&&!0===r,h=p?G(t):t,f=p?new oe(h):new re(h),v=this.runWebGLProgram(f,[{shape:h,dtype:a,dataId:e}],"float32"),m=this.texData.get(v.dataId),g=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture,m.texShape[0],m.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(v),g}},{key:"time",value:function(){var e=Object(d.a)(u.a.mark((function e(n){var t,a,r,o,c,s,l;return u.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(t=this.activeTimers,a=[],r=!1,null==this.programTimersStack?(this.programTimersStack=a,r=!0):this.activeTimers.push(a),this.activeTimers=a,n(),o=i.util.flatten(this.activeTimers.map((function(e){return e.query}))).filter((function(e){return null!=e})),c=i.util.flatten(this.activeTimers.map((function(e){return e.name}))).filter((function(e){return null!=e})),this.activeTimers=t,r&&(this.programTimersStack=null),s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},!(Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)){e.next=19;break}return e.next=14,Promise.all(o);case 14:l=e.sent,s.kernelMs=i.util.sum(l),s.getExtraProfileInfo=function(){return l.map((function(e,n){return{name:c[n],ms:e}})).map((function(e){return"".concat(e.name,": ").concat(e.ms)})).join(", ")},e.next=20;break;case 19:s.kernelMs={error:"WebGL query timers are not supported in this environment."};case 20:return this.uploadWaitMs=0,this.downloadWaitMs=0,e.abrupt("return",s);case 23:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}()},{key:"memory",value:function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}},{key:"startTimer",value:function(){return Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:i.util.now(),endMs:null}}},{key:"endTimer",value:function(e){return Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=i.util.now(),e)}},{key:"getQueryTime",value:function(){var e=Object(d.a)(u.a.mark((function e(n){var t;return u.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(!(Object(i.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)){e.next=2;break}return e.abrupt("return",this.gpgpu.waitForQueryAndGetTime(n));case 2:return t=n,e.abrupt("return",t.endMs-t.startMs);case 4:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}()},{key:"disposeData",value:function(e){if(!this.pendingDisposal.has(e)){if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(this.texData.has(e))if(this.texData.get(e).complexParentRefCount>0)this.texData.get(e).refCount--;else{this.releaseGPUData(e);var n=this.texData.get(e).complexTensorInfos;null!=n&&(this.texData.get(n.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(n.real),this.texData.get(n.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(n.imag)),this.texData.delete(e)}}}},{key:"releaseGPUData",value:function(e){var n=this.texData.get(e),t=n.texture,a=n.dtype,r=n.texShape,o=n.usage,i=n.isPacked,c=n.slice,s=c&&c.origDataId||e,u=this.dataRefCount.get(s);u>1?this.dataRefCount.set(s,u-1):(this.dataRefCount.delete(s),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,a),this.textureManager.releaseTexture(t,r,o,i)));var l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}},{key:"getTexture",value:function(e){return this.uploadToGPU(e),this.texData.get(e).texture}},{key:"getDataInfo",value:function(e){return this.texData.get(e)}},{key:"getCPUBackend",value:function(){return Object(i.env)().getBool("WEBGL_CPU_FORWARD")?(null==this.cpuBackend&&(this.cpuBackend=Object(i.engine)().findBackend("cpu")),this.cpuBackend):null}},{key:"shouldExecuteOnCPU",value:function(e){var n=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:128,a=this.getCPUBackend();return Object(i.env)().getBool("IS_TEST")||this.warnedAboutCPUBackend||null!=a||(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),null!=a&&e.every((function(e){return null==n.texData.get(e.dataId).texture&&i.util.sizeFromShape(e.shape)<t}))}},{key:"getGPGPUContext",value:function(){return this.gpgpu}},{key:"where",value:function(e){i.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var n=e.dataSync();return ft(e.shape,n)}},{key:"packedUnaryOp",value:function(e,n,t){var a=new pt(e.shape,n);return this.compileAndRun(a,[e],t)}},{key:"abs",value:function(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){var n=Bn(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,n)}if(Object(i.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,at,e.dtype);var t=new et(e.shape,at);return this.compileAndRun(t,[e])}},{key:"makeTensorInfo",value:function(e,n,t){var a;if("string"===n&&null!=t&&t.length>0&&i.util.isString(t[0])){var r=t.map((function(e){return i.util.encodeString(e)}));a=this.write(r,e,n)}else a=this.write(t,e,n);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:n}}},{key:"makeOutput",value:function(e,n,t){var a=this.makeTensorInfo(e,n,t).dataId;return Object(i.engine)().makeTensorFromDataId(a,e,n,this)}},{key:"unpackTensor",value:function(e){var n=new ht(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}},{key:"packTensor",value:function(e){var n=new Kn(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}},{key:"packedReshape",value:function(e,n){var t=[V(e.shape)].concat(Object(l.a)(z(e.shape))),a={dtype:e.dtype,shape:t,dataId:e.dataId},r=[V(n)].concat(Object(l.a)(z(n))),o=new Yn(r,t),i=this.runWebGLProgram(o,[a],e.dtype,null,!0);return{dataId:i.dataId,shape:n,dtype:i.dtype}}},{key:"decode",value:function(e){var n,t=this.texData.get(e),a=t.isPacked,r=t.shape,o=t.dtype,i=G(r);n=a?new ae(i):new te(i);return{dtype:o,shape:r,dataId:this.runWebGLProgram(n,[{shape:i,dtype:o,dataId:e}],o,null,!0).dataId}}},{key:"runWebGLProgram",value:function(e,n,t,r){var o=this,c=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=this.makeTensorInfo(e.outputShape,t),u=this.texData.get(s.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===a.DENSE){var l=I(e.outputShape);u.texShape=l.map((function(e){return 2*e}))}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===i.util.sizeFromShape(s.shape))return u.values=i.util.getTypedArrayFromDType(s.dtype,0),s;var d=[],p=n.map((function(n){if("complex64"===n.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var t=o.texData.get(n.dataId);if(null==t.texture){if(!e.packedInputs&&i.util.sizeFromShape(n.shape)<=Object(i.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:n.shape,texData:null,isUniform:!0,uniformValues:t.values};e.packedInputs&&(t.isPacked=!0,t.shape=n.shape)}else if(!!t.isPacked!==!!e.packedInputs)n=t.isPacked?o.unpackTensor(n):o.packTensor(n),d.push(n),t=o.texData.get(n.dataId);else if(t.isPacked&&!H(t.shape,n.shape)){var a=n,r=n.shape;n.shape=t.shape,n=o.packedReshape(n,r),d.push(n),t=o.texData.get(n.dataId),a.shape=r}return o.uploadToGPU(n.dataId),{shape:n.shape,texData:t,isUniform:!1}}));this.uploadToGPU(s.dataId);var h,f={shape:s.shape,texData:u,isUniform:!1},v=Le(e,p,f),m=this.getAndSaveBinary(v,(function(){return De(o.gpgpu,e,p,f)})),g=null!=this.activeTimers;if(g&&(h=this.startTimer()),Me(this.gpgpu,m,p,f,r),d.forEach((function(e){return o.disposeIntermediateTensorInfo(e)})),g&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)})),!Object(i.env)().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===c){var b=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),b}return s}},{key:"compileAndRun",value:function(e,n,t,a){var r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];t=t||n[0].dtype;var o=this.runWebGLProgram(e,n,t,a,r);return Object(i.engine)().makeTensorFromDataId(o.dataId,o.shape,o.dtype)}},{key:"getAndSaveBinary",value:function(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}},{key:"getTextureManager",value:function(){return this.textureManager}},{key:"dispose",value:function(){var e=this;if(!this.disposed){if(!Object(i.env)().getBool("IS_TEST"))Object.keys(this.binaryCache).forEach((function(n){e.gpgpu.deleteProgram(e.binaryCache[n].webGLProgram),delete e.binaryCache[n]}));this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}},{key:"floatPrecision",value:function(){var e=this;return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Object(i.tidy)((function(){if(!Object(i.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){var n=Object(i.env)().getBool("DEBUG");Object(i.env)().set("DEBUG",!1);var t=e.abs(Object(i.scalar)(1e-8)).dataSync()[0];if(Object(i.env)().set("DEBUG",n),t>0)return 32}return 16}))),this.floatPrecisionValue}},{key:"epsilon",value:function(){return 32===this.floatPrecision()?1e-7:1e-4}},{key:"uploadToGPU",value:function(e){var n=this.texData.get(e),t=n.shape,a=n.dtype,o=n.values,s=n.texture,u=n.usage,l=n.isPacked;if(null==s){var d,p=null!=this.activeTimers;p&&(d=i.util.now());var h=n.texShape;if(null==h&&(h=function(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=Object(i.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n&&(t*=2,1===(e=e.map((function(n,t){return t>=e.length-2?i.util.nearestLargerEven(e[t]):e[t]}))).length&&(e=[2,e[0]])),2!==e.length){var a=i.util.squeezeShape(e);e=a.newShape}var r=i.util.sizeFromShape(e);if(e.length<=1&&r<=t)return[1,r];if(2===e.length&&e[0]<=t&&e[1]<=t)return e;if(3===e.length&&e[0]*e[1]<=t&&e[2]<=t)return[e[0]*e[1],e[2]];if(3===e.length&&e[0]<=t&&e[1]*e[2]<=t)return[e[0],e[1]*e[2]];if(4===e.length&&e[0]*e[1]*e[2]<=t&&e[3]<=t)return[e[0]*e[1]*e[2],e[3]];if(4===e.length&&e[0]<=t&&e[1]*e[2]*e[3]<=t)return[e[0],e[1]*e[2]*e[3]];if(n){var o=V(e),s=2,u=2;if(e.length){var l=z(e),d=Object(c.a)(l,2);s=d[0],u=d[1]}return r=o*(s/2)*(u/2),i.util.sizeToSquarishShape(r).map((function(e){return 2*e}))}return i.util.sizeToSquarishShape(r)}(t,l),n.texShape=h),null!=o){var f,v=G(t),m=h[1],g=h[0],b=o instanceof Uint8Array;if(l){var x=y(h[0],h[1]),k=Object(c.a)(x,2);m=k[0],g=k[1],f=new ce(v,[g,m],b)}else f=new ie(v,[g,m],b);var I=this.makeTensorInfo([g,m],a);this.texData.get(I.dataId).usage=b?r.PIXELS:r.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(I.dataId),m,g,o);var C=this.runWebGLProgram(f,[I],a,null,!0),N=this.texData.get(C.dataId);n.texture=N.texture,n.texShape=N.texShape,n.isPacked=N.isPacked,n.usage=N.usage,this.disposeIntermediateTensorInfo(I),this.texData.delete(C.dataId),n.values=null,p&&(this.uploadWaitMs+=i.util.now()-d)}else{var T=this.acquireTexture(h,u,a,l);n.texture=T}}}},{key:"convertAndCacheOnCPU",value:function(e,n){var t=this.texData.get(e),a=t.dtype;return this.releaseGPUData(e),null!=n&&(t.values=function(e,n){if("float32"===n||"complex64"===n)return e;if("int32"===n||"bool"===n){for(var t="int32"===n?new Int32Array(e.length):new Uint8Array(e.length),a=0;a<t.length;++a)t[a]=Math.round(e[a]);return t}throw new Error("Unknown dtype ".concat(n))}(n,a)),t.values}},{key:"acquireTexture",value:function(e,n,t,a){if(this.numBytesInGPU+=this.computeBytes(e,t),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(r," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,n,a)}},{key:"computeBytes",value:function(e,n){return e[0]*e[1]*i.util.bytesPerElement(n)}}]),t}(i.KernelBackend);i.device_util.isBrowser()&&Object(i.registerBackend)("webgl",(function(){return new mt}),2);var gt=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["A","B"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,a),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(n,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")},bt=function e(n,t,a){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];Object(p.a)(this,e),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,a);var o=this.outputShape.length,c="";if(r)if(0===o||1===i.util.sizeFromShape(this.outputShape))c="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{var s=Ae(o);if(c="\n          ".concat(s," coords = getOutputCoords();\n        "),1===o)c+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{var u=qn("coords",o);c+="\n            bool nextRowOutOfBounds =\n              (".concat(u[o-2]," + 1) >= ").concat(this.outputShape[o-2],";\n            bool nextColOutOfBounds =\n              (").concat(u[o-1]," + 1) >= ").concat(this.outputShape[o-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(n,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(c,"\n\n        setOutput(result);\n      }\n    ")};function xt(e){var n=e.inputs,t=e.backend,a=n.x;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var kt={kernelName:i.Identity,backendName:"webgl",kernelFunc:xt};function It(e){var n=e.inputs,t=e.backend,a=n.real,r=n.imag,o=t.makeTensorInfo(a.shape,"complex64"),i=t.texData.get(o.dataId),c=xt({inputs:{x:a},backend:t});t.texData.get(c.dataId).complexParentRefCount++;var s=xt({inputs:{x:r},backend:t});return t.texData.get(s.dataId).complexParentRefCount++,i.complexTensorInfos={real:c,imag:s},o}var yt={kernelName:i.Complex,backendName:"webgl",kernelFunc:It},Ct="return (a < 0.) ? b * a : a;",Nt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var Tt={kernelName:i.LeakyRelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.alpha,c=t.makeTensorInfo([],"float32",i.util.createScalarValue(o,"float32")),s=Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bt(Nt,r.shape,c.shape):new gt(Ct,r.shape,c.shape),u=t.runWebGLProgram(s,[r,c],r.dtype);return t.disposeIntermediateTensorInfo(c),u}},Rt="return (a < 0.) ? b * a : a;",wt="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";var St={kernelName:i.Prelu,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=n.alpha,o=Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bt(wt,a.shape,r.shape):new gt(Rt,a.shape,r.shape);return t.runWebGLProgram(o,[a,r],a.dtype)}};function Ot(e){var n=e.opSnippet,t=e.packedOpSnippet,a=e.cpuKernelImpl,r=e.dtype;return function(e){var o,c=e.inputs,s=e.backend,u=c.x,l=s,d=r||u.dtype;if(l.shouldExecuteOnCPU([u])&&null!=a){var p=l.texData.get(u.dataId),h=a(p.values,d);return l.makeTensorInfo(u.shape,d,h)}return o=Object(i.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new pt(u.shape,t):new et(u.shape,n),l.runWebGLProgram(o,[u],d)}}function Ft(e){var n=e.opSnippet,t=e.packedOpSnippet,a=e.checkOutOfBounds,r=void 0!==a&&a,o=e.supportsComplex,s=void 0!==o&&o,u=e.cpuKernelImpl,l=e.dtype;return function(e){var a=e.inputs,o=e.backend,d=a.a,p=a.b,h=o;if(s&&"complex64"===d.dtype){var f=h.texData.get(d.dataId),v=h.texData.get(p.dataId),m=[[f.complexTensorInfos.real,v.complexTensorInfos.real],[f.complexTensorInfos.imag,v.complexTensorInfos.imag]].map((function(e){var t=Object(c.a)(e,2),a=t[0],r=t[1],o={dataId:a.dataId,dtype:a.dtype,shape:d.shape},s={dataId:r.dataId,dtype:r.dtype,shape:p.shape},u=new gt(n,d.shape,p.shape);return h.runWebGLProgram(u,[o,s],Object(i.upcastType)(a.dtype,r.dtype))})),g=Object(c.a)(m,2),b=g[0],x=g[1],k=It({inputs:{real:b,imag:x},backend:h});return h.disposeIntermediateTensorInfo(b),h.disposeIntermediateTensorInfo(x),k}var I,y=l||Object(i.upcastType)(d.dtype,p.dtype);if(h.shouldExecuteOnCPU([d,p])&&null!=u){var C=h.texData.get(d.dataId),N=h.texData.get(p.dataId),T=u(d.shape,p.shape,C.values,N.values,y),R=Object(c.a)(T,2),w=R[0],S=R[1],O=h.makeTensorInfo(S,y);return h.texData.get(O.dataId).values=w,O}return I=Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new bt(t,d.shape,p.shape,r):new gt(n,d.shape,p.shape),h.runWebGLProgram(I,[d,p],y)}}function At(e){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return n?st:tt;if("relu"===e)return n?lt:ot;if("elu"===e)return n?ut:rt;if("relu6"===e)return n?dt:it;if("prelu"===e)return n?wt:Rt;if("leakyrelu"===e)return n?Nt:Ct;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}var Et=function e(n,t,a){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,s=arguments.length>7&&void 0!==arguments[7]&&arguments[7],u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];Object(p.a)(this,e),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;var l=r?n[1]:n[2],d=Math.ceil(l/2),h=r?"i * 2, rc.y":"rc.y, i * 2",f=o?"rc.z, i * 2":"i * 2, rc.z",v=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",b="";c&&(g=s?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(c,"\n        }"):u?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(c,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(c,"\n        }"),b="result = activation(result);");var x=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");var k="rc.x",I="rc.x";n[0]<t[0]?k="int(min(float(rc.x), ".concat(n[0]-1,".))"):t[0]<n[0]&&(I="int(min(float(rc.x), ".concat(t[0]-1,".))")),this.userCode="\n      ".concat(g,"\n\n      const float sharedDimension = ").concat(d,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        for (int i = 0; i < ").concat(d,"; i++) {\n          int batchA = ").concat(k,";\n          int batchB = ").concat(I,";\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(f,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(v[0]," * ").concat(m[0],");\n          result += (").concat(v[1]," * ").concat(m[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(x,"\n\n        ").concat(b,"\n\n        setOutput(result);\n      }\n    ")},_t="return areal * breal - aimag * bimag;",Dt="return areal * bimag + aimag * breal;",Pt=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=i.backend_util.assertAndGetBroadcastShape(t,a),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(n,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")},Mt="return a * b;";function Lt(e){var n,t=e.inputs,a=e.backend,r=t.a,o=t.b,s=i.backend_util.upcastType(r.dtype,o.dtype);if("complex64"===r.dtype){var u=a.texData.get(r.dataId),l=a.texData.get(o.dataId),d=new Pt(_t,r.shape,o.shape),p=new Pt(Dt,r.shape,o.shape),h=[{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:o.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:o.shape}],f=a.runWebGLProgram(d,h,"float32"),v=a.runWebGLProgram(p,h,"float32"),m=It({inputs:{real:f,imag:v},backend:a});return a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(v),m}if(a.shouldExecuteOnCPU([r,o])){var g=a.texData.get(r.dataId),b=a.texData.get(o.dataId),x=_n(r.shape,o.shape,g.values,b.values,s),k=Object(c.a)(x,2),I=k[0],y=k[1],C=a.makeTensorInfo(y,s);return a.texData.get(C.dataId).values=I,C}return n=Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bt(Mt,r.shape,o.shape):new gt(Mt,r.shape,o.shape),a.runWebGLProgram(n,[r,o],s)}var Bt={kernelName:i.Multiply,backendName:"webgl",kernelFunc:Lt};function Wt(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.shape,c=t,s=i.util.sizeFromShape(r.shape),u=i.util.inferFromImplicitShape(o,s),d=i.util.sizeFromShape(u);i.util.assert(s===d,(function(){return"The new shape (".concat(u,") has ").concat(d," elements and the old ")+"shape (".concat(r.shape,") has ").concat(s," elements. The new shape and old ")+"shape must have the same number of elements."}));var p=c.texData.get(r.dataId);return!p.isPacked||H(r.shape,u)||null!==p.texture&&H(p.shape,u)?(c.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype}):function(e,n,t){var a=[V(e.shape)].concat(Object(l.a)(z(e.shape))),r={dtype:e.dtype,shape:a,dataId:e.dataId},o=[V(n)].concat(Object(l.a)(z(n))),i=new Yn(o,a),c=t.runWebGLProgram(i,[r],e.dtype,null,!0);return{dataId:c.dataId,shape:n,dtype:c.dtype}}(r,u,c)}var jt={kernelName:i.Reshape,backendName:"webgl",kernelFunc:Wt},Vt=function e(n,t){Object(p.a)(this,e),this.variableNames=["x"];var a=n.windowSize,r=n.batchSize,o=n.inSize,c=n.outSize;this.outputShape=[r,c];var s=4*Math.floor(a/4),u=a%4,l="sumValue += dot(values, ones);";if(null!=t){var d=1/t;l="sumValue += dot(values * ".concat(i.util.isInt(d)?d.toPrecision(2):d,", ones);")}var h="";o%a>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(o,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(h,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(a,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===u,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(2===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(l,"\n        } else if (").concat(3===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(l,"\n        }\n        setOutput(sumValue);\n      }\n    ")},zt=function e(n,t){Object(p.a)(this,e),this.variableNames=["x"];var a=n.windowSize,r=n.batchSize,o=n.inSize,i=n.outSize;this.outputShape=[r,i];var c="0.0",s="";"prod"===t?c="1.0":"min"===t?(c="1.0 / 1e-20",s="min"):"max"===t&&(c="-1.0 / 1e-20",s="max");var u="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");var l=4*Math.floor(a/4),d=a%4,h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(s,"(values, minMaxValue);\n      }\n    "),f="vec4";"all"===t?(c="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===t&&(c="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");var v="";o%a>0&&(v="\n        if (inIdx < 0 || inIdx >= ".concat(o,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(c,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(v,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(a,";\n\n        vec4 minMaxValue = vec4(").concat(c,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(f," values = ").concat(f,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===d,") {\n          ").concat(f," values = ").concat(f,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===d,") {\n          ").concat(f," values = ").concat(f,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===d,") {\n          ").concat(f," values = ").concat(f,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(u,");\n      }\n    ")};function Gt(e,n,t,a){for(var r=function(e){for(var n=[];0===n.length||1!==n[n.length-1].outSize;){var t=n.length?n[n.length-1].outSize:e[1],a=i.backend_util.computeOptimalWindowSize(t);n.push({inSize:t,windowSize:a,outSize:Math.ceil(t/a)})}return n}(e.shape),o=e,c=0;c<r.length;c++){var s,u=r[c],l=u.inSize,d=u.windowSize,p=u.outSize,h=void 0;h="mean"===t?0===c?new Vt({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:p},l):new Vt({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:p}):new zt({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:p},t),s=o,o=a.runWebGLProgram(h,[o],n),s.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(s)}return o}var Ut=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"];for(var a=new Array(n.length),r=0;r<a.length;r++)a[r]=n[t[r]];this.outputShape=a,this.rank=a.length;var o=Ae(this.rank),i=function(e){var n=e.length;if(n>6)throw Error("Transpose for rank ".concat(n," is not yet supported"));for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(n),r=0;r<e.length;r++)a[e[r]]=t[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(o," resRC = getOutputCoords();\n      setOutput(getA(").concat(i,"));\n    }\n    ")};var Ht=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var a=new Array(n.length),r=0;r<a.length;r++)a[r]=n[t[r]];if(this.outputShape=a,this.rank=a.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));for(var o=Ae(this.rank),i=Xn("rc",this.rank),c=new Array(this.rank),s=0;s<t.length;s++)c[t[s]]=i[s];var u="vec2(".concat(c.slice(-2).join(),")"),l="++".concat(i[this.rank-1]," < ").concat(a[this.rank-1]),d="getChannel(getA(".concat(c.join(),"), ").concat(u,")");this.userCode="\n    void main() {\n      ".concat(o," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(d,";\n      if(").concat(l,") {\n        result[1] = ").concat(d,";\n      }\n      --").concat(i[this.rank-1],";\n      if(++").concat(i[this.rank-2]," < ").concat(a[this.rank-2],") {\n        result[2] = ").concat(d,";\n        if(").concat(l,") {\n          result[3] = ").concat(d,";\n        }\n      }\n      setOutput(result);\n    }\n    ")};function Xt(e,n,t){var a=Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ht(e.shape,n):new Ut(e.shape,n);return t.runWebGLProgram(a,[e],e.dtype)}function qt(e){var n=e.inputs,t=e.backend,a=e.attrs;return function(e,n,t,a){var r=n,o=e.shape.length,s=i.util.parseAxisParam(r,e.shape),u=s,l=i.backend_util.getAxesPermutation(u,o),d=null!=l,p=e;d&&(p=Xt(e,l,a),u=i.backend_util.getInnerMostAxes(u.length,o)),i.backend_util.assertAxesAreInnerMostDims("sum",u,o);var h=i.backend_util.computeOutAndReduceShapes(p.shape,u),f=Object(c.a)(h,2),v=f[0],m=f[1],g=v;t&&(g=i.backend_util.expandShapeToKeepDim(v,s));var b=i.util.sizeFromShape(m),x=Wt({inputs:{x:p},attrs:{shape:[i.util.sizeFromShape(e.shape)/b,b]},backend:a}),k=Gt(x,Object(i.sumOutType)(e.dtype),"sum",a),I=Wt({inputs:{x:k},attrs:{shape:g},backend:a});return a.disposeIntermediateTensorInfo(x),a.disposeIntermediateTensorInfo(k),d&&a.disposeIntermediateTensorInfo(p),I}(n.x,a.axis,a.keepDims,t)}var Kt={kernelName:i.Sum,backendName:"webgl",kernelFunc:qt};function Yt(e){for(var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,i=r.perm,c=a,s=o.shape.length,u=new Array(s),l=0;l<u.length;l++)u[l]=o.shape[i[l]];if(c.shouldExecuteOnCPU([o])){var d=c.texData.get(o.dataId).values,p=Un(d,o.shape,o.dtype,i,u);n=c.makeTensorInfo(u,o.dtype),c.texData.get(n.dataId).values=p}else n=Xt(o,i,c);return n}var Qt={kernelName:i.Transpose,backendName:"webgl",kernelFunc:Yt};function Zt(e){var n=e.a,t=e.b,a=e.transposeA,r=e.transposeB,o=e.backend,c=e.bias,s=void 0===c?null:c,u=e.preluActivationWeights,l=void 0===u?null:u,d=e.leakyreluAlpha,p=void 0===d?0:d,h=e.activation,f=void 0===h?null:h,v=n.shape.length,m=t.shape.length,g=a?n.shape[v-2]:n.shape[v-1],b=r?t.shape[m-1]:t.shape[m-2],x=a?n.shape[v-1]:n.shape[v-2],k=r?t.shape[m-2]:t.shape[m-1],I=n.shape.slice(0,-2),y=t.shape.slice(0,-2),C=i.util.sizeFromShape(I),N=i.util.sizeFromShape(y),T=C===N||1===C||1===N;i.util.assert(v>=2&&m>=2&&T,(function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input "+"batch dimensions of (".concat(I,") and (").concat(y,").")}));var R=(C>N?n.shape.slice(0,-2):t.shape.slice(0,-2)).concat([x,k]);i.util.assert(g===b,(function(){return"Error in matMul: inner shapes (".concat(g,") and (")+"".concat(b,") of Tensors with shapes ").concat(n.shape," and ")+"".concat(t.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")}));var w,S=a?[C,g,x]:[C,x,g],O=r?[N,k,b]:[N,b,k],F=Wt({inputs:{x:n},backend:o,attrs:{shape:S}}),A=Wt({inputs:{x:t},backend:o,attrs:{shape:O}}),E=[F,A],_=Math.max(C,N),D=a?F.shape[1]:F.shape[2],P=null!=s,M=null!=l,L="leakyrelu"===f,B=null!=f?At(f,!0):null;if((1===x||1===k)&&D>1e3&&!1===(P||M||L||null!=B)){var W=F,j=A;a&&(W=Yt({inputs:{x:F},backend:o,attrs:{perm:[0,2,1]}}),E.push(W)),r&&(j=Yt({inputs:{x:A},backend:o,attrs:{perm:[0,2,1]}}),E.push(j));var V=1===k,z=W;1!==k&&(z=Wt({inputs:{x:W},backend:o,attrs:{shape:[_,D,1]}}),E.push(z));var G=1===k?2:1,U=j;V&&(U=Wt({inputs:{x:j},backend:o,attrs:{shape:[_,1,D]}}),E.push(U));var H=Lt({inputs:{a:z,b:U},backend:o});w=qt({inputs:{x:H},backend:o,attrs:{axis:G,keepDims:!0}}),E.push(H)}else{var X=Object(i.upcastType)(n.dtype,t.dtype),q=new Et(S,O,[_,x,k],a,r,P,B,M,L),K=[F,A];if(null!=s&&K.push(s),M&&K.push(l),L){var Y=o.makeTensorInfo([],"float32",i.util.createScalarValue(p,"float32"));K.push(Y),E.push(Y)}w=o.runWebGLProgram(q,K,X)}var Q=Wt({inputs:{x:w},backend:o,attrs:{shape:R}});E.push(w);for(var Z=0,J=E;Z<J.length;Z++){var $=J[Z];o.disposeIntermediateTensorInfo($)}return Q}var Jt={kernelName:i._FusedMatMul,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.a,o=n.b,i=n.bias,c=n.preluActivationWeights,s=a.transposeA,u=a.transposeB,l=a.activation;return Zt({a:r,b:o,transposeA:s,transposeB:u,backend:t,bias:i,preluActivationWeights:c,leakyreluAlpha:a.leakyreluAlpha,activation:l})}},$t="return abs(x);";var ea={kernelName:i.Abs,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=t.x;if(a.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){var o=a.texData.get(r.dataId),c=Bn(o.values);return a.makeTensorInfo(r.shape,r.dtype,c)}return n=Object(i.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new pt(r.shape,$t):new et(r.shape,$t),a.runWebGLProgram(n,[r],r.dtype)}},na=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),ta={kernelName:i.Acos,backendName:"webgl",kernelFunc:na},aa=Ot({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),ra={kernelName:i.Acosh,backendName:"webgl",kernelFunc:aa},oa="return a + b;",ia=Ft({opSnippet:oa,packedOpSnippet:oa,supportsComplex:!0,cpuKernelImpl:gn}),ca={kernelName:i.Add,backendName:"webgl",kernelFunc:ia},sa=function e(n,t){Object(p.a)(this,e),this.outputShape=[],this.outputShape=n,this.variableNames=t.map((function(e,n){return"T".concat(n)}));var a=[];this.variableNames.forEach((function(e){a.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));var r=this.variableNames.map((function(e){return"v".concat(e)})).join(" + ");this.userCode="\n      void main() {\n        ".concat(a.join("\n        "),"\n\n        float result = ").concat(r,";\n        setOutput(result);\n      }\n    ")},ua=function e(n,t){Object(p.a)(this,e),this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=t.map((function(e,n){return"T".concat(n)}));var a=[];this.variableNames.forEach((function(e){a.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));var r=this.variableNames.map((function(e){return"v".concat(e)})).join(" + ");this.userCode="\n      void main() {\n        ".concat(a.join("\n        "),"\n\n        vec4 result = ").concat(r,";\n        setOutput(result);\n      }\n    ")};var la={kernelName:i.AddN,backendName:"webgl",kernelFunc:function e(n){var t=n.inputs,a=n.backend,r=t;if(1===r.length)return xt({inputs:{x:r[0]},backend:a});if(r.length>Object(i.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var o=Math.floor(r.length/2),c=e({inputs:r.slice(0,o),backend:a}),s=e({inputs:r.slice(o),backend:a});return e({inputs:[c,s],backend:a})}var u=r.map((function(e){return e.dtype})).reduce((function(e,n){return Object(i.upcastType)(e,n)})),l=r.map((function(e){return e.shape})),d=Object(i.env)().getBool("WEBGL_PACK")?new ua(r[0].shape,l):new sa(r[0].shape,l);return a.runWebGLProgram(d,r,u)}};var da={kernelName:i.All,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,s=a.keepDims,u=r.shape.length,l=i.util.parseAxisParam(o,r.shape),d=l,p=i.backend_util.getAxesPermutation(d,u),h=r;null!=p&&(h=Yt({inputs:{x:r},backend:t,attrs:{perm:p}}),d=i.backend_util.getInnerMostAxes(d.length,u)),i.backend_util.assertAxesAreInnerMostDims("all",d,u);var f,v=i.backend_util.computeOutAndReduceShapes(h.shape,d),m=Object(c.a)(v,2),g=m[0],b=m[1],x=Wt({inputs:{x:h},backend:t,attrs:{shape:[-1,i.util.sizeFromShape(b)]}}),k=Gt(x,x.dtype,"all",t);return f=Wt(s?{inputs:{x:k},backend:t,attrs:{shape:i.backend_util.expandShapeToKeepDim(g,l)}}:{inputs:{x:k},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(k),null!=p&&t.disposeIntermediateTensorInfo(h),f}};var pa={kernelName:i.Any,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,s=a.keepDims,u=r.shape.length,l=i.util.parseAxisParam(o,r.shape),d=l,p=i.backend_util.getAxesPermutation(d,u),h=r;null!=p&&(h=Yt({inputs:{x:r},backend:t,attrs:{perm:p}}),d=i.backend_util.getInnerMostAxes(d.length,u)),i.backend_util.assertAxesAreInnerMostDims("any",d,u);var f,v=i.backend_util.computeOutAndReduceShapes(h.shape,d),m=Object(c.a)(v,2),g=m[0],b=m[1],x=Wt({inputs:{x:h},backend:t,attrs:{shape:[-1,i.util.sizeFromShape(b)]}}),k=Gt(x,x.dtype,"any",t);return f=Wt(s?{inputs:{x:k},backend:t,attrs:{shape:i.backend_util.expandShapeToKeepDim(g,l)}}:{inputs:{x:k},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(k),null!=p&&t.disposeIntermediateTensorInfo(h),f}},ha=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["A"];var r=n.windowSize,o=n.batchSize,i=n.outSize;a||this.variableNames.push("bestIndicesA"),this.outputShape=[o,i];var c="max"===t?">":"<",s=a?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(r,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          int inIdx = ").concat(s,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(c," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")},fa=function e(n,t,a,r){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,i.util.assert(n.length>2,(function(){return"Packed arg".concat(a.charAt(0).toUpperCase()+a.slice(1)," supports only inputs with rank above 2.")}));var o=n[n.length-1],c=Math.ceil(o/t);this.outputShape=n.slice(0,-1),c>1&&this.outputShape.push(c),r||this.variableNames.push("bestIndicesA");var s,u,l=this.outputShape,d=l.length,h=Ae(d),f=qn("coords",d);if(1===c){var v=Ae(u=d+1);s="\n        ".concat(v," sourceLocR = ").concat(v,"(").concat(f.join(),", 0);\n        ++").concat(f[d-1],";\n        ").concat(v," sourceLocG = ").concat(v,"(").concat(f.join(),", 0);\n        ++").concat(f[d-2],";\n        ").concat(v," sourceLocA = ").concat(v,"(").concat(f.join(),", 0);\n        --").concat(f[d-1],";\n        ").concat(v," sourceLocB = ").concat(v,"(").concat(f.join(),", 0);\n        --").concat(f[d-2],";")}else u=d,s="\n        ".concat(h," sourceLocR = coords;\n        ++").concat(f[d-1],";\n        ").concat(h," sourceLocG = coords;\n        ++").concat(f[d-2],";\n        ").concat(h," sourceLocA = coords;\n        --").concat(f[d-1],";\n        ").concat(h," sourceLocB = coords;\n        --").concat(f[d-2],";");var m=["x","y","z","w","u","v"].slice(0,u),g="."+m[u-1],b=m.map((function(e){return"int "+e})),x=qn("sourceLocR",u-1).concat("inIdx.r"),k=qn("sourceLocG",u-1).concat("inIdx.g"),I=qn("sourceLocB",u-1).concat("inIdx.b"),y=qn("sourceLocA",u-1).concat("inIdx.a"),C="max"===a?"greaterThan":"lessThan",N=r?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(x.join(),"),\n                             getBestIndicesAChannel(").concat(k.join(),"),\n                             getBestIndicesAChannel(").concat(I.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),")));"),T="vec4(\n            getAChannel(".concat(x.join(),"),\n            hasNextCol ? getAChannel(").concat(k.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(I.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(y.join(),") : 0.)"),R=r?"":"\n      float getBestIndicesAChannel(".concat(b.join(),") {\n        return getChannel(getBestIndicesA(").concat(m.join(),"),\n                                          vec2(").concat(m.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(b.join(),") {\n        return getChannel(getA(").concat(m.join(),"),\n                               vec2(").concat(m.slice(-2).join(),"));\n      }\n      ").concat(R,"\n      void main() {\n        ").concat(h," coords = getOutputCoords();\n        bool hasNextCol = ").concat(f[d-1]," < ").concat(l[d-1]-1,";\n        bool hasNextRow = ").concat(f[d-2]," < ").concat(l[d-2]-1,";\n        ").concat(s,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(g,", sourceLocG").concat(g,",\n          sourceLocB").concat(g,", sourceLocA").concat(g,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(T,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(N,"\n          vec4 candidate = ").concat(T,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(C,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")};function va(e,n,t){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=n.shape[0],o=n.shape[1];null!=a&&(r=a.shape[0],o=a.shape[1]);var c=i.backend_util.computeOptimalWindowSize(o),s={windowSize:c,inSize:o,batchSize:r,outSize:Math.ceil(o/c)},u=new ha(s,t,null==a),l=[n];null!=a&&l.push(a);var d=e.runWebGLProgram(u,l,"int32");if(1===d.shape[1])return d;var p=va(e,n,t,d);return e.disposeIntermediateTensorInfo(d),p}function ma(e,n,t){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=null!=a?a.shape:n.shape,o=r[r.length-1],c=i.backend_util.computeOptimalWindowSize(o),s=new fa(r,c,t,null==a),u=null==a?[n]:[n,a],l=e.runWebGLProgram(s,u,"int32");if(l.shape.length===n.shape.length){var d=ma(e,n,t,l);return e.disposeIntermediateTensorInfo(l),d}return l}function ga(e,n,t,a){var r=[t];if(i.backend_util.assertAxesAreInnerMostDims("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,n.shape.length),!Object(i.env)().getBool("WEBGL_PACK_REDUCE")||n.shape.length<=2){var o=[],s=i.backend_util.computeOutAndReduceShapes(n.shape,r),u=Object(c.a)(s,2),l=u[0],d=u[1],p=i.util.sizeFromShape(d),h=Wt({inputs:{x:n},backend:e,attrs:{shape:[-1,p]}});o.push(h);var f=va(e,h,a);o.push(f);var v=Wt({inputs:{x:f},backend:e,attrs:{shape:l}});return o.forEach((function(n){return e.disposeIntermediateTensorInfo(n)})),v}return ma(e,n,a)}var ba={kernelName:i.ArgMax,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,c=i.util.parseAxisParam(o,r.shape),s=i.backend_util.getAxesPermutation(c,r.shape.length),u=r,l=[];null!=s&&(u=Yt({inputs:{x:r},backend:t,attrs:{perm:s}}),l.push(u),c=i.backend_util.getInnerMostAxes(c.length,u.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMax",[c[0]],u.shape.length);var d=ga(t,u,c[0],"max");return l.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),d}};var xa={kernelName:i.ArgMin,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,c=i.util.parseAxisParam(o,r.shape),s=i.backend_util.getAxesPermutation(c,r.shape.length),u=r,l=[];null!=s&&(u=Yt({inputs:{x:r},backend:t,attrs:{perm:s}}),l.push(u),c=i.backend_util.getInnerMostAxes(c.length,u.shape.length)),i.backend_util.assertAxesAreInnerMostDims("argMin",[c[0]],u.shape.length);var d=ga(t,u,c[0],"min");return l.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),d}},ka=Ot({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),Ia={kernelName:i.Asin,backendName:"webgl",kernelFunc:ka},ya=Ot({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),Ca={kernelName:i.Asinh,backendName:"webgl",kernelFunc:ya},Na=Ot({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),Ta={kernelName:i.Atan,backendName:"webgl",kernelFunc:Na},Ra=Ft({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),wa={kernelName:i.Atan2,backendName:"webgl",kernelFunc:Ra},Sa=Ot({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Oa={kernelName:i.Atanh,backendName:"webgl",kernelFunc:Sa},Fa=function e(n,t,a){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(Object(p.a)(this,e),this.variableNames=["x"],"avg"===t&&a)throw new Error("Cannot compute positions for average pool.");var i=n.filterWidth,c=n.strideHeight,s=n.strideWidth,u=n.dilationHeight,l=n.dilationWidth,d=n.effectiveFilterHeight,h=n.effectiveFilterWidth,f=n.padInfo.top,v=n.padInfo.left;this.outputShape=n.outShape;var m="avg"===t,g="((batch  * ".concat(n.inHeight," + xR) * ").concat(n.inWidth," + xC) * ").concat(n.inChannels," + d"),b="(xR * ".concat(n.inWidth," + xC) * ").concat(n.inChannels," + d"),x="0.0";if(m||(x="-1.0 / 1e-20"),a){var k=">=";this.userCode="\n        const ivec2 strides = ivec2(".concat(c,", ").concat(s,");\n        const ivec2 pads = ivec2(").concat(f,", ").concat(v,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(d,";\n              wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(n.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(k," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(r?o?g:b:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ")}else{var I="max",y="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(y="avgValue / count");var C=4*Math.floor(i/4),N=i%4,T="\n      if (".concat(m,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(I,"(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(c,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(f,", ").concat(v,");\n      const float initializationValue = ").concat(x,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(n.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(x,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(d,";\n            wR += ").concat(u,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(n.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(C,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(T,"\n          }\n\n          int xC = xCCorner + ").concat(C,";\n          if (").concat(1===N,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(T,"\n          } else if (").concat(2===N,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(T,"\n          } else if (").concat(3===N,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(T,"\n          }\n        }\n        setOutput(").concat(y,");\n      }\n    ")}},Aa=function e(n,t,a){var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(Object(p.a)(this,e),this.variableNames=["x"],"avg"===t&&a)throw new Error("Cannot compute positions for average pool.");var i=n.filterWidth,c=n.strideDepth,s=n.strideHeight,u=n.strideWidth,l=n.dilationDepth,d=n.dilationHeight,h=n.dilationWidth,f=n.effectiveFilterDepth,v=n.effectiveFilterHeight,m=n.effectiveFilterWidth,g=n.padInfo.front,b=n.padInfo.top,x=n.padInfo.left;this.outputShape=n.outShape;var k="avg"===t,I="0.0";if(k||(I="-1.0 / 1e-20"),a){var y=">=";this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(c,", ").concat(s,", ").concat(u,");\n        const ivec3 pads = ivec3(").concat(g,", ").concat(b,", ").concat(x,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(f,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(n.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(v,";\n                wR += ").concat(d,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(n.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(m,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(y," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(r?o?"(((batch * ".concat(n.inDepth," + xD) * ").concat(n.inHeight," + xR) * ").concat(n.inWidth," + xC) * ").concat(n.inChannels," + ch"):"((xD * ".concat(n.inHeight," + xR) * ").concat(n.inWidth," + xC) * ").concat(n.inChannels," + ch"):"wD * ".concat(v," * ").concat(m," +\n                      wR * ").concat(m," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ")}else{var C="max",N="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(N="avgValue / count");var T=4*Math.floor(i/4),R=i%4,w="\n      if (".concat(k,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat(C,"(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(c,", ").concat(s,", ").concat(u,");\n      const ivec3 pads = ivec3(").concat(g,", ").concat(b,", ").concat(x,");\n      const float initializationValue = ").concat(I,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(n.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(I,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(f,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(n.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(v,";\n            wR += ").concat(d,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(n.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(T,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(w,"\n            }\n\n            int xC = xCCorner + ").concat(T,";\n            if (").concat(1===R,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(w,"\n            } else if (").concat(2===R,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(w,"\n            } else if (").concat(3===R,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(w,"\n            }\n          }\n          setOutput(").concat(N,");\n        }\n      }\n    ")}};var Ea={kernelName:i.AvgPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x;Q(r,"avgPool");var o=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode;i.util.assert(i.backend_util.eitherStridesOrDilationsAreOne(c,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(c," and dilations '").concat(1,"'")}));var l=i.backend_util.computePool2DInfo(r.shape,o,c,1,s,u);if(1===l.filterWidth&&1===l.filterHeight&&i.util.arraysEqual(l.inShape,l.outShape))return xt({inputs:{x:r},backend:t});var d=new Fa(l,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}};var _a={kernelName:i.AvgPool3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode,l=a.dataFormat,d=i.backend_util.computePool3DInfo(r.shape,o,c,[1,1,1],s,u,l),p=new Aa(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}},Da=function e(n){Object(p.a)(this,e),this.variableNames=["dy"],this.outputShape=n.inShape;var t=n.filterHeight,a=n.filterWidth,r=n.strideHeight,o=n.strideWidth,i=n.dilationHeight,c=n.dilationWidth,s=n.effectiveFilterHeight,u=n.effectiveFilterWidth,l=s-1-n.padInfo.top,d=u-1-n.padInfo.left,h=1/(t*a);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(d,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(s,";\n            wR += ").concat(i,") {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(u,";\n            wC+= ").concat(c,") {\n            float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Pa=function e(n){Object(p.a)(this,e),this.variableNames=["dy"],this.outputShape=n.inShape;var t=n.filterDepth,a=n.filterHeight,r=n.filterWidth,o=n.strideDepth,i=n.strideHeight,c=n.strideWidth,s=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,d=n.effectiveFilterDepth,h=n.effectiveFilterHeight,f=n.effectiveFilterWidth,v=d-1-n.padInfo.front,m=h-1-n.padInfo.top,g=f-1-n.padInfo.left,b=1/(t*a*r);this.userCode="\n      const ivec3 pads = ivec3(".concat(v,", ").concat(m,", ").concat(g,");\n      const float avgMultiplier = float(").concat(b,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(s,") {\n          float dyD = float(dyDCorner + wD) / ").concat(o,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(n.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(u,") {\n            float dyR = float(dyRCorner + wR) / ").concat(i,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(f,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(c,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")};var Ma={kernelName:i.AvgPool3DGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,c=a.filterSize,s=a.strides,u=a.pad,l=a.dimRoundingMode,d=i.backend_util.computePool3DInfo(o.shape,c,s,[1,1,1],u,l),p=new Pa(d);return t.runWebGLProgram(p,[r],o.dtype)}};var La={kernelName:i.AvgPoolGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,c=o;Q([r,o],"avgPoolGrad");var s=a.filterSize,u=a.strides,l=a.pad,d=i.backend_util.computePool2DInfo(c.shape,s,u,1,l),p=new Da(d);return t.runWebGLProgram(p,[r],c.dtype)}};var Ba={kernelName:i.BatchMatMul,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs;return Zt({a:n.a,b:n.b,transposeA:a.transposeA,transposeB:a.transposeB,backend:t})}},Wa=function e(n,t,a,r,o,c){Object(p.a)(this,e),this.outputShape=[],this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(n,t),i.backend_util.assertAndGetBroadcastShape(n,a);var s="0.0";null!=r&&(i.backend_util.assertAndGetBroadcastShape(n,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");var u="1.0";null!=o&&(i.backend_util.assertAndGetBroadcastShape(n,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(s,";\n        float scale = ").concat(u,";\n        float inv = scale * inversesqrt(variance + float(").concat(c,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")},ja=function e(n,t,a,r,o,c){Object(p.a)(this,e),this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],i.backend_util.assertAndGetBroadcastShape(n,t),i.backend_util.assertAndGetBroadcastShape(n,a);var s="vec4(0.0)";null!=r&&(i.backend_util.assertAndGetBroadcastShape(n,r),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");var u="vec4(1.0)";null!=o&&(i.backend_util.assertAndGetBroadcastShape(n,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=n,this.userCode="\n      void main() {\n        vec4 offset = ".concat(s,";\n        vec4 scale = ").concat(u,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(c,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")},Va={kernelName:i.FusedBatchNorm,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.mean,c=n.variance,s=n.offset,u=n.scale;i.util.assert(o.shape.length===c.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),i.util.assert(null==s||o.shape.length===s.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),i.util.assert(null==u||o.shape.length===u.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."}));var l=a.varianceEpsilon;null==l&&(l=.001);var d=[r,o,c],p=null;null!=s&&(p=s.shape,d.push(s));var h=null;null!=u&&(h=u.shape,d.push(u));var f=Object(i.env)().getBool("WEBGL_PACK_NORMALIZATION")?new ja(r.shape,o.shape,c.shape,p,h,l):new Wa(r.shape,o.shape,c.shape,p,h,l);return t.runWebGLProgram(f,d,d[0].dtype)}},za=function(){function e(n){Object(p.a)(this,e),this.variableNames=["source"],this.outputShape=n,this.rank=n.length;var t,a=Ae(this.rank),r="uniform int start[".concat(this.rank,"];"),o=function(e){if(1===e)return"sourceLoc";if(e<=6)return Ga.slice(0,e).map((function(e){return"sourceLoc."+e})).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank),i=n.map((function(e,n){return"sourceLoc.".concat(Ga[n]," = start[").concat(n,"] + coords.").concat(Ga[n],";")}));t="\n        ".concat(a," sourceLoc;\n        ").concat(a," coords = getOutputCoords();\n        ").concat(i.join("\n"),"\n      "),this.userCode="\n      ".concat(r,"\n      void main() {\n        ").concat(t,"\n        setOutput(getSource(").concat(o,"));\n      }\n    ")}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e){var n=this;if(e.length!==this.rank)throw Error("The rank (".concat(this.rank,") of the program must match the ")+"length of start (".concat(e.length,")"));return function(t,a){null==n.startLoc&&(n.startLoc=t.getUniformLocationNoThrow(a,"start"),null==n.startLoc)||t.gl.uniform1iv(n.startLoc,e)}}}]),e}(),Ga=["x","y","z","w","u","v"];var Ua=function(){function e(n){Object(p.a)(this,e),this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.rank=n.length;var t=Ae(this.rank),a=qn("coords",this.rank),r=qn("sourceLoc",this.rank),o=1===this.rank?"sourceLoc":"vec2(".concat(r.slice(-2).join(),")"),i="getChannel(getSource(".concat(r.join(),"), ").concat(o,")"),c="\n      result.x = ".concat(i,";\n      if (++").concat(a[this.rank-1]," < ").concat(n[this.rank-1],") {\n        ++").concat(r[this.rank-1],";\n        result.y = ").concat(i,";\n        --").concat(r[this.rank-1],";\n      }\n    "),s=1===this.rank?"":"\n      --".concat(a[this.rank-1],";\n      if (++").concat(a[this.rank-2]," < ").concat(n[this.rank-2],") {\n        ++").concat(r[this.rank-2],";\n        result.z = ").concat(i,";\n        if (++").concat(a[this.rank-1]," < ").concat(n[this.rank-1],") {\n          ++").concat(r[this.rank-1],";\n          result.w = ").concat(i,";\n        }\n      }\n    "),u=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(n.map((function(e,n){return"start[".concat(n,"]")})).join(),");"):n.map((function(e,n){return"".concat(r[n]," = ").concat(a[n]," + start[").concat(n,"];")})).join("\n");this.userCode="\n      uniform int start[".concat(this.rank,"];\n      void main() {\n        ").concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(u,"\n        vec4 result = vec4(0.);\n        ").concat(c,"\n        ").concat(s,"\n        setOutput(result);\n      }\n    ")}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e){var n=this;if(e.length!==this.rank)throw Error("The rank (".concat(this.rank,") of the program must match the ")+"length of start (".concat(e.length,")"));return function(t,a){null==n.startLoc&&(n.startLoc=t.getUniformLocationNoThrow(a,"start"),null==n.startLoc)||t.gl.uniform1iv(n.startLoc,e)}}}]),e}();function Ha(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.begin,s=a.size,u=i.slice_util.parseSliceParams(r,o,s),l=Object(c.a)(u,2),d=l[0],p=l[1];if(i.slice_util.assertParamsValid(r,d,p),0===i.util.sizeFromShape(p))return t.makeTensorInfo(p,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||"string"===r.dtype){var h=t.texData.get(r.dataId),f=Wn(h.values,d,p,r.shape,r.dtype);return t.makeTensorInfo(p,r.dtype,f)}var v=t.texData.get(r.dataId).isPacked,m=i.slice_util.isSliceContinous(r.shape,d,p);if(v||!m){var g=Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Ua(p):new za(p),b=g.getCustomSetupFunc(d);return t.runWebGLProgram(g,[r],r.dtype,b)}return t.uploadToGPU(r.dataId),function(e,n,t,a){var r=a.texData.get(e.dataId),o=a.makeTensorInfo(t,e.dtype),c=a.texData.get(o.dataId);Object.assign(c,r),c.complexParentRefCount=0,c.refCount=1,c.shape=t,c.dtype=e.dtype;var s=i.slice_util.computeFlatOffset(n,i.util.computeStrides(e.shape));r.slice&&(s+=r.slice.flatOffset),c.slice={flatOffset:s,origDataId:r.slice&&r.slice.origDataId||e.dataId};var u=a.dataRefCount.get(c.slice.origDataId)||1;return a.dataRefCount.set(c.slice.origDataId,u+1),o}(r,d,p,t)}var Xa={kernelName:i.Slice,backendName:"webgl",kernelFunc:Ha},qa={kernelName:i.BatchToSpaceND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockShape,c=a.crops;i.util.assert(r.shape.length<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}));var s=o.reduce((function(e,n){return e*n})),u=i.backend_util.getReshaped(r.shape,o,s),l=i.backend_util.getPermuted(u.length,o.length),d=i.backend_util.getReshapedPermuted(r.shape,o,s),p=i.backend_util.getSliceBeginCoords(c,o.length),h=i.backend_util.getSliceSize(d,c,o.length),f=[],v=Wt({inputs:{x:r},backend:t,attrs:{shape:u}}),m=Yt({inputs:{x:v},backend:t,attrs:{perm:l}}),g=Wt({inputs:{x:m},backend:t,attrs:{shape:d}}),b=Ha({inputs:{x:g},backend:t,attrs:{begin:p,size:h}});return f.push(v),f.push(m),f.push(g),f.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),b}};var Ka={kernelName:i.Bincount,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.weights,i=a.size,c=t.readSync(r.dataId),s=t.readSync(o.dataId),u=bn(c,s,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,u)}},Ya=Ft({opSnippet:"return float(a != b);",dtype:"bool"}),Qa={kernelName:i.NotEqual,backendName:"webgl",kernelFunc:Ya};function Za(e){var n=e.inputs,t=e.backend,a=n.input;return xt({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.real},backend:t})}var Ja={kernelName:i.Real,backendName:"webgl",kernelFunc:Za};var $a={kernelName:i.Cast,backendName:"webgl",kernelFunc:function e(n){var t=n.inputs,a=n.backend,r=n.attrs,o=t.x,c=r.dtype;if("complex64"===c){if("complex64"===o.dtype)return xt({inputs:{x:o},backend:a});var s=i.zeros(o.shape),u=e({inputs:{x:o},backend:a,attrs:{dtype:"float32"}}),l=It({inputs:{real:u,imag:s},backend:a});return s.dispose(),a.disposeIntermediateTensorInfo(u),l}if("complex64"===o.dtype){var d=Za({inputs:{input:o},backend:a}),p=e({inputs:{x:d},backend:a,attrs:{dtype:c}});return a.disposeIntermediateTensorInfo(d),p}if(!i.util.hasEncodingLoss(o.dtype,c)){var h=xt({inputs:{x:o},backend:a});return{dataId:h.dataId,shape:h.shape,dtype:c}}if("int32"===c)return function(e,n){var t=new et(e.shape,"return float(int(x));"),a=n.runWebGLProgram(t,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(o,a);if("bool"===c){var f=a.makeTensorInfo([],"bool",i.util.getTypedArrayFromDType("bool",1)),v=Ya({inputs:{a:o,b:f},backend:a});return a.disposeIntermediateTensorInfo(f),v}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(c))}},er="return ceil(x);",nr=Ot({opSnippet:er,packedOpSnippet:er,cpuKernelImpl:kn}),tr={kernelName:i.Ceil,backendName:"webgl",kernelFunc:nr},ar=function(){function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e,n){var t=this;return function(a,r){null==t.minLoc&&(t.minLoc=a.getUniformLocationNoThrow(r,"minVal"),t.maxLoc=a.getUniformLocationNoThrow(r,"maxVal")),a.gl.uniform1f(t.minLoc,e),a.gl.uniform1f(t.maxLoc,n)}}}]),e}(),rr=function(){function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode="\n      uniform float minVal;\n      uniform float maxVal;\n\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e,n){var t=this;return function(a,r){null==t.minLoc&&(t.minLoc=a.getUniformLocationNoThrow(r,"minVal"),t.maxLoc=a.getUniformLocationNoThrow(r,"maxVal")),a.gl.uniform1f(t.minLoc,e),a.gl.uniform1f(t.maxLoc,n)}}}]),e}();var or={kernelName:i.ClipByValue,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,c=r.clipValueMin,s=r.clipValueMax,u=(n=Object(i.env)().getBool("WEBGL_PACK_CLIP")?new rr(o.shape):new ar(o.shape)).getCustomSetupFunc(c,s);return a.runWebGLProgram(n,[o],o.dtype,u)}},ir=function e(n){Object(p.a)(this,e),this.variableNames=["real","imag"],this.outputShape=n,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "};function cr(e,n){return{dataId:n.dataId,dtype:n.dtype,shape:e.shape}}var sr={kernelName:i.ComplexAbs,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=t.texData.get(a.dataId),o=new ir(a.shape),i=[cr(a,r.complexTensorInfos.real),cr(a,r.complexTensorInfos.imag)];return t.runWebGLProgram(o,i,i[0].dtype)}},ur=function e(n){Object(p.a)(this,e),this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(n,1),this.variableNames=n.map((function(e,n){return"T".concat(n)}));var t=new Array(n.length-1);t[0]=n[0][1];for(var a=1;a<t.length;a++)t[a]=t[a-1]+n[a][1];for(var r=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")],o=1;o<t.length;o++){var c=t[o-1];r.push("else if (yC < ".concat(t[o],") ")+"setOutput(getT".concat(o,"(yR, yC-").concat(c,"));"))}var s=t.length,u=t[t.length-1];r.push("else setOutput(getT".concat(s,"(yR, yC-").concat(u,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(r.join("\n        "),"\n      }\n    ")},lr=function e(n,t){Object(p.a)(this,e),this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=i.backend_util.computeOutShape(n,t);var a=this.outputShape,r=a.length,o=Ae(r),c=qn("coords",r),s=["x","y","z","w","u","v"].slice(0,r);this.variableNames=n.map((function(e,n){return"T".concat(n)}));var u=new Array(n.length-1);u[0]=n[0][t];for(var l=1;l<u.length;l++)u[l]=u[l-1]+n[l][t];for(var d=s[t],h=s.slice(-2),f=s.join(),v="if (".concat(d," < ").concat(u[0],") {\n        return getChannel(\n            getT0(").concat(f,"), vec2(").concat(h.join(),"));\n        }"),m=1;m<u.length;m++){var g=u[m-1];v+="\n        if (".concat(d," < ").concat(u[m],"  && ").concat(d," >= ").concat(u[m-1],") {\n          return getChannel(\n            getT").concat(m,"(").concat(dr(s,d,g),"),\n            vec2(").concat(dr(h,d,g),"));\n        }")}var b=u.length,x=u[u.length-1];v+="\n        return getChannel(\n          getT".concat(b,"(").concat(dr(s,d,x),"),\n          vec2(").concat(dr(h,d,x),"));"),this.userCode="\n      float getValue(".concat(s.map((function(e){return"int "+e})),") {\n        ").concat(v,"\n      }\n\n      void main() {\n        ").concat(o," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(c,"), 0., 0., 0.);\n\n        ").concat(c[r-1]," = ").concat(c[r-1]," + 1;\n        if (").concat(c[r-1]," < ").concat(a[r-1],") {\n          result.g = getValue(").concat(c,");\n        }\n\n        ").concat(c[r-2]," = ").concat(c[r-2]," + 1;\n        if (").concat(c[r-2]," < ").concat(a[r-2],") {\n          result.a = getValue(").concat(c,");\n        }\n\n        ").concat(c[r-1]," = ").concat(c[r-1]," - 1;\n        if (").concat(c[r-2]," < ").concat(a[r-2]," &&\n            ").concat(c[r-1]," < ").concat(a[r-1],") {\n          result.b = getValue(").concat(c,");\n        }\n        setOutput(result);\n      }\n    ")};function dr(e,n,t){var a=e.indexOf(n);return e.map((function(e,n){return n===a?"".concat(e," - ").concat(t):e})).join()}function pr(e){var n=e.inputs,t=e.backend,a=n.input;return xt({inputs:{x:t.texData.get(a.dataId).complexTensorInfos.imag},backend:t})}var hr={kernelName:i.Imag,backendName:"webgl",kernelFunc:pr};function fr(e,n,t){var a=e[0].dtype;if("complex64"===a){var r=e.map((function(e){return Za({inputs:{input:e},backend:t})})),o=e.map((function(e){return pr({inputs:{input:e},backend:t})})),c=fr(r,n,t),s=fr(o,n,t),u=It({inputs:{real:c,imag:s},backend:t});return r.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),o.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(s),u}if("string"===a){var l=vr(e,n,t),d=l.tensors2D,p=l.outShape,h=d.map((function(e){return{vals:t.readSync(e.dataId),shape:e.shape}})),f=1===d[0].shape[0],v=In(h,p,a,f),m=i.backend_util.computeOutShape(e.map((function(e){return e.shape})),n),g=t.makeTensorInfo(m,a,v);return d.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),g}if(e.length>Object(i.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var b=Math.floor(e.length/2),x=fr(e.slice(0,b),n,t),k=fr(e.slice(b),n,t),I=fr([x,k],n,t);return t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(k),I}if(Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].shape.length>1){var y=new lr(e.map((function(e){return e.shape})),n);return t.runWebGLProgram(y,e,a)}var C=vr(e,n,t),N=C.tensors2D,T=C.outShape,R=new ur(N.map((function(e){return e.shape}))),w=t.runWebGLProgram(R,N,a);N.forEach((function(e){return t.disposeIntermediateTensorInfo(e)}));var S=Wt({inputs:{x:w},attrs:{shape:T},backend:t});return t.disposeIntermediateTensorInfo(w),S}function vr(e,n,t){var a=i.backend_util.computeOutShape(e.map((function(e){return e.shape})),n);return{tensors2D:e.map((function(e){return Wt({inputs:{x:e},attrs:{shape:[-1,i.util.sizeFromShape(e.shape.slice(n))]},backend:t})})),outShape:a}}function mr(e){var n=e.inputs,t=e.backend,a=e.attrs.axis,r=i.util.parseAxisParam(a,n[0].shape)[0],o=i.backend_util.computeOutShape(n.map((function(e){return e.shape})),r);if(0===i.util.sizeFromShape(o))return t.makeTensorInfo(o,n[0].dtype,[]);var c=n.filter((function(e){return i.util.sizeFromShape(e.shape)>0}));if(1===c.length)return xt({inputs:{x:c[0]},backend:t});var s=c.map((function(e){return e.shape}));return i.backend_util.assertParamsConsistent(s,r),fr(c,r,t)}var gr={kernelName:i.Concat,backendName:"webgl",kernelFunc:mr},br=function e(n){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];Object(p.a)(this,e),this.variableNames=["x","W"],this.outputShape=n.outShape;var i=n.padInfo.top,c=n.padInfo.left,s=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,d=n.dilationWidth,h=n.filterHeight,f=n.filterWidth,v=4*Math.floor(n.inChannels/4),m=n.inChannels%4,g="channelsLast"===n.dataFormat,b=g?1:2,x=g?2:3,k=g?3:1,I="",y="";a&&(I=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(a,"\n        }"):o?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(a,"\n        }"):"\n          float activation(float x) {\n            ".concat(a,"\n          }\n        "),y="result = activation(result);");var C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(I,"\n\n      const ivec2 strides = ivec2(").concat(s,", ").concat(u,");\n      const ivec2 pads = ivec2(").concat(i,", ").concat(c,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(k,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(b,"], coords[").concat(x,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(n.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(f,"; wC++) {\n            int xC = xCCorner + wC * ").concat(d,";\n\n            if (xC < 0 || xC >= ").concat(n.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(v,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(g,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===m,") {\n\n              if (").concat(g,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(v,") *\n                    getW(wR, wC, ").concat(v,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(v,", xR, xC) *\n                    getW(wR, wC, ").concat(v,", d2);\n              }\n\n            } else if (").concat(2===m,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(v,", d2),\n                getW(wR, wC, ").concat(v," + 1, d2)\n              );\n\n              if (").concat(g,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(v,"),\n                  getX(batch, xR, xC, ").concat(v," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(v,", xR, xC),\n                  getX(batch, ").concat(v," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===m,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(v,", d2),\n                getW(wR, wC, ").concat(v," + 1, d2),\n                getW(wR, wC, ").concat(v," + 2, d2)\n              );\n\n              if (").concat(g,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(v,"),\n                  getX(batch, xR, xC, ").concat(v," + 1),\n                  getX(batch, xR, xC, ").concat(v," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(v,", xR, xC),\n                  getX(batch, ").concat(v," + 1, xR, xC),\n                  getX(batch, ").concat(v," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(C,"\n        ").concat(y,"\n        setOutput(result);\n      }\n    ")},xr=function e(n){Object(p.a)(this,e),this.variableNames=["x","W"],this.outputShape=n.outShape;var t=n.padInfo.front,a=n.padInfo.top,r=n.padInfo.left,o=n.strideDepth,i=n.strideHeight,c=n.strideWidth,s=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,d=n.filterDepth,h=n.filterHeight,f=n.filterWidth,v=4*Math.floor(n.inChannels/4),m=n.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(o,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(a,", ").concat(r,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(d,"; wF++) {\n          int xF = xFCorner + wF * ").concat(s,";\n\n          if (xF < 0 || xF >= ").concat(n.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(u,";\n\n            if (xR < 0 || xR >= ").concat(n.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(f,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(v,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===m,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(v,") *\n                  getW(wF, wR, wC, ").concat(v,", d2);\n              } else if (").concat(2===m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(v,"),\n                  getX(batch, xF, xR, xC, ").concat(v," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(v,", d2),\n                  getW(wF, wR, wC, ").concat(v," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(v,"),\n                  getX(batch, xF, xR, xC, ").concat(v," + 1),\n                  getX(batch, xF, xR, xC, ").concat(v," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(v,", d2),\n                  getW(wF, wR, wC, ").concat(v," + 1, d2),\n                  getW(wF, wR, wC, ").concat(v," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},kr=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;for(var r=a.filterWidth,o=a.inChannels,i=a.strideWidth,c=a.strideHeight,s=a.padInfo,u=a.outWidth,l=a.dilationWidth,d=a.dilationHeight,h=a.dataFormat,f=s.left,v=s.top,m=o*r,g=J(),b="channelsLast"===h,x=b?0:1,k=b?1:2,I="",y=0;y<=1;y++)for(var C=0;C<=1;C++)I+="\n          blockIndex = rc.y + ".concat(C,";\n          pos = rc.x + ").concat(y,";\n\n          if(blockIndex < ").concat(n[1]," && pos < ").concat(n[0],") {\n            offsetY = int(blockIndex / (").concat(u,")) * ").concat(c," - ").concat(v,";\n            d0 = offsetY + ").concat(d," * (pos / ").concat(m,");\n\n            if(d0 < ").concat(t[x]," && d0 >= 0) {\n\n              offsetX = int(mod(float(blockIndex), ").concat(u,".) * ").concat(i,". - ").concat(f,".);\n              d1 = offsetX + ").concat(l," * (int(mod(float(pos), ").concat(m,".) / ").concat(o,".));\n\n              if(d1 < ").concat(t[k]," && d1 >= 0) {\n\n                ch = int(mod(float(pos), ").concat(o,".));\n\n                if (").concat(b,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*y+C,"] = getChannel(\n                    getA(d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*y+C,"] = getChannel(\n                    getA(ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec2 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(I,"\n\n        ").concat(g.output," = result;\n      }\n    ")};function Ir(e){var n,t=e.x,a=e.filter,r=e.convInfo,o=e.backend,c=e.bias,s=void 0===c?null:c,u=e.preluActivationWeights,l=void 0===u?null:u,d=e.leakyreluAlpha,p=void 0===d?0:d,h=e.activation,f=void 0===h?null:h,v=t.shape,m=o.texData.get(t.dataId),g=r.inChannels,b=v[0]*v[1]*v[2],x=r.outChannels,k="channelsLast"===r.dataFormat,I=[],y=(1===b||1===x)&&g>1e3,C=v[2]%2!==0&&!!m.isPacked;if(!y&&Object(i.env)().getBool("WEBGL_LAZILY_UNPACK")&&Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&C){var N=k?v[0]*v[1]*(v[2]+1):v[0]*v[2]*(v[3]+1),T={dataId:t.dataId,shape:[1,N,r.inChannels],dtype:t.dtype},R=m.shape;m.shape=m.shape.slice(),m.shape[m.shape.length-2]++,i.util.assert(H(m.shape,T.shape),(function(){return"packed reshape ".concat(m.shape," to ").concat(T.shape," isn't free")}));var w=Wt({inputs:{x:a},backend:o,attrs:{shape:[1,r.inChannels,r.outChannels]}});I.push(w);var S=Zt({a:T,b:w,backend:o,transposeA:false,transposeB:false,bias:s,activation:f,preluActivationWeights:l,leakyreluAlpha:p}),O=o.texData.get(S.dataId);i.util.assert(O.isPacked,(function(){return"batchMatMul result is expected to be packed"})),m.shape=R,O.shape=r.outShape,(n=xt({inputs:{x:S},backend:o})).shape=r.outShape,I.push(S)}else{var F=Wt({inputs:{x:t},backend:o,attrs:{shape:[1,k?v[0]*v[1]*v[2]:v[0]*v[2]*v[3],r.inChannels]}}),A=Wt({inputs:{x:a},backend:o,attrs:{shape:[1,r.inChannels,r.outChannels]}}),E=Zt({a:F,b:A,transposeA:false,transposeB:false,backend:o,bias:s,activation:f,preluActivationWeights:l,leakyreluAlpha:p});n=Wt({inputs:{x:E},backend:o,attrs:{shape:r.outShape}}),I.push(F),I.push(A),I.push(E)}for(var _=0,D=I;_<D.length;_++){var P=D[_];o.disposeIntermediateTensorInfo(P)}return n}function yr(e){var n=e.x,t=e.filter,a=e.convInfo,r=e.backend,o=e.bias,c=void 0===o?null:o,s=e.preluActivationWeights,u=void 0===s?null:s,l=e.leakyreluAlpha,d=void 0===l?0:l,p=e.activation,h=void 0===p?null:p,f=a.filterWidth,v=a.filterHeight,m=a.inChannels,g=a.outWidth,b=a.outHeight,x="channelsLast"===a.dataFormat,k=f*v*m,I=b*g,y=[k,I],C=[],N=Wt({inputs:{x:n},backend:r,attrs:{shape:n.shape.slice(1)}}),T=Wt({inputs:{x:t},backend:r,attrs:{shape:[1,k,i.util.sizeFromShape(t.shape)/k]}});C.push(N),C.push(T);var R=new kr(y,N.shape,a),w=r.runWebGLProgram(R,[N],"float32"),S=Wt({inputs:{x:w},backend:r,attrs:{shape:[1,y[0],y[1]]}});C.push(w),C.push(S);var O=null!=c,F=null!=u,A="leakyrelu"===h,E=h?At(h,!0):null,_=new Et(S.shape,T.shape,[1,I,a.outChannels],!0,!1,O,E,F,A),D=[S,T];if(c&&D.push(c),F&&D.push(u),A){var P=r.makeTensorInfo([],"float32",i.util.createScalarValue(d,"float32"));D.push(P),C.push(P)}var M=r.runWebGLProgram(_,D,"float32"),L=Wt({inputs:{x:M},backend:r,attrs:{shape:x?[1,b,g,a.outChannels]:[1,a.outChannels,b,g]}});C.push(M);for(var B=0,W=C;B<W.length;B++){var j=W[B];r.disposeIntermediateTensorInfo(j)}return L}var Cr={kernelName:i.Conv2D,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,c=t.filter,s=r.strides,u=r.pad,l=r.dataFormat,d=r.dilations,p=r.dimRoundingMode,h=i.backend_util.convertConv2DDataFormat(l),f=i.backend_util.computeConv2DInfo(o.shape,c.shape,s,d,u,p,!1,h);if(1!==f.filterHeight||1!==f.filterWidth||1!==f.dilationHeight||1!==f.dilationWidth||1!==f.strideHeight||1!==f.strideWidth||"SAME"!==f.padInfo.type&&"VALID"!==f.padInfo.type)if(Object(i.env)().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])n=yr({x:o,filter:c,convInfo:f,backend:a});else{var v=new br(f);n=a.runWebGLProgram(v,[o,c],"float32")}else n=Ir({x:o,filter:c,convInfo:f,backend:a});var m=Wt({inputs:{x:n},backend:a,attrs:{shape:f.outShape}});return a.disposeIntermediateTensorInfo(n),m}},Nr=function e(n){Object(p.a)(this,e),this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideHeight,a=n.strideWidth,r=n.padInfo.top,o=n.padInfo.left,i="channelsLast"===n.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(n.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(n.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(n.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(n.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(a," - ").concat(o,";\n\n              if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                continue;\n              }\n\n              if (").concat(i,") {\n                float dyValue = getDy(b, yR, yC, d2);\n                float xValue = getX(b, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              } else {\n                float dyValue = getDy(b, d2, yR, yC);\n                float xValue = getX(b, d1, xR, xC);\n                dotProd += (xValue * dyValue);\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Tr=function e(n){Object(p.a)(this,e),this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterHeight,a=n.filterWidth,r=n.strideHeight,o=n.strideWidth,i="channelsLast"===n.dataFormat,c=t-1-n.padInfo.top,s=a-1-n.padInfo.left,u=i?1:2,l=i?2:3,d=i?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(d,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(u,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(a,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(a," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(n.outChannels,"; d2++) {\n\n              if (").concat(i,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Rr=function e(n){Object(p.a)(this,e),this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideDepth,a=n.strideHeight,r=n.strideWidth,o=n.padInfo.front,i=n.padInfo.top,c=n.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(n.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(n.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(o,";\n\n            if (xF < 0 || xF >= ").concat(n.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(n.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(a," - ").concat(i,";\n\n              if (xR < 0 || xR >= ").concat(n.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(n.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(r," - ").concat(c,";\n\n                if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},wr=function e(n){Object(p.a)(this,e),this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterDepth,a=n.filterHeight,r=n.filterWidth,o=n.strideDepth,i=n.strideHeight,c=n.strideWidth,s=t-1-n.padInfo.front,u=a-1-n.padInfo.top,l=r-1-n.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(s,", ").concat(u,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(o,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(n.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(a,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(i,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(a," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(r,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(c,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(r," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(n.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")};var Sr={kernelName:i.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,c=a.strides,s=a.pad,u=a.dataFormat,l=a.dimRoundingMode,d=a.filterShape,p=i.backend_util.convertConv2DDataFormat(u),h=i.backend_util.computeConv2DInfo(r.shape,d,c,1,s,l,!1,p),f=new Nr(h);return t.runWebGLProgram(f,[r,o],"float32")}};var Or={kernelName:i.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,c=a.inputShape,s=a.strides,u=a.pad,l=a.dataFormat,d=a.dimRoundingMode,p=i.backend_util.convertConv2DDataFormat(l),h=i.backend_util.computeConv2DInfo(c,o.shape,s,1,u,d,!1,p),f=new Tr(h);return t.runWebGLProgram(f,[r,o],"float32")}};var Fr={kernelName:i.Conv3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,c=a.strides,s=a.pad,u=a.dilations,l=i.backend_util.computeConv3DInfo(r.shape,o.shape,c,u,s),d=new xr(l);return t.runWebGLProgram(d,[r,o],"float32")}};var Ar={kernelName:i.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,c=a.strides,s=a.pad,u=a.filterShape,l=i.backend_util.computeConv3DInfo(r.shape,u,c,1,s),d=new Rr(l);return t.runWebGLProgram(d,[r,o],"float32")}};var Er={kernelName:i.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,c=a.pad,s=a.strides,u=a.inputShape,l=i.backend_util.computeConv3DInfo(u,o.shape,s,1,c),d=new wr(l);return t.runWebGLProgram(d,[r,o],"float32")}},_r=Ot({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n"}),Dr={kernelName:i.Cos,backendName:"webgl",kernelFunc:_r},Pr=Ot({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Mr={kernelName:i.Cosh,backendName:"webgl",kernelFunc:Pr},Lr=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var i=Object(c.a)(n,4),s=i[0],u=i[1],l=i[2],d=i[3],h=Object(c.a)(t,1)[0],f=Object(c.a)(a,2),v=f[0],m=f[1];this.outputShape=[h,v,m,d];var g="bilinear"===r?1:0,b="".concat(u-1,".0"),x="".concat(l-1,".0"),k=v>1?["".concat((u-1)/(v-1)),"(y2-y1) * height_ratio","y1*".concat(b," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(b)],I=Object(c.a)(k,3),y=I[0],C=I[1],N=I[2],T=m>1?["".concat((l-1)/(m-1)),"(x2-x1) * width_ratio","x1*".concat(x," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(x)],R=Object(c.a)(T,3),w=R[0],S=R[1],O=R[2];this.userCode="\n      const float height_ratio = float(".concat(y,");\n      const float width_ratio = float(").concat(w,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(C,";\n        float width_scale = ").concat(S,";\n\n        float in_y = ").concat(N,";\n        if( in_y < 0.0 || in_y > ").concat(b," ) {\n          setOutput(float(").concat(o,"));\n          return;\n        }\n        float in_x = ").concat(O,";\n        if( in_x < 0.0 || in_x > ").concat(x," ) {\n          setOutput(float(").concat(o,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(g," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")},Br={kernelName:i.CropAndResize,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.image,o=n.boxes,i=n.boxInd,c=a.cropSize,s=a.method,u=a.extrapolationValue,l=new Lr(r.shape,o.shape,c,s,u);return t.runWebGLProgram(l,[r,o,i],"float32")}},Wr=function(){function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=n;var r=n.length,o=t?"0.0":"getX(".concat(jr(r,"coords"),")"),i=n[n.length-1],c="",s="";t?(c=a?"end != ".concat(i-1):"end != 0",s=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",s=a?"end + pow2":"end - pow2"),this.userCode="\n      uniform float index;\n      void main() {\n        ".concat(Ae(r)," coords = getOutputCoords();\n        int end = ").concat(Vr(r,"coords"),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(s,";\n          ").concat(Vr(r,"coords")," = idx;\n          val += getX(").concat(jr(r,"coords"),");\n        }\n        setOutput(val);\n      }\n    ")}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e){var n=this;return function(t,a){null==n.index&&(n.index=t.getUniformLocation(a,"index")),t.gl.uniform1f(n.index,e)}}}]),e}();function jr(e,n){if(1===e)return"".concat(n);if(2===e)return"".concat(n,".x, ").concat(n,".y");if(3===e)return"".concat(n,".x, ").concat(n,".y, ").concat(n,".z");if(4===e)return"".concat(n,".x, ").concat(n,".y, ").concat(n,".z, ").concat(n,".w");throw Error("Cumulative sum for rank ".concat(e," is not yet supported"))}function Vr(e,n){if(1===e)return"".concat(n);if(2===e)return"".concat(n,".y");if(3===e)return"".concat(n,".z");if(4===e)return"".concat(n,".w");throw Error("Cumulative sum for rank ".concat(e," is not yet supported"))}var zr={kernelName:i.Cumsum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,c=a.exclusive,s=a.reverse,u=r.shape.length,l=i.backend_util.getAxesPermutation([o],u),d=r;null!=l&&(d=Yt({inputs:{x:r},backend:t,attrs:{perm:l}}));var p=i.backend_util.getInnerMostAxes(1,u)[0];if(p!==u-1)throw new Error("WebGL cumsum shader expects an inner-most axis=".concat(r.shape.length-1," ")+"but got axis=".concat(o));for(var h=r.shape[p],f=xt({inputs:{x:d},backend:t}),v=0;v<=Math.ceil(Math.log2(h))-1;v++){var m=new Wr(d.shape,!1,s),g=m.getCustomSetupFunc(v),b=f;f=t.runWebGLProgram(m,[f],f.dtype,g),t.disposeIntermediateTensorInfo(b)}if(c){var x=new Wr(d.shape,c,s),k=f;f=t.runWebGLProgram(x,[f],f.dtype),t.disposeIntermediateTensorInfo(k)}if(null!=l){var I=Yt({inputs:{x:f},backend:t,attrs:{perm:i.backend_util.getUndoAxesPermutation(l)}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),I}return f}};var Gr={kernelName:i.DenseBincount,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.weights,i=a.size,c=a.binaryOutput;if(1===r.shape.length){var s=t.readSync(r.dataId),u=t.readSync(o.dataId),l=bn(s,u,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,l)}if(2===r.shape.length){var d=t.bufferSync(r),p=t.bufferSync(o),h=xn(d,p,i,c);return t.makeTensorInfo(h.shape,o.dtype,h.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}},Ur=function(){function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=[],this.outputShape=n,this.blockSize=t,this.dataFormat=a,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}return Object(h.a)(e,[{key:"getHeightCoordString",value:function(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}},{key:"getWidthCoordString",value:function(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}},{key:"getDepthCoordString",value:function(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}},{key:"getOutputDepthSize",value:function(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}},{key:"getInputSamplingString",value:function(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}]),e}();var Hr={kernelName:i.DepthToSpace,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockSize,c=a.dataFormat;i.util.assert(o>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: ".concat(o)}));var s=r.shape[0],u="NHWC"===c?r.shape[1]:r.shape[2],l="NHWC"===c?r.shape[2]:r.shape[3],d="NHWC"===c?r.shape[3]:r.shape[1],p=u*o,h=l*o,f=d/(o*o),v=new Ur("NHWC"===c?[s,p,h,f]:[s,f,p,h],o,c);return t.runWebGLProgram(v,[r],r.dtype)}},Xr=function e(n){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];Object(p.a)(this,e),this.variableNames=["x","W"],this.outputShape=n.outShape;var i=n.inHeight,c=n.inWidth,s=n.padInfo.top,u=n.padInfo.left,l=n.strideHeight,d=n.strideWidth,h=n.dilationHeight,f=n.dilationWidth,v=n.filterHeight,m=n.filterWidth,g=n.outChannels/n.inChannels,b="",x="";a&&(b=r?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(a,"\n        }"):o?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(a,"\n        }"):"\n          float activation(float x) {\n            ".concat(a,"\n          }\n        "),x="result = activation(result);");var k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(b,"\n\n      const ivec2 strides = ivec2(").concat(l,", ").concat(d,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(u,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(g,";\n        int q = d2 - d1 * ").concat(g,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(v,"; wR++) {\n          int xR = xRCorner + wR * ").concat(h,";\n\n          if (xR < 0 || xR >= ").concat(i,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(m,"; wC++) {\n            int xC = xCCorner + wC * ").concat(f,";\n\n            if (xC < 0 || xC >= ").concat(c,") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(k,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")},qr=function e(n){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];Object(p.a)(this,e),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.outShape;for(var c=n.inHeight,s=n.inWidth,u=n.padInfo.top,l=n.padInfo.left,d=n.strideHeight,h=n.strideWidth,f=n.dilationHeight,v=n.dilationWidth,m=n.filterHeight,g=n.filterWidth,b=g,x="int xR; int xC; int xCOffset;",k=0;k<m;k++)for(var I=0;I<g;I++)x+="\n          vec4 xTexelR".concat(k,"C").concat(2*I," = vec4(0.);\n          vec4 wR").concat(k,"C").concat(I," = vec4(0.);\n          vec4 xR").concat(k,"C").concat(I," = vec4(0.);");for(var y=0;y<m;y++)for(var C=0;C<b;C++){var N=2*C;if(x+="\n          xR = xRCorner + ".concat(y*f,";\n          xC = xCCorner + ").concat(N*v,";\n        "),1===h){if(N<g&&(x+=l%2===1?"\n                xCOffset = xC + 1;\n                if(xR >= 0 && xR < ".concat(c," && xCOffset >= 0 && xCOffset < ").concat(s,") {\n                  xTexelR").concat(y,"C").concat(N," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ").concat(s,") {\n                    xTexelR").concat(y,"C").concat(N,".zw = vec2(0.);\n                  }\n                } else {\n                  xTexelR").concat(y,"C").concat(N," = vec4(0.);\n                }\n\n                xCOffset = xC + 1 - 2;\n                if(xR >= 0 && xR < ").concat(c," && xCOffset >= 0 && xCOffset < ").concat(s,") {\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if(xCOffset + 1 >= ").concat(s,") {\n                    previous.zw = vec2(0.);\n                  }\n\n                  xR").concat(y,"C").concat(N," = vec4(previous.zw, xTexelR").concat(y,"C").concat(N,".xy);\n                } else {\n                  xR").concat(y,"C").concat(N," = vec4(0, 0, xTexelR").concat(y,"C").concat(N,".xy);\n                }\n              "):"\n                if(xR >= 0 && xR < ".concat(c," && xC >= 0 && xC < ").concat(s,") {\n                  xTexelR").concat(y,"C").concat(N," = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR").concat(y,"C").concat(N," = vec4(0.);\n                }\n\n                xR").concat(y,"C").concat(N," = xTexelR").concat(y,"C").concat(N,";\n              "),N+1<g)){var T=l%2===0?i.util.nearestLargerEven(v):v;v%2===0&&l%2===1||v%2!==0&&l%2!==1?(x+="\n                  xCOffset = xC + ".concat(l%2," + ").concat(T,";\n\n                  if(xR >= 0 && xR < ").concat(c," &&\n                    xCOffset >= 0 && xCOffset < ").concat(s,") {\n                    xTexelR").concat(y,"C").concat(N+2," = getX(batch, xR, xCOffset, d1);\n                  }\n                "),v>1&&(x+="\n                    xCOffset -= 2;\n                    if(xR >= 0 && xR < ".concat(c," &&\n                      xCOffset >= 0 && xCOffset < ").concat(s,") {\n                      xTexelR").concat(y,"C").concat(N," = getX(batch, xR, xCOffset, d1);\n                    } else {\n                      xTexelR").concat(y,"C").concat(N," = vec4(0.);\n                    }\n                  ")),x+="\n                  xR".concat(y,"C").concat(N+1," = vec4(\n                    xTexelR").concat(y,"C").concat(N,".zw, xTexelR").concat(y,"C").concat(N+2,".xy);\n                ")):x+="\n                  xCOffset = xC + ".concat(T,";\n\n                  if(xR >= 0 && xR < ").concat(c," &&\n                    xCOffset >= 0 && xCOffset < ").concat(s,") {\n                    xTexelR").concat(y,"C").concat(N+2," = getX(batch, xR, xCOffset, d1);\n                  }\n\n                  xR").concat(y,"C").concat(N+1," = xTexelR").concat(y,"C").concat(N+2,";\n                ")}}else N<g&&(x+="\n              if(xR >= 0 && xR < ".concat(c,") {\n            "),l%2===1?(x+="\n                xCOffset = xC + 1 - ".concat(h,";\n                if(xCOffset >= 0 && xCOffset < ").concat(s,") {\n                  xTexelR").concat(y,"C").concat(N," = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR").concat(y,"C").concat(N," = vec4(0.);\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < ").concat(s,") {\n                  xTexelR").concat(y,"C").concat(N+2," = getX(batch, xR, xC + 1, d1);\n                } else {\n                  xTexelR").concat(y,"C").concat(N+2," = vec4(0.);\n                }\n\n                xR").concat(y,"C").concat(N," = vec4(\n                  xTexelR").concat(y,"C").concat(N,".zw, xTexelR").concat(y,"C").concat(N+2,".zw);\n              "),N+1<g&&(x+="\n                  vec4 final = vec4(0.);\n                  xCOffset = xC + 1 + ".concat(h,";\n                  if(xCOffset >= 0 && xCOffset < ").concat(s,") {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xR").concat(y,"C").concat(N+1," = vec4(xTexelR").concat(y,"C").concat(N+2,".xy, final.xy);\n                "))):(x+="\n                if(xC >= 0 && xC < ".concat(s,") {\n                  xTexelR").concat(y,"C").concat(N," = getX(batch, xR, xC, d1);\n                } else {\n                  xTexelR").concat(y,"C").concat(N," = vec4(0.);\n                }\n\n                xCOffset = xC + ").concat(h,";\n                if(xCOffset >= 0 && xCOffset < ").concat(s,") {\n                  xTexelR").concat(y,"C").concat(N+2," = getX(batch, xR, xCOffset, d1);\n                } else {\n                  xTexelR").concat(y,"C").concat(N+2," = vec4(0.);\n                }\n\n                xR").concat(y,"C").concat(N," = vec4(\n                  xTexelR").concat(y,"C").concat(N,".xy, xTexelR").concat(y,"C").concat(N+2,".xy);\n              "),N+1<g&&(x+="\n                  xR".concat(y,"C").concat(N+1," = vec4(\n                    xTexelR").concat(y,"C").concat(N,".zw, xTexelR").concat(y,"C").concat(N+2,".zw);\n                "))),x+="}");N<g&&(x+="\n            vec4 wTexelR".concat(y,"C").concat(N," = getW(").concat(y,", ").concat(N,", d1, q);\n            wR").concat(y,"C").concat(N," = vec4(wTexelR").concat(y,"C").concat(N,".xz, wTexelR").concat(y,"C").concat(N,".xz);\n          "),N+1<g&&(x+="\n              vec4 wTexelR".concat(y,"C").concat(N+1," = getW(").concat(y,", ").concat(N+1,", d1, q);\n              wR").concat(y,"C").concat(N+1," =\n                vec4(wTexelR").concat(y,"C").concat(N+1,".xz, wTexelR").concat(y,"C").concat(N+1,".xz);")))}for(var R=0;R<m;R++)for(var w=0;w<g;w++)x+="dotProd += xR".concat(R,"C").concat(w," * wR").concat(R,"C").concat(w,";");var S="",O="";a&&(S=r?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(a,"\n        }"):o?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(a,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(a,"\n        }"),O="result = activation(result);");var F=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(S,"\n\n      const ivec2 strides = ivec2(").concat(d,", ").concat(h,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(l,");\n\n      void main() {\n\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2;\n        int q = 0;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 dotProd = vec4(0.);\n\n        ").concat(x,"\n\n        vec4 result = dotProd;\n        ").concat(F,"\n        ").concat(O,"\n        setOutput(result);\n      }\n    ")};var Kr={kernelName:i.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,c=a.strides,s=a.pad,u=a.dilations,l=a.dimRoundingMode,d=u;null==d&&(d=[1,1]),i.util.assert(i.backend_util.eitherStridesOrDilationsAreOne(c,d),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(d,"'")}));var p,h=i.backend_util.computeConv2DInfo(r.shape,o.shape,c,d,s,l,!0);return p=Object(i.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new qr(h):new Xr(h),t.runWebGLProgram(p,[r,o],"float32")}},Yr=function e(n){Object(p.a)(this,e),this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideHeight,a=n.strideWidth,r=n.padInfo.top,o=n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(i," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(n.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(n.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(r,";\n\n            if (xR < 0 || xR >= ").concat(n.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(n.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(a," - ").concat(o,";\n\n              if (xC < 0 || xC >= ").concat(n.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Qr=function e(n){Object(p.a)(this,e),this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterHeight,a=n.filterWidth,r=n.strideHeight,o=n.strideWidth,i=t-1-n.padInfo.top,c=a-1-n.padInfo.left,s=n.outChannels/n.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(i,", ").concat(c,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(r,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(a,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(a," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(s,"; dm++) {\n              int d2 = d1 * ").concat(s," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")};var Zr={kernelName:i.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.dy,c=a.strides,s=a.dilations,u=a.pad,l=a.dimRoundingMode,d=a.filterShape,p=i.backend_util.computeConv2DInfo(r.shape,d,c,s,u,l,!0),h=new Yr(p);return t.runWebGLProgram(h,[r,o],"float32")}};var Jr={kernelName:i.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.filter,c=a.strides,s=a.dilations,u=a.pad,l=a.dimRoundingMode,d=a.inputShape,p=i.backend_util.computeConv2DInfo(d,o.shape,c,s,u,l,!0),h=new Qr(p);return t.runWebGLProgram(h,[r,o],"float32")}},$r=function e(n){Object(p.a)(this,e),this.variableNames=["X"],this.outputShape=[n,n],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "};var eo={kernelName:i.Diag,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=[].concat(Object(l.a)(a.shape),Object(l.a)(a.shape)),o=i.util.sizeFromShape(a.shape),c=Wt({inputs:{x:a},backend:t,attrs:{shape:[o]}}),s=new $r(o),u=t.runWebGLProgram(s,[c],c.dtype),d=Wt({inputs:{x:u},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),d}},no=function e(n){Object(p.a)(this,e),this.variableNames=["x","W"],this.outputShape=n.outShape;var t=n.inHeight,a=n.inWidth,r=n.padInfo,o=n.strideHeight,i=n.strideWidth,c=n.filterHeight,s=n.filterWidth,u=n.dilationHeight,l=n.dilationWidth,d=r.top,h=r.left;this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(c,"; h++) {\n          int hIn = hBeg + h * ").concat(u,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(s,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(a,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")};var to={kernelName:i.Dilation2D,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,c=t.filter,s=r.strides,u=r.pad,l=r.dilations,d=i.backend_util.computeDilation2DInfo(o.shape,c.shape,s,u,"NHWC",l),p=new no(d),h=Wt({inputs:{x:n=a.runWebGLProgram(p,[o,c],"float32")},backend:a,attrs:{shape:d.outShape}});return a.disposeIntermediateTensorInfo(n),h}},ao=Ot({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),ro={kernelName:i.Elu,backendName:"webgl",kernelFunc:ao},oo={kernelName:i.EluGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.dy,r=n.y,o=Object(i.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new bt("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new gt("return (b >= 1.0) ? a : a * (b + 1.0);",a.shape,r.shape);return t.runWebGLProgram(o,[a,r],a.dtype)}},io=Ft({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool"}),co={kernelName:i.Equal,backendName:"webgl",kernelFunc:io},so=Ot({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(i.backend_util.ERF_P,";\n  float a1 = ").concat(i.backend_util.ERF_A1,";\n  float a2 = ").concat(i.backend_util.ERF_A2,";\n  float a3 = ").concat(i.backend_util.ERF_A3,";\n  float a4 = ").concat(i.backend_util.ERF_A4,";\n  float a5 = ").concat(i.backend_util.ERF_A5,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),uo={kernelName:i.Erf,backendName:"webgl",kernelFunc:so},lo="return exp(x);",po=Ot({opSnippet:lo,packedOpSnippet:lo,cpuKernelImpl:yn}),ho={kernelName:i.Exp,backendName:"webgl",kernelFunc:po};function fo(e){var n=e.inputs,t=e.attrs,a=e.backend,r=t.dim,o=n.input,c=o.shape.length,s=o.shape.slice(),u=r;return r<0&&(i.util.assert(-(c+1)<=r,(function(){return"Axis must be in the interval [".concat(-(c+1),", ").concat(c,"]")})),u=c+r+1),s.splice(u,0,1),Wt({inputs:{x:o},backend:a,attrs:{shape:s}})}var vo={kernelName:i.ExpandDims,backendName:"webgl",kernelFunc:fo},mo="return exp(x) - 1.0;",go=Ot({opSnippet:mo,packedOpSnippet:mo,cpuKernelImpl:Cn}),bo={kernelName:i.Expm1,backendName:"webgl",kernelFunc:go},xo=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["real","imag"];var r=t[1];this.outputShape=t;var o,i=a?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),c=a?"".concat(r,".0"):"1.0";if("real"===n)o="return real * expR - imag * expI;";else{if("imag"!==n)throw new Error('FFT component must be either "real" or "imag", got '.concat(n,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(i,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(r,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(r,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(c,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")};function ko(e,n,t){var a=t.texData.get(e.dataId),r=i.util.sizeFromShape(e.shape),o=e.shape[e.shape.length-1],c=Wt({inputs:{x:e},backend:t,attrs:{shape:[r/o,o]}}),s=c.shape,u=new xo("real",s,n),l=new xo("imag",s,n),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s}],p=t.runWebGLProgram(u,d,"float32"),h=t.runWebGLProgram(l,d,"float32"),f=It({inputs:{real:p,imag:h},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h);var v=Wt({inputs:{x:f},backend:t,attrs:{shape:e.shape}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(f),v}var Io={kernelName:i.FFT,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend;return ko(n.input,!1,t)}},yo=function(){function e(n,t){Object(p.a)(this,e),this.outputShape=[],this.variableNames=["x"],this.outputShape=n,this.userCode="\n      uniform float value;\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e){var n=this;return function(t,a){null==n.valueLoc&&(n.valueLoc=t.getUniformLocationNoThrow(a,"value")),t.gl.uniform1f(n.valueLoc,e)}}}]),e}();function Co(e){var n=e.backend,t=e.attrs,a=t.shape,r=t.value,o=t.dtype;if("string"===(o=o||i.util.inferDtype(r))){var c=i.util.getArrayFromDType(o,i.util.sizeFromShape(a));return c.fill(r),n.makeTensorInfo(a,o,c)}var s=new yo(a,r),u=s.getCustomSetupFunc(r);return n.runWebGLProgram(s,[],o,u)}var No,To={kernelName:i.Fill,backendName:"webgl",kernelFunc:Co},Ro=function e(n){Object(p.a)(this,e),this.variableNames=["Image"],this.outputShape=[];var t=n[2];this.outputShape=n,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")},wo={kernelName:i.FlipLeftRight,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.image,r=t,o=new Ro(a.shape);return r.runWebGLProgram(o,[a],a.dtype)}},So="return floor(x);",Oo=Ot({opSnippet:So,packedOpSnippet:So,cpuKernelImpl:Nn}),Fo={kernelName:i.Floor,backendName:"webgl",kernelFunc:Oo},Ao=Ft({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),Eo={kernelName:i.FloorDiv,backendName:"webgl",kernelFunc:Ao},_o=function e(n){Object(p.a)(this,e),this.variableNames=["A"];var t=J(),a=Object(c.a)(n,2),r=a[0],o=a[1];this.outputShape=n,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(o,".0, ").concat(r,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")},Do=function e(n){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var t=J(),a=Object(c.a)(n,2),r=a[0],o=a[1];this.outputShape=n,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(o,".0, ").concat(r,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")},Po={kernelName:i.FromPixels,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,o=n.pixels,s=a.numChannels,u="undefined"!==typeof HTMLVideoElement&&o instanceof HTMLVideoElement,l="undefined"!==typeof HTMLImageElement&&o instanceof HTMLImageElement,d="undefined"!==typeof ImageBitmap&&o instanceof ImageBitmap,p=u?[o.videoWidth,o.videoHeight]:[o.width,o.height],h=Object(c.a)(p,2),f=h[0],v=h[1],m=[v,f],g=[v,f,s];(l||u||d)&&(null==No&&(No=document.createElement("canvas").getContext("2d")),No.canvas.width=f,No.canvas.height=v,No.drawImage(o,0,0,f,v),o=No.canvas);var b=t.makeTensorInfo(m,"int32");t.texData.get(b.dataId).usage=r.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(b.dataId),o);var x=Object(i.env)().getBool("WEBGL_PACK")?new Do(g):new _o(g),k=t.runWebGLProgram(x,[b],"int32");return t.disposeData(b.dataId),k}};var Mo={kernelName:i.FusedConv2D,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,c=t.filter,s=t.bias,u=t.preluActivationWeights,l=r.strides,d=r.pad,p=r.dataFormat,h=r.dilations,f=r.dimRoundingMode,v=r.activation,m=r.leakyreluAlpha,g=i.backend_util.convertConv2DDataFormat(p),b=i.backend_util.computeConv2DInfo(o.shape,c.shape,l,h,d,f,!1,g),x=[];if(1!==b.filterHeight||1!==b.filterWidth||1!==b.dilationHeight||1!==b.dilationWidth||1!==b.strideHeight||1!==b.strideWidth||"SAME"!==b.padInfo.type&&"VALID"!==b.padInfo.type)if(Object(i.env)().getBool("WEBGL_CONV_IM2COL")&&1===o.shape[0])n=yr({x:o,filter:c,convInfo:b,backend:a,bias:s,activation:v,preluActivationWeights:u,leakyreluAlpha:m});else{var k=null!=s,I=null!=u,y="leakyrelu"===v,C=v?At(v,!1):null,N=new br(b,k,C,I,y),T=[o,c];if(s&&T.push(s),u&&T.push(u),y){var R=a.makeTensorInfo([],"float32",i.util.createScalarValue(m,"float32"));T.push(R),x.push(R)}n=a.runWebGLProgram(N,T,"float32")}else n=Ir({x:o,filter:c,convInfo:b,backend:a,bias:s,activation:v,preluActivationWeights:u,leakyreluAlpha:m});var w=Wt({inputs:{x:n},backend:a,attrs:{shape:b.outShape}});return x.push(n),x.forEach((function(e){return a.disposeIntermediateTensorInfo(e)})),w}};var Lo={kernelName:i.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,c=n.bias,s=n.preluActivationWeights,u=a.strides,l=a.pad,d=a.dilations,p=a.dimRoundingMode,h=a.activation,f=a.leakyreluAlpha,v=[],m=d;null==m&&(m=[1,1]),i.util.assert(i.backend_util.eitherStridesOrDilationsAreOne(u,m),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(u," and dilations '").concat(m,"'")}));var g,b=i.backend_util.computeConv2DInfo(r.shape,o.shape,u,m,l,p,!0),x=Object(i.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,k=h?At(h,x):null,I=[r,o],y=null!=c,C=null!=s,N="leakyrelu"===h;if(y&&I.push(c),C&&I.push(s),N){var T=t.makeTensorInfo([],"float32",i.util.createScalarValue(f,"float32"));I.push(T),v.push(T)}g=x?new qr(b,y,k,C,N):new Xr(b,y,k,C,N);var R=t.runWebGLProgram(g,I,"float32");return v.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),R}},Bo=function e(n,t,a){Object(p.a)(this,e),this.sliceDim=n,this.strides=t,this.variableNames=["x","indices"],this.outputShape=a;var r=Ae(t.length),o=Ae(a.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode="\n        ".concat(r," strides = ").concat(r,"(").concat(this.strides,");\n         void main() {\n          ").concat(o," coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < ").concat(this.sliceDim,"; j++) {\n            int index = round(getIndices(coords[0], j));\n            flattenIndex += index * ").concat(i,";\n          }\n          setOutput(getX(flattenIndex, coords[1]));\n        }\n      ")};var Wo={kernelName:i.GatherNd,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.params,r=n.indices,o=r.shape,s=o[o.length-1],u=i.backend_util.prepareAndValidate(a,r),l=Object(c.a)(u,4),d=l[0],p=l[1],h=l[2],f=l[3],v=Wt({inputs:{x:r},backend:t,attrs:{shape:[p,s]}}),m=Wt({inputs:{x:a},backend:t,attrs:{shape:[i.util.sizeFromShape(a.shape)/h,h]}}),g=new Bo(s,f,[p,h]),b=t.runWebGLProgram(g,[m,v],m.dtype),x=Wt({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(b),x}},jo=function e(n,t){Object(p.a)(this,e),this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;var a=Ae(this.rank),r=function(e,n){for(var t=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],r=0;r<e.length;r++)2===r?a.push("int(getIndices(resRC.x, resRC.z))"):a.push("".concat(t[r]));return a.join()}(n);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")};var Vo={kernelName:i.GatherV2,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.indices,c=a.axis,s=a.batchDims,u=i.util.parseAxisParam(c,r.shape)[0],l=i.backend_util.segment_util.collectGatherOpShapeInfo(r,o,u,s),d=i.util.sizeFromShape(o.shape),p=[],h=Wt({inputs:{x:r},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=Wt({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,d/l.batchSize]}});p.push(h),p.push(f);var v=[l.batchSize,l.outerSize,d/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([r,o])||"string"===r.dtype){var m=t.bufferSync(f),g=t.bufferSync(h),b=Tn(g,m,v);return p.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.makeTensorInfo(l.outputShape,b.dtype,b.values)}var x=new jo(h.shape,v),k=t.runWebGLProgram(x,[h,f],h.dtype);p.push(k);var I=Wt({inputs:{x:k},backend:t,attrs:{shape:l.outputShape}});return p.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),I}},zo=Ft({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Rn,dtype:"bool"}),Go={kernelName:i.Greater,backendName:"webgl",kernelFunc:zo},Uo=Ft({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool"}),Ho={kernelName:i.GreaterEqual,backendName:"webgl",kernelFunc:Uo};var Xo={kernelName:i.IFFT,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend;return ko(n.input,!0,t)}},qo=Ot({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),Ko={kernelName:i.IsFinite,backendName:"webgl",kernelFunc:qo},Yo=Ot({opSnippet:"return float(isinf(x));",dtype:"bool"}),Qo={kernelName:i.IsInf,backendName:"webgl",kernelFunc:Yo},Zo=Ot({opSnippet:"return float(isnan(x));",dtype:"bool"}),Jo={kernelName:i.IsNan,backendName:"webgl",kernelFunc:Zo},$o=Ft({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:wn,dtype:"bool"}),ei={kernelName:i.Less,backendName:"webgl",kernelFunc:$o},ni=Ft({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",dtype:"bool"}),ti={kernelName:i.LessEqual,backendName:"webgl",kernelFunc:ni};var ai={kernelName:i.LinSpace,backendName:"webgl",kernelFunc:function(e){var n=e.backend,t=e.attrs,a=t.start,r=t.stop,o=t.num,i=Sn(a,r,o);return n.makeTensorInfo([i.length],"float32",i)}},ri=Ot({opSnippet:"if (x < 0.0) return NAN;\n  return log(x);",packedOpSnippet:"\n  vec4 result = log(x);\n  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));\n  result.r = isNaN.r == 1.0 ? NAN : result.r;\n  result.g = isNaN.g == 1.0 ? NAN : result.g;\n  result.b = isNaN.b == 1.0 ? NAN : result.b;\n  result.a = isNaN.a == 1.0 ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:On}),oi={kernelName:i.Log,backendName:"webgl",kernelFunc:ri},ii=Ot({opSnippet:"return log(1.0 + x);"}),ci={kernelName:i.Log1p,backendName:"webgl",kernelFunc:ii},si=Ft({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),ui={kernelName:i.LogicalAnd,backendName:"webgl",kernelFunc:si},li=Ot({opSnippet:"return float(!(x >= 1.0));"}),di={kernelName:i.LogicalNot,backendName:"webgl",kernelFunc:li},pi=Ft({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),hi={kernelName:i.LogicalOr,backendName:"webgl",kernelFunc:pi},fi=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=[];var i,c=t,s=n[3]-1;this.outputShape=n;var u="float(".concat(a,") + float(").concat(r,") * sum");i=.5===o?"inversesqrt(".concat(u,")"):1===o?"1.0/(".concat(u,")"):"exp(log(".concat(u,") * float(-").concat(o,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(c,"; j <= ").concat(c,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(s,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")},vi=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var i,c=t,s=n[3]-1;this.outputShape=n;var u="float(".concat(a,") + float(").concat(r,") * sum");i=.5===o?"inversesqrt(".concat(u,")"):1===o?"1.0/(".concat(u,")"):"exp(log(".concat(u,") * float(-").concat(o,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(c,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(c,"; j <= ").concat(c,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(s,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")},mi={kernelName:i.LRN,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.depthRadius,c=a.bias,s=a.alpha,u=a.beta,l=Object(i.env)().getBool("WEBGL_PACK_NORMALIZATION")?new vi(r.shape,o,c,s,u):new fi(r.shape,o,c,s,u);return t.runWebGLProgram(l,[r],r.dtype)}},gi=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=t,this.bias=a,this.alpha=r,this.beta=o,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(r,") * norm + float(").concat(a,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(r,")\n                * float(").concat(o,")\n                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(o,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")},bi={kernelName:i.LRNGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.y,i=n.dy,c=a.depthRadius,s=a.bias,u=a.alpha,l=a.beta,d=new gi(r.shape,c,s,u,l);return t.runWebGLProgram(d,[r,o,i],r.dtype)}};function xi(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.reductionIndices,s=a.keepDims,u=r.shape.length,l=i.util.parseAxisParam(o,r.shape),d=l,p=i.backend_util.getAxesPermutation(d,u),h=null!=p,f=t.shouldExecuteOnCPU([r]),v=r;if(h){if(f){for(var m=t.texData.get(v.dataId).values,g=new Array(u),b=0;b<g.length;b++)g[b]=r.shape[p[b]];var x=Un(m,r.shape,r.dtype,p,g);v=t.makeTensorInfo(g,r.dtype),t.texData.get(v.dataId).values=x}else v=Xt(r,p,t);d=i.backend_util.getInnerMostAxes(d.length,u)}i.backend_util.assertAxesAreInnerMostDims("max",d,u);var k,I=i.backend_util.computeOutAndReduceShapes(v.shape,d),y=Object(c.a)(I,2),C=y[0],N=y[1],T=C;if(s&&(T=i.backend_util.expandShapeToKeepDim(C,l)),f){var R=t.texData.get(v.dataId).values,w=Fn(R,i.util.sizeFromShape(N),T,r.dtype);k=t.makeTensorInfo(T,r.dtype),t.texData.get(k.dataId).values=w}else k=function(e,n,t,a){var r=i.util.sizeFromShape(n),o=Wt({inputs:{x:e},attrs:{shape:[i.util.sizeFromShape(e.shape)/r,r]},backend:a}),c=Gt(o,e.dtype,"max",a),s=Wt({inputs:{x:c},attrs:{shape:t},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(c),s}(v,N,T,t);return h&&t.disposeIntermediateTensorInfo(v),k}var ki={kernelName:i.Max,backendName:"webgl",kernelFunc:xi},Ii=Ft({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:An}),yi={kernelName:i.Maximum,backendName:"webgl",kernelFunc:Ii};var Ci={kernelName:i.MaxPool,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x;Q(r,"maxPool");var o=a.filterSize,c=a.strides,s=a.pad,u=a.dimRoundingMode;i.util.assert(i.backend_util.eitherStridesOrDilationsAreOne(c,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(c," and dilations '").concat(1,"'")}));var l=i.backend_util.computePool2DInfo(r.shape,o,c,1,s,u);if(1===l.filterWidth&&1===l.filterHeight&&i.util.arraysEqual(l.inShape,l.outShape))return xt({inputs:{x:r},backend:t});var d=new Fa(l,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}};var Ni={kernelName:i.MaxPool3D,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.filterSize,c=a.strides,s=a.pad,u=a.dataFormat,l=a.dimRoundingMode,d=i.backend_util.computePool3DInfo(r.shape,o,c,[1,1,1],s,l,u),p=new Aa(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}},Ti=function e(n){Object(p.a)(this,e),this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;var t=n.strideHeight,a=n.strideWidth,r=n.dilationHeight,o=n.effectiveFilterHeight,i=n.effectiveFilterWidth,c=o-1-n.padInfo.top,s=i-1-n.padInfo.left,u=o*i-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(c,", ").concat(s,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(o,";\n          wR += ").concat(r,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(i,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(u," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(i," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")},Ri=function e(n){Object(p.a)(this,e),this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;var t=n.strideDepth,a=n.strideHeight,r=n.strideWidth,o=n.dilationDepth,i=n.dilationHeight,c=n.dilationWidth,s=n.effectiveFilterDepth,u=n.effectiveFilterHeight,l=n.effectiveFilterWidth,d=s-1-n.padInfo.front,h=u-1-n.padInfo.top,f=l-1-n.padInfo.left,v=s*u*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(d,", ").concat(h,", ").concat(f,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(s,";\n           wD += ").concat(o,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(n.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(i,") {\n            float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(n.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(c,") {\n              float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(n.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(v," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(u," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")};var wi={kernelName:i.MaxPool3DGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,c=a.filterSize,s=a.strides,u=a.pad,l=a.dimRoundingMode,d=i.backend_util.computePool3DInfo(o.shape,c,s,[1,1,1],u,l),p=new Aa(d,"max",!0),h=t.runWebGLProgram(p,[o],o.dtype),f=new Ri(d),v=t.runWebGLProgram(f,[r,h],o.dtype);return t.disposeIntermediateTensorInfo(h),v}};var Si={kernelName:i.MaxPoolGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.dy,o=n.input,c=o;Q([o,n.output],"maxPoolGrad");var s=a.filterSize,u=a.strides,l=a.pad,d=a.dimRoundingMode,p=i.backend_util.computePool2DInfo(c.shape,s,u,1,l,d),h=new Fa(p,"max",!0),f=t.runWebGLProgram(h,[c],c.dtype),v=new Ti(p),m=t.runWebGLProgram(v,[r,f],c.dtype);return t.disposeIntermediateTensorInfo(f),m}};var Oi={kernelName:i.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.x,o=t.filterSize,s=t.strides,u=t.pad,l=t.includeBatchInIndex,d=a;i.util.assert(4===r.shape.length,(function(){return"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")}));var p=[1,1];i.util.assert(i.backend_util.eitherStridesOrDilationsAreOne(s,p),(function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(p,"'")}));var h=i.backend_util.computePool2DInfo(r.shape,o,s,p,u),f=function(e,n,t,a){var r=new Fa(t,"max",!1),o=a.runWebGLProgram(r,[e],"float32");return r=new Fa(t,"max",!0,!0,n),[o,a.runWebGLProgram(r,[e],"float32")]}(r,l,h,d),v=Object(c.a)(f,2);return[v[0],v[1]]}};var Fi={kernelName:i.Mean,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.x,o=t.keepDims,s=t.axis,u=a,l=r.shape.length,d=i.util.parseAxisParam(s,r.shape),p=d,h=i.backend_util.getAxesPermutation(p,l),f=null!=h,v=u.shouldExecuteOnCPU([r]),m=[],g=r;if(f){if(v){for(var b=u.texData.get(g.dataId).values,x=new Array(l),k=0;k<x.length;k++)x[k]=r.shape[h[k]];var I=Un(b,r.shape,r.dtype,h,x);g=u.makeTensorInfo(x,r.dtype),u.texData.get(g.dataId).values=I}else g=Xt(r,h,u);m.push(g),p=i.backend_util.getInnerMostAxes(p.length,l)}i.backend_util.assertAxesAreInnerMostDims("sum",p,l);var y=i.backend_util.computeOutAndReduceShapes(g.shape,p),C=Object(c.a)(y,2),N=C[0],T=C[1],R=N;o&&(R=i.backend_util.expandShapeToKeepDim(N,d));for(var w=function(e,n,t,a){var r=i.util.sizeFromShape(n),o=Wt({inputs:{x:e},attrs:{shape:[i.util.sizeFromShape(e.shape)/r,r]},backend:a}),c=Gt(o,"float32","mean",a),s=Wt({inputs:{x:c},attrs:{shape:t},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(c),s}(g,T,R,u),S=0,O=m;S<O.length;S++){var F=O[S];u.disposeIntermediateTensorInfo(F)}return w}};var Ai={kernelName:i.Min,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.axis,s=a.keepDims,u=r.shape.length,l=i.util.parseAxisParam(o,r.shape),d=l,p=i.backend_util.getAxesPermutation(d,u),h=r;null!=p&&(h=Yt({inputs:{x:r},backend:t,attrs:{perm:p}}),d=i.backend_util.getInnerMostAxes(d.length,r.shape.length)),i.backend_util.assertAxesAreInnerMostDims("min",d,u);var f,v=i.backend_util.computeOutAndReduceShapes(h.shape,d),m=Object(c.a)(v,2),g=m[0],b=m[1],x=Wt({inputs:{x:h},backend:t,attrs:{shape:[-1,i.util.sizeFromShape(b)]}}),k=Gt(x,x.dtype,"min",t);return f=Wt(s?{inputs:{x:k},backend:t,attrs:{shape:i.backend_util.expandShapeToKeepDim(g,l)}}:{inputs:{x:k},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(k),null!=p&&t.disposeIntermediateTensorInfo(h),f}},Ei=Ft({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:En}),_i={kernelName:i.Minimum,backendName:"webgl",kernelFunc:Ei},Di=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=t.map((function(e,t){return e[0]+n[t]+e[1]}));var r=n.length,o=Ae(r),i=t.map((function(e){return e[0]})).join(","),c=t.map((function(e,t){return e[0]+n[t]})).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===a?0:1;this.userCode=1!==r?"\n      ".concat(o," start = ").concat(o,"(").concat(i,");\n      ").concat(o," end = ").concat(o,"(").concat(c,");\n\n      void main() {\n        ").concat(o," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(r,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(u,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(u,";\n          }\n        }\n        ").concat(o," coords = outC - start;\n        setOutput(getX(").concat(s,"));\n      }\n    "):"\n        int start = ".concat(i,";\n        int end = ").concat(c,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(u,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(u,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")},Pi=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((function(e,t){return e[0]+n[t]+e[1]}));var r=n.length,o=Ae(r),i=t.map((function(e){return e[0]})).join(","),c=t.map((function(e,t){return e[0]+n[t]})).join(","),s=qn("rc",r),u=qn("source",r),l="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),d=1===r?"source":"vec2(".concat(u.slice(-2).join(),")"),h="reflect"===a?0:1,f="";if(1===r){var v="\n        ".concat(o," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");f="\n        ".concat(o," rc = outputLoc;\n        ").concat(v,"\n        result[0] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(l,") {\n          ").concat(v,"\n          result[1] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n        }\n      ")}else{var m="\n        ".concat(o," source = rc;\n        ").concat(o," lt = ").concat(o,"(lessThan(source, start));\n        ").concat(o," gte = ").concat(o,"(greaterThanEqual(source, end));\n        ").concat(o," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");f="\n        ".concat(o," rc = outputLoc;\n        ").concat(m,"\n        result[0] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n        ").concat(s[r-1]," += 1;\n        if(").concat(l,") {\n          ").concat(m,"\n          result[1] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n        }\n        rc = outputLoc;\n        ").concat(s[r-2]," += 1;\n        if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {\n          ").concat(m,"\n          result[2] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n          ").concat(s[r-1]," += 1;\n          if(").concat(l,") {\n            ").concat(m,"\n            result[3] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(o," start = ").concat(o,"(").concat(i,");\n      const ").concat(o," end = ").concat(o,"(").concat(c,");\n\n      void main() {\n        ").concat(o," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")},Mi={kernelName:i.MirrorPad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.paddings,c=a.mode,s=Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Pi(r.shape,o,c):new Di(r.shape,o,c);return t.runWebGLProgram(s,[r],r.dtype)}},Li=Ft({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  vec4 isNaN = vec4(equal(b, vec4(0.0)));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),Bi={kernelName:i.Mod,backendName:"webgl",kernelFunc:Li},Wi=function(){function e(n,t,a){Object(p.a)(this,e),this.variableNames=["probs"],this.outputShape=[n,a],this.userCode="\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}return Object(h.a)(e,[{key:"getCustomSetupFunc",value:function(e){var n=this;return function(t,a){null==n.seedLoc&&(n.seedLoc=t.getUniformLocation(a,"seed")),t.gl.uniform1f(n.seedLoc,e)}}}]),e}(),ji=Ft({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),Vi={kernelName:i.RealDiv,backendName:"webgl",kernelFunc:ji},zi="return a - b;",Gi=Ft({opSnippet:zi,packedOpSnippet:zi,supportsComplex:!0,cpuKernelImpl:Vn}),Ui={kernelName:i.Sub,backendName:"webgl",kernelFunc:Gi};function Hi(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.logits,o=a.dim,c=i.util.parseAxisParam([o],r.shape),s=xi({inputs:{x:r},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),u=i.backend_util.expandShapeToKeepDim(s.shape,c),l=Wt({inputs:{x:s},backend:t,attrs:{shape:u}}),d=Gi({inputs:{a:r,b:l},backend:t}),p=po({inputs:{x:d},backend:t}),h=qt({inputs:{x:p},backend:t,attrs:{axis:c,keepDims:!1}}),f=Wt({inputs:{x:h},backend:t,attrs:{shape:u}}),v=ji({inputs:{a:p,b:f},backend:t});return t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),v}var Xi={kernelName:i.Softmax,backendName:"webgl",kernelFunc:Hi};var qi={kernelName:i.Multinomial,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.logits,o=a.numSamples,i=a.seed,c=a.normalized,s=c?r:Hi({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),u=s.shape[0],l=s.shape[1],d=new Wi(u,l,o),p=d.getCustomSetupFunc(i),h=t.runWebGLProgram(d,[s],"int32",p);return c||t.disposeIntermediateTensorInfo(s),h}},Ki="return -x;";var Yi={kernelName:i.Neg,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=t.x;if(a.shouldExecuteOnCPU([r])){var o=a.texData.get(r.dataId),s=Dn(o.values,r.shape,r.dtype),u=Object(c.a)(s,2),l=u[0],d=u[1];return a.makeTensorInfo(d,r.dtype,l)}return n=Object(i.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new pt(r.shape,Ki):new et(r.shape,Ki),a.runWebGLProgram(n,[r],r.dtype)}},Qi=i.kernel_impls.nonMaxSuppressionV3Impl;var Zi={kernelName:i.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,c=a.maxOutputSize,s=a.iouThreshold,u=a.scoreThreshold,l=t.readSync(r.dataId),d=t.readSync(o.dataId),p=Qi(l,d,c,s,u).selectedIndices;return t.makeTensorInfo([p.length],"int32",new Int32Array(p))}},Ji=i.kernel_impls.nonMaxSuppressionV4Impl;var $i={kernelName:i.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,c=a.maxOutputSize,s=a.iouThreshold,u=a.scoreThreshold,l=a.padToMaxOutputSize,d=t.readSync(r.dataId),p=t.readSync(o.dataId),h=Ji(d,p,c,s,u,l),f=h.selectedIndices,v=h.validOutputs;return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([],"int32",new Int32Array([v]))]}},ec=i.kernel_impls.nonMaxSuppressionV5Impl;var nc={kernelName:i.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function(e){i.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,c=a.maxOutputSize,s=a.iouThreshold,u=a.scoreThreshold,l=a.softNmsSigma,d=t.readSync(r.dataId),p=t.readSync(o.dataId),h=ec(d,p,c,s,u,l),f=h.selectedIndices,v=h.selectedScores;return[t.makeTensorInfo([f.length],"int32",new Int32Array(f)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}},tc=function e(n,t,a,r){Object(p.a)(this,e),this.variableNames=["indices"],this.outputShape=[n,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(r,"), float(").concat(a,"),\n                      float(index == coords.y)));\n      }\n    ")},ac={kernelName:i.OneHot,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.indices,o=a.depth,c=a.onValue,s=a.offValue,u=i.util.sizeFromShape(r.shape),d=new tc(u,o,c,s),p=Wt({inputs:{x:r},backend:t,attrs:{shape:[u]}}),h=t.runWebGLProgram(d,[p],r.dtype);t.disposeIntermediateTensorInfo(p);var f=Wt({inputs:{x:h},backend:t,attrs:{shape:[].concat(Object(l.a)(r.shape),[o])}});return t.disposeIntermediateTensorInfo(h),f}};function rc(e){var n=e.inputs,t=e.backend,a=n.x;if("complex64"===a.dtype){var r=Za({inputs:{input:a},backend:t}),o=rc({inputs:{x:r},backend:t}),i=pr({inputs:{input:a},backend:t}),c=rc({inputs:{x:i},backend:t}),s=It({inputs:{real:o,imag:c},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),s}return Co({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:t})}var oc={kernelName:i.ZerosLike,backendName:"webgl",kernelFunc:rc};var ic={kernelName:i.OnesLike,backendName:"webgl",kernelFunc:function e(n){var t=n.inputs,a=n.backend,r=t.x;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){var o=Za({inputs:{input:r},backend:a}),i=e({inputs:{x:o},backend:a}),c=pr({inputs:{input:r},backend:a}),s=rc({inputs:{x:c},backend:a}),u=It({inputs:{real:i,imag:s},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(s),u}return Co({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};var cc={kernelName:i.Pack,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs.axis;if(1===n.length)return fo({inputs:{input:n[0]},backend:t,attrs:{dim:a}});var r=n[0].shape,o=n[0].dtype;n.forEach((function(e){i.util.assertShapesMatch(r,e.shape,"All tensors passed to stack must have matching shapes"),i.util.assert(o===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var c=[],s=mr({inputs:n.map((function(e){var n=fo({inputs:{input:e},backend:t,attrs:{dim:a}});return c.push(n),n})),backend:t,attrs:{axis:a}});return c.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),s}},sc=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=t.map((function(e,t){return e[0]+n[t]+e[1]}));var r=n.length,o=Ae(r),i=t.map((function(e){return e[0]})).join(","),c=t.map((function(e,t){return e[0]+n[t]})).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?"\n      ".concat(o," start = ").concat(o,"(").concat(i,");\n      ").concat(o," end = ").concat(o,"(").concat(c,");\n\n      void main() {\n        ").concat(o," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(").concat(a,"));\n        } else {\n          ").concat(o," coords = outC - start;\n          setOutput(getX(").concat(s,"));\n        }\n      }\n    "):"\n        int start = ".concat(i,";\n        int end = ").concat(c,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(").concat(a,"));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")},uc=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((function(e,t){return e[0]+n[t]+e[1]}));for(var r=n.length,o=Ae(r),i=t.map((function(e){return e[0]})).join(","),c=t.map((function(e,t){return e[0]+n[t]})).join(","),s=qn("rc",r),u=qn("source",r),l="".concat(s[r-1]," < ").concat(this.outputShape[r-1]),d=1===r?"source":"vec2(".concat(u.slice(-2).join(),")"),h=["".concat(o," rc = outputLoc;"),"".concat(s[r-1]," += 1;\n       if(").concat(l,") {\n      "),1===r?"":"}\n       rc = outputLoc;\n       ".concat(s[r-2]," += 1;\n       if(").concat(s[r-2]," < ").concat(this.outputShape[r-2],") {"),1===r?"":"  ".concat(s[r-1]," += 1;\n         if(").concat(l,") {")],f=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",v="",m=0,g=1===r?2:4;m<g;m++)v+="\n        ".concat(h[m],"\n        if (").concat(f,") {\n          result[").concat(m,"] = float(").concat(a,");\n        } else {\n          ").concat(o," source = rc - start;\n          result[").concat(m,"] = getChannel(getX(").concat(u.join(),"), ").concat(d,");\n        }\n      ");v+=1===r?"} ":"}}",this.userCode="\n      const ".concat(o," start = ").concat(o,"(").concat(i,");\n      const ").concat(o," end = ").concat(o,"(").concat(c,");\n\n      void main() {\n        ").concat(o," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(v,"\n        setOutput(result);\n      }\n    ")},lc=function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.paddings,c=a.constantValue,s=Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uc(r.shape,o,c):new sc(r.shape,o,c);return t.runWebGLProgram(s,[r],r.dtype)},dc={kernelName:i.PadV2,backendName:"webgl",kernelFunc:lc},pc=Ft({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  \n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n\n  return result;\n"}),hc={kernelName:i.Pow,backendName:"webgl",kernelFunc:pc};var fc={kernelName:i.Prod,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,s=r.axis,u=r.keepDims,l=o.shape.length,d=[],p=i.util.parseAxisParam(s,o.shape),h=p,f=i.backend_util.getAxesPermutation(h,l),v=o;if(null!=f&&(v=Yt({inputs:{x:o},backend:a,attrs:{perm:f}}),h=i.backend_util.getInnerMostAxes(h.length,l),d.push(v)),i.backend_util.assertAxesAreInnerMostDims("prod",h,l),a.shouldExecuteOnCPU([v])){var m=a.texData.get(v.dataId).values,g=Pn(v.shape,v.dtype,m,h),b=g.outVals,x=g.outShape,k=g.outDtype;n=a.makeTensorInfo(x,k,b)}else{var I=i.backend_util.computeOutAndReduceShapes(v.shape,h),y=Object(c.a)(I,2),C=y[0],N=y[1],T=i.util.sizeFromShape(N),R=Wt({inputs:{x:v},backend:a,attrs:{shape:[-1,T]}}),w=Gt(R,Object(i.sumOutType)(o.dtype),"prod",a);n=Wt({inputs:{x:w},backend:a,attrs:{shape:C}}),d.push(R),d.push(w)}if(u){d.push(n);var S=i.backend_util.expandShapeToKeepDim(n.shape,p);n=Wt({inputs:{x:n},backend:a,attrs:{shape:S}})}return d.forEach((function(e){return a.disposeIntermediateTensorInfo(e)})),n}},vc=function(e){var n=e.backend,t=e.attrs,a=t.start,r=t.stop,o=t.step,i=t.dtype,c=Mn(a,r,o,i);return n.makeTensorInfo([c.length],i,c)},mc={kernelName:i.Range,backendName:"webgl",kernelFunc:vc},gc=Ot({opSnippet:"return 1.0 / x;"}),bc={kernelName:i.Reciprocal,backendName:"webgl",kernelFunc:gc},xc=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),kc={kernelName:i.Relu,backendName:"webgl",kernelFunc:xc},Ic=Ot({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),yc={kernelName:i.Relu6,backendName:"webgl",kernelFunc:Ic},Cc=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["A"],this.outputShape=[];var i=Object(c.a)(n,4),s=i[0],u=i[1],l=i[2],d=i[3];this.outputShape=[s,t,a,d];var h,f=[r&&t>1?u-1:u,r&&a>1?l-1:l],v=[r&&t>1?t-1:t,r&&a>1?a-1:a];h=o?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f[0]/v[0],",\n          ").concat(f[1]/v[1],");\n      const vec2 inputShapeRC = vec2(").concat(u,".0, ").concat(l,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")},Nc=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var i=Object(c.a)(n,4),s=i[0],u=i[1],l=i[2],d=i[3];this.outputShape=[s,t,a,d];var h,f=[r&&t>1?u-1:u,r&&a>1?l-1:l],v=[r&&t>1?t-1:t,r&&a>1?a-1:a];h=o?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(f[0]/v[0],",\n          ").concat(f[1]/v[1],",\n          ").concat(f[1]/v[1],");\n      const vec3 inputShapeRC = vec3(").concat(u,".0, ").concat(l,".0,\n                                     ").concat(l,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(d-1,";\n        bool hasNextRow = coords.z < ").concat(a-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")};var Tc={kernelName:i.ResizeBilinear,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=a.alignCorners,s=a.halfPixelCenters,u=a.size,l=Object(c.a)(u,2),d=l[0],p=l[1],h=Object(i.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Nc(r.shape,d,p,o,s):new Cc(r.shape,d,p,o,s);return t.runWebGLProgram(h,[r],"float32")}},Rc=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;var r=Object(c.a)(t,3),o=r[1],i=r[2],s=Object(c.a)(n,3),u=s[1],l=s[2],d=[a&&u>1?o-1:o,a&&l>1?i-1:i],h=[a&&u>1?u-1:u,a&&l>1?l-1:l],f=d[0]/h[0],v=d[1]/h[1],m=1/f,g=1/v,b=2*Math.ceil(m)+2,x=2*Math.ceil(g)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f,");\n        const float widthScale = float(").concat(v,");\n\n        const float invHeightScale = float(").concat(m,");\n        const float invWidthScale = float(").concat(g,");\n\n        const int winHeight = int(").concat(b,");\n        const int winWidth = int(").concat(x,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(l,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(o-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(i-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")};var wc={kernelName:i.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=n.dy,i=a.alignCorners,c=new Rc(o.shape,r.shape,i);return t.runWebGLProgram(c,[o],o.dtype)}},Sc=function e(n,t,a,r,o){Object(p.a)(this,e),this.variableNames=["A"],this.outputShape=[];var i=Object(c.a)(n,4),s=i[0],u=i[1],l=i[2],d=i[3];this.outputShape=[s,t,a,d];var h,f=[r&&t>1?u-1:u,r&&a>1?l-1:l],v=[r&&t>1?t-1:t,r&&a>1?a-1:a],m=r?"0.5":"0.0";h=o?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(f[0]/v[0],",\n          ").concat(f[1]/v[1],");\n      const vec2 inputShapeRC = vec2(").concat(u,".0, ").concat(l,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(m,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")};var Oc={kernelName:i.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=a.alignCorners,i=a.halfPixelCenters,s=a.size,u=Object(c.a)(s,2),l=u[0],d=u[1],p=new Sc(r.shape,l,d,o,i);return t.runWebGLProgram(p,[r],r.dtype)}},Fc=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;var r=Object(c.a)(t,3),o=r[1],i=r[2],s=Object(c.a)(n,3),u=s[1],l=s[2],d=[a&&u>1?o-1:o,a&&l>1?i-1:i],h=[a&&u>1?u-1:u,a&&l>1?l-1:l],f=d[0]/h[0],v=d[1]/h[1],m=1/f,g=1/v,b=2*Math.ceil(m)+2,x=2*Math.ceil(g)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(f,");\n        const float widthScale = float(").concat(v,");\n\n        const float invHeightScale = float(").concat(m,");\n        const float invWidthScale = float(").concat(g,");\n\n        const int winHeight = int(").concat(b,");\n        const int winWidth = int(").concat(x,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(u,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(l,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(d[0],") *\n                (float(dyR) / float(").concat(h[0],"));\n\n            float sourceFracCol =\n                float(").concat(d[1],") *\n                  (float(dyC) / float(").concat(h[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(o,") - 1),\n                ").concat(a," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(i,") - 1),\n                ").concat(a," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")};var Ac={kernelName:i.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.images,o=n.dy,i=a.alignCorners,c=new Fc(o.shape,r.shape,i);return t.runWebGLProgram(c,[o],o.dtype)}},Ec=function e(n,t){Object(p.a)(this,e),this.variableNames=["x"];var a=n.length;if(a>4)throw new Error("WebGL backend: Reverse of rank-".concat(a," tensor is not yet supported"));if(this.outputShape=n,1!==a){var r=n.map((function(e,a){return function(e){return-1!==t.indexOf(e)&&1!==n[e]?"".concat(n[e]," - coords[").concat(e,"] - 1"):"coords[".concat(e,"]")}(a)})).join(","),o=Ae(a);this.userCode="\n      void main() {\n        ".concat(o," coords = getOutputCoords();\n        setOutput(getX(").concat(r,"));\n      }\n    ")}else this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(n[0]," - coord - 1));\n        }\n      ")},_c=function e(n,t){Object(p.a)(this,e),this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var a=n.length;if(a>4)throw new Error("WebGL backend: Reverse of rank-".concat(a," tensor is not yet supported"));this.outputShape=n;var r=qn("rc",a),o="".concat(r[a-1]," + 1 < ").concat(this.outputShape[a-1]),i="".concat(r[a-2]," + 1 < ").concat(this.outputShape[a-2]),c=Ae(a);function s(e){var a=n.map((function(a,r){return function(e,a){return-1!==t.indexOf(e)&&1!==n[e]?"".concat(n[e]," - ").concat(a[e]," - 1"):"".concat(a[e])}(r,e)})),r=a.join(","),o=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(o,"))")}this.userCode=1===a?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(n[0]," - rc - 1),\n            ").concat(n[0]," - rc - 1);\n          if(").concat(o,"){\n              result.g = getChannel(getX(").concat(n[0]," - (rc  + 1) - 1),\n                ").concat(n[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(c," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return s(e)}(r.slice()),";\n          if(").concat(o,"){\n            result.g = ").concat(function(e){return e[a-1]="("+e[a-1]+" + 1)",s(e)}(r.slice()),";\n          }\n          if(").concat(i,") {\n            result.b = ").concat(function(e){return e[a-2]="("+e[a-2]+" + 1)",s(e)}(r.slice()),";\n            if(").concat(o,") {\n              result.a = ").concat(function(e){return e[a-1]="("+e[a-1]+" + 1)",e[a-2]="("+e[a-2]+" + 1)",s(e)}(r.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")};var Dc={kernelName:i.Reverse,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.dims,c=r.shape.length,s=i.util.parseAxisParam(o,r.shape);if(0===c)return xt({inputs:{x:r},backend:t});var u=Object(i.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _c(r.shape,s):new Ec(r.shape,s);return t.runWebGLProgram(u,[r],r.dtype)}},Pc=function e(n,t,a,r){Object(p.a)(this,e),this.variableNames=["Image"],this.outputShape=[];var o=n[1],s=n[2],u=Math.sin(t).toFixed(3),l=Math.cos(t).toFixed(3);this.outputShape=n;var d=i.backend_util.getImageCenter(r,o,s),h=Object(c.a)(d,2),f=h[0],v=h[1],m=f.toFixed(3),g=v.toFixed(3),b="";b="number"===typeof a?"float outputValue = ".concat(a.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(a.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - ".concat(m,") * ").concat(l," - (float(y) - ").concat(g,") * ").concat(u,";\n          float coordYFloat = (float(x) - ").concat(m,") * ").concat(u," + (float(y) - ").concat(g,") * ").concat(l,";\n          int coordX = int(round(coordXFloat + ").concat(m,"));\n          int coordY = int(round(coordYFloat + ").concat(g,"));\n          ").concat(b,"\n          if(coordX >= 0 && coordX < ").concat(s," && coordY >= 0 && coordY < ").concat(o,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")},Mc={kernelName:i.RotateWithOffset,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.image,o=t.radians,i=t.fillValue,c=t.center,s=a,u=new Pc(r.shape,o,i,c);return s.runWebGLProgram(u,[r],r.dtype)}},Lc=Ot({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),Bc={kernelName:i.Round,backendName:"webgl",kernelFunc:Lc},Wc=Ot({opSnippet:"return inversesqrt(x);",cpuKernelImpl:Ln}),jc={kernelName:i.Rsqrt,backendName:"webgl",kernelFunc:Wc},Vc=function e(n,t,a,r,o,i){Object(p.a)(this,e),this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;var c=Ae(o.length),s=Ae(i.length),u="";1===a?u="i":2===a&&(u="i, j");var l="getIndices(".concat(u,")"),d="";1===r?d="i":2===r&&(d="i, coords[1]");var h="getUpdates(".concat(d,")"),f=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(c," strides = ").concat(c,"(").concat(o,");\n\n        void main() {\n          ").concat(s," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(n,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(l,");\n              flattenedIndex += index * ").concat(f,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(h,";\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(), sum, float(found)));\n        }\n      ")};var zc={kernelName:i.ScatterNd,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.indices,o=n.updates,c=a.shape,s=i.backend_util.calculateShapes(o,r,c),u=s.sliceRank,l=s.numUpdates,d=s.sliceSize,p=s.strides,h=s.outputSize,f=[h/d,d];if(0===h)return t.makeTensorInfo(c,r.dtype);var v=Wt({inputs:{x:r},backend:t,attrs:{shape:[l,u]}}),m=Wt({inputs:{x:o},backend:t,attrs:{shape:[l,d]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0])),b=new Vc(l,u,v.shape.length,m.shape.length,p,f),x=t.runWebGLProgram(b,[m,v,g],m.dtype),k=Wt({inputs:{x:x},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(g),k}},Gc=function e(n,t,a){var r,o;if(Object(p.a)(this,e),this.variableNames=["c","a","b"],this.outputShape=t,a>4)throw Error("Where for rank ".concat(a," is not yet supported"));if(1===a)o="resRC",r="resRC";else{for(var i=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],s=[],u=0;u<t.length;u++)s.push("".concat(i[u])),u<n&&c.push("".concat(i[u]));r=c.join(),o=s.join()}var l=Ae(a);this.userCode="\n      void main() {\n        ".concat(l," resRC = getOutputCoords();\n        float cVal = getC(").concat(r,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(o,"));\n        } else {\n          setOutput(getB(").concat(o,"));\n        }\n      }\n    ")};var Uc={kernelName:i.Select,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.condition,r=n.t,o=n.e,c=new Gc(a.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(c,[a,r,o],Object(i.upcastType)(r.dtype,o.dtype))}},Hc=Ot({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(i.backend_util.SELU_SCALEALPHA,";\n  float scale = ").concat(i.backend_util.SELU_SCALE,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),Xc={kernelName:i.Selu,backendName:"webgl",kernelFunc:Hc},qc=Ot({opSnippet:"return 1.0 / (1.0 + exp(-1.0 * x));"}),Kc={kernelName:i.Sigmoid,backendName:"webgl",kernelFunc:qc},Yc=Ot({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Qc={kernelName:i.Sign,backendName:"webgl",kernelFunc:Yc},Zc=Ot({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n"}),Jc={kernelName:i.Sin,backendName:"webgl",kernelFunc:Zc},$c=Ot({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),es={kernelName:i.Sinh,backendName:"webgl",kernelFunc:$c},ns=Ot({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),ts={kernelName:i.Softplus,backendName:"webgl",kernelFunc:ns},as={kernelName:i.SpaceToBatchND,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.blockShape,c=a.paddings;i.util.assert(r.shape.length<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}));var s=o.reduce((function(e,n){return e*n})),u=[[0,0]];u.push.apply(u,Object(l.a)(c));for(var d=1+o.length;d<r.shape.length;++d)u.push([0,0]);var p=[],h=lc({inputs:{x:r},backend:t,attrs:{paddings:u,constantValue:0}}),f=i.backend_util.getReshaped(h.shape,o,s,!1),v=i.backend_util.getPermuted(f.length,o.length,!1),m=i.backend_util.getReshapedPermuted(h.shape,o,s,!1),g=Wt({inputs:{x:h},backend:t,attrs:{shape:f}}),b=Yt({inputs:{x:g},backend:t,attrs:{perm:v}}),x=Wt({inputs:{x:b},backend:t,attrs:{shape:m}});return p.push(h),p.push(g),p.push(b),p.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),x}};var rs={kernelName:i.SparseToDense,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.sparseIndices,o=n.sparseValues,c=n.defaultValue,s=a.outputShape,u=i.backend_util.calculateShapes(o,r,s),l=u.sliceRank,d=u.numUpdates,p=u.strides,h=u.outputSize,f=new Vc(d,l,r.shape.length,o.shape.length,p,[h,1],!1),v=t.runWebGLProgram(f,[o,r,c],o.dtype),m=Wt({inputs:{x:v},backend:t,attrs:{shape:s}});return t.disposeIntermediateTensorInfo(v),m}};var os={kernelName:i.SplitV,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.numOrSizeSplits,c=a.axis,s=i.util.parseAxisParam(c,r.shape)[0],u=i.backend_util.prepareSplitSize(r,o,s),d=r.shape.length,p=new Array(d).fill(0),h=r.shape.slice();return u.map((function(e){var n=Object(l.a)(h);n[s]=e;var a=Ha({inputs:{x:r},backend:t,attrs:{begin:p,size:n}});return p[s]+=e,a}))}},is=Ot({opSnippet:"return sqrt(x);"}),cs={kernelName:i.Sqrt,backendName:"webgl",kernelFunc:is},ss=Ot({opSnippet:"return x * x;"}),us={kernelName:i.Square,backendName:"webgl",kernelFunc:ss},ls="return (a - b) * (a - b);",ds=Ft({opSnippet:ls,packedOpSnippet:ls}),ps={kernelName:i.SquaredDifference,backendName:"webgl",kernelFunc:ds};var hs={kernelName:i.Step,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.x,o=nt+"\n    return x > 0.0 ? 1.0 : float(".concat(t.alpha,");\n  "),i=new et(r.shape,o);return a.runWebGLProgram(i,[r],r.dtype)}},fs=function e(n,t,a){Object(p.a)(this,e),this.variableNames=["x"],this.outputShape=a;var r=a.length,o=Ae(a.length),i=Ae(a.length),c="";if(1===r)c="coords * strides + begin";else{var s=0;c=a.map((function(e,n){return s++,1===a.length?"coords * strides[".concat(n,"] + begin[").concat(n,"]"):"coords[".concat(s-1,"] * strides[").concat(n,"] + begin[").concat(n,"]")})).join(",")}this.userCode="\n      ".concat(o," begin = ").concat(o,"(").concat(n,");\n      ").concat(o," strides = ").concat(o,"(").concat(t,");\n\n      void main() {\n        ").concat(i," coords = getOutputCoords();\n        setOutput(getX(").concat(c,"));\n      }\n    ")};var vs={kernelName:i.StridedSlice,backendName:"webgl",kernelFunc:function(e){var n,t=e.inputs,a=e.backend,r=e.attrs,o=t.x,c=r.begin,s=r.end,u=r.strides,l=r.beginMask,d=r.endMask,p=r.ellipsisMask,h=r.newAxisMask,f=r.shrinkAxisMask,v=i.slice_util.sliceInfo(o.shape,c,s,u,l,d,p,h,f),m=v.nonStrided,g=v.$begin,b=v.$strides,x=v.size,k=v.newShape,I=v.outShape,y=Wt({inputs:{x:o},backend:a,attrs:{shape:k}});if(m){var C=Ha({inputs:{x:y},backend:a,attrs:{begin:g,size:x}});n=Wt({inputs:{x:C},backend:a,attrs:{shape:I}}),a.disposeIntermediateTensorInfo(C)}else if(I.some((function(e){return 0===e})))n=a.makeTensorInfo(I,o.dtype,[]);else{if(a.shouldExecuteOnCPU([y])){var N=a.texData.get(y.dataId).values,T=Object(i.buffer)(y.shape,y.dtype,N),R=jn(I,T,b,g);n=a.makeTensorInfo(I,y.dtype,R.values)}else{var w=new fs(g,b,I);n=a.runWebGLProgram(w,[y],y.dtype)}}var S=Wt({inputs:{x:n},backend:a,attrs:{shape:I}});return a.disposeIntermediateTensorInfo(y),a.disposeIntermediateTensorInfo(n),S}},ms=Ot({opSnippet:"return tan(x);"}),gs={kernelName:i.Tan,backendName:"webgl",kernelFunc:ms},bs=Ot({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),xs={kernelName:i.Tanh,backendName:"webgl",kernelFunc:bs},ks=function e(n,t){Object(p.a)(this,e),this.variableNames=["A"];for(var a=new Array(n.length),r=0;r<a.length;r++)a[r]=n[r]*t[r];this.outputShape=a,this.rank=a.length;var o=Ae(this.rank),i=function(e){var n=e.length;if(n>5)throw Error("Tile for rank ".concat(n," is not yet supported"));if(1===n)return"imod(resRC, ".concat(e[0],")");for(var t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[],r=0;r<e.length;r++)a.push("imod(".concat(t[r],", ").concat(e[r],")"));return a.join()}(n);this.userCode="\n      void main() {\n        ".concat(o," resRC = getOutputCoords();\n        setOutput(getA(").concat(i,"));\n      }\n    ")};function Is(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.reps;if("string"===r.dtype){var c=t.readSync(r.dataId).map((function(e){return i.util.decodeString(e)})),s=Object(i.buffer)(r.shape,r.dtype,c),u=zn(s,o);return t.makeTensorInfo(u.shape,u.dtype,u.values)}var l=new ks(r.shape,o);return t.runWebGLProgram(l,[r],r.dtype)}var ys={kernelName:i.Tile,backendName:"webgl",kernelFunc:Is};var Cs={kernelName:i.TopK,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=a.k,i=a.sorted,s=t.readSync(r.dataId),u=Gn(s,r.shape,r.dtype,o,i),l=Object(c.a)(u,2),d=l[0],p=l[1];return[t.makeTensorInfo(d.shape,d.dtype,d.values),t.makeTensorInfo(p.shape,p.dtype,p.values)]}};var Ns={kernelName:i.Unique,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.attrs,a=e.backend,r=t.axis,o=n.x;Q(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");var i=a.readSync(o.dataId),c=Hn(i,r,o.shape,o.dtype),s=c.outputValues,u=c.outputShape,l=c.indices;return[a.makeTensorInfo(u,o.dtype,s),a.makeTensorInfo([l.length],"int32",l)]}};var Ts={kernelName:i.Unpack,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.value,o=a.axis;o<0&&(o+=r.shape.length);for(var i=r,c=i.shape.length,s=r.shape[o],u=new Array(c-1),l=0,d=0;d<c;d++)d!==o&&(u[l++]=i.shape[d]);var p=[],h=new Array(c).fill(0),f=i.shape.slice();f[o]=1;for(var v=new Array(s),m=0;m<v.length;m++){h[o]=m;var g=Ha({inputs:{x:i},backend:t,attrs:{begin:h,size:f}}),b=Wt({inputs:{x:g},backend:t,attrs:{shape:u}});v[m]=b,p.push(g)}return p.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),v}},Rs=function e(n,t){Object(p.a)(this,e),this.variableNames=["x","segmentIds"];var a=n.windowSize,r=n.batchSize,o=n.inSize,i=n.numSegments,c=i*Math.ceil(o/a);this.outputShape=[r,c];var s=4*Math.floor(a/4),u=a%4,l="\n        sumValue += dot(values, segFilter);\n    ",d="";o%a>0&&(d="\n        if (inIdx < 0 || inIdx >= ".concat(o,") {\n          return initializationValue;\n        }\n      "));var h="";o%a>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(o,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(d,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(i,")) * float(").concat(a,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(i,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(s,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(s,";\n        if (").concat(1===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===u,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")};for(var ws=0,Ss=[mi,bi,Jt,ea,ta,ra,ca,la,da,pa,ba,xa,Ia,Ca,wa,Ta,Oa,_a,Ea,Ma,La,Ba,Va,qa,Ka,$a,tr,or,sr,yt,gr,Sr,Or,Cr,Ar,Er,Fr,Dr,Mr,Br,zr,Gr,Hr,Zr,Jr,Kr,eo,to,ro,oo,co,uo,ho,vo,bo,Io,To,wo,Fo,Eo,Po,Mo,Lo,Wo,Vo,Go,Ho,kt,Xo,hr,Ko,Qo,Jo,Tt,ei,ti,ai,ci,oi,ui,di,hi,ki,Ni,Ci,wi,Si,Oi,yi,Fi,Ai,_i,Mi,Bi,qi,Bt,Yi,Zi,$i,nc,Qa,ac,ic,cc,dc,hc,St,fc,mc,Ja,Vi,bc,yc,kc,jt,Tc,wc,Oc,Ac,Dc,Mc,Bc,jc,zc,Uc,Xc,Kc,Qc,Jc,es,Xa,Xi,ts,as,rs,os,cs,us,ps,hs,vs,Ui,Kt,gs,xs,ys,Cs,Qt,Ns,Ts,{kernelName:i.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.segmentIds,c=a.numSegments,s=r.shape.length,u=[],l=0,d=i.backend_util.getAxesPermutation([l],s),p=r;null!=d&&(p=Yt({inputs:{x:r},backend:t,attrs:{perm:d}}),u.push(p),l=i.backend_util.getInnerMostAxes(1,s)[0]);var h=i.backend_util.segment_util.computeOutShape(p.shape,l,c),f=i.util.sizeFromShape([p.shape[l]]),v=Wt({inputs:{x:p},backend:t,attrs:{shape:[-1,f]}});u.push(v);var m=Wt({inputs:{x:function e(n,a,r,o,c){var s=n.shape[0],l=n.shape[1],d=i.backend_util.segment_util.segOpComputeOptimalWindowSize(l,c),p=new Rs({windowSize:d,inSize:l,batchSize:s,numSegments:c},a),h=t.compileAndRun(p,[n,r],o);if(u.push(h),h.shape[1]===c)return h;var f=vc({backend:t,attrs:{start:0,stop:c,step:1,dtype:"float32"}}),v=Is({inputs:{x:f},backend:t,attrs:{reps:[l/d]}});return u.push(f),u.push(v),e(h,a,v,o,c)}(v,"unsortedSegmentSum",o,Object(i.sumOutType)(r.dtype),c)},backend:t,attrs:{shape:h}}),g=m;if(null!=d){u.push(m);var b=i.backend_util.getUndoAxesPermutation(d);g=Yt({inputs:{x:g},backend:t,attrs:{perm:b}})}return u.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),g}},oc];ws<Ss.length;ws++){var Os=Ss[ws];Object(i.registerKernel)(Os)}},521:function(e,n,t){"use strict";var a=t(169),r=t(22),o=t.n(r),i=t(36),c=t(66),s=t(67),u=t(70),l=t(193),d=t(59),p=t(68),h=t(69);function f(e,n){Array.isArray(e)||(e=[e]),e.forEach((function(e){null!=e&&a.util.assert("complex64"!==e.dtype,(function(){return"".concat(n," does not support complex64 tensors in the CPU backend.")}))}))}var v=a.kernel_impls.whereImpl,m=function(e){Object(p.a)(t,e);var n=Object(h.a)(t);function t(){var e;return Object(c.a)(this,t),(e=n.call(this)).blockSize=48,e.firstUse=!0,e.data=new a.DataStorage(Object(u.a)(e),Object(a.engine)()),e}return Object(s.a)(t,[{key:"write",value:function(e,n,t){this.firstUse&&(this.firstUse=!1,Object(a.env)().get("IS_NODE")&&a.backend_util.warn("\n============================\nHi there \ud83d\udc4b. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\n============================"));var r={};return this.data.set(r,{values:e,dtype:t,refCount:1}),r}},{key:"makeTensorInfo",value:function(e,n,t){var r;if("string"===n&&null!=t&&t.length>0&&a.util.isString(t[0])){var o=t.map((function(e){return a.util.encodeString(e)}));r=this.write(o,e,n)}else r=this.write(t,e,n);return{dataId:r,shape:e,dtype:n}}},{key:"incRef",value:function(e){this.data.get(e).refCount++}},{key:"decRef",value:function(e){this.data.has(e)&&this.data.get(e).refCount--}},{key:"move",value:function(e,n,t,a){this.data.set(e,{values:n,dtype:a,refCount:1})}},{key:"numDataIds",value:function(){return this.data.numDataIds()}},{key:"read",value:function(){var e=Object(i.a)(o.a.mark((function e(n){return o.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.abrupt("return",this.readSync(n));case 1:case"end":return e.stop()}}),e,this)})));return function(n){return e.apply(this,arguments)}}()},{key:"readSync",value:function(e){var n=this.data.get(e),t=n.dtype,r=n.complexTensorInfos;if("complex64"===t){var o=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return a.backend_util.mergeRealAndImagArrays(o,i)}return this.data.get(e).values}},{key:"bufferSync",value:function(e){var n=this.readSync(e.dataId),t=n;if("string"===e.dtype)try{t=n.map((function(e){return a.util.decodeString(e)}))}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(a.buffer)(e.shape,e.dtype,t)}},{key:"makeOutput",value:function(e,n,t){var r=this.write(e,n,t);return Object(a.engine)().makeTensorFromDataId(r,n,t,this)}},{key:"disposeData",value:function(e){if(this.data.has(e)){var n=this.data.get(e).complexTensorInfos;null!=n&&(this.disposeData(n.real.dataId),this.disposeData(n.imag.dataId)),this.data.delete(e)}}},{key:"disposeIntermediateTensorInfo",value:function(e){var n=e.dataId;if(this.data.has(n)){var t=this.data.get(n);t.refCount--,t.refCount<1&&this.disposeData(n)}}},{key:"time",value:function(){var e=Object(i.a)(o.a.mark((function e(n){var t,r;return o.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return t=a.util.now(),n(),r=a.util.now()-t,e.abrupt("return",{kernelMs:r});case 4:case"end":return e.stop()}}),e)})));return function(n){return e.apply(this,arguments)}}()},{key:"memory",value:function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}},{key:"where",value:function(e){f([e],"where");var n=this.readSync(e.dataId);return v(e.shape,n)}},{key:"dispose",value:function(){}},{key:"floatPrecision",value:function(){return 32}},{key:"epsilon",value:function(){return Object(l.a)(Object(d.a)(t.prototype),"epsilon",this).call(this)}}]),t}(a.KernelBackend);function g(e,n,t){return function(r){var o=r.inputs,i=r.attrs,c=r.backend,s=o.x;if(f(s,e),"string"===s.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");for(var u=c,l=u.data.get(s.dataId).values,d=a.util.sizeFromShape(s.shape),p=t||s.dtype,h=a.util.getArrayFromDType(p,d),v=0;v<d;++v)h[v]=n(l[v],i);return u.makeTensorInfo(s.shape,p,h)}}function b(e,n,t){return function(a){var r=a.inputs,o=a.attrs,i=a.backend,c=r.x;if(f(c,e),"string"===c.dtype||"string"===t)throw new Error("unaryKernelFunc does not support string input/output");var s=i,u=s.data.get(c.dataId).values,l=t||c.dtype,d=n(u,l,o);return s.makeTensorInfo(c.shape,l,d)}}Object(a.registerBackend)("cpu",(function(){return new m}),1);var x=g(a.Elu,(function(e){return e>=0?e:Math.exp(e)-1})),k={kernelName:a.Elu,backendName:"cpu",kernelFunc:x};function I(e){var n=e.inputs,t=e.backend,a=n.x;return t.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}var y={kernelName:a.Identity,backendName:"cpu",kernelFunc:I};function C(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.alpha;f([o],"leakyRelu");for(var c=a.util.sizeFromShape(o.shape),s=t.data.get(o.dataId).values,u=a.util.getTypedArrayFromDType("float32",c),l=0;l<s.length;l++)u[l]=s[l]<0?i*s[l]:s[l];return t.makeTensorInfo(o.shape,"float32",u)}var N={kernelName:a.LeakyRelu,backendName:"cpu",kernelFunc:C},T=t(57);function R(e){return function(n,t,r,o,i){var c=a.backend_util.assertAndGetBroadcastShape(n,t),s=c.length,u=a.util.computeStrides(c),l=a.util.sizeFromShape(c),d=a.util.getTypedArrayFromDType(i,l),p=n.length,h=t.length,f=a.util.computeStrides(n),v=a.util.computeStrides(t),m=a.backend_util.getBroadcastDims(n,c),g=a.backend_util.getBroadcastDims(t,c);if(m.length+g.length===0)for(var b=0;b<d.length;++b)d[b]=e(r[b%r.length],o[b%o.length]);else for(var x=function(n){var t=a.util.indexToLoc(n,s,u),i=t.slice(-p);m.forEach((function(e){return i[e]=0}));var c=a.util.locToIndex(i,p,f),l=t.slice(-h);g.forEach((function(e){return l[e]=0}));var b=a.util.locToIndex(l,h,v);d[n]=e(r[c],o[b])},k=0;k<d.length;++k)x(k);return[d,c]}}var w=R((function(e,n){return e<0?n*e:e}));function S(e){var n=e.inputs,t=e.backend,a=n.x,r=n.alpha;f([a,r],"prelu");var o=t.data.get(a.dataId).values,i=t.data.get(r.dataId).values,c=w(a.shape,r.shape,o,i,a.dtype),s=Object(T.a)(c,2),u=s[0],l=s[1];return t.makeTensorInfo(l,a.dtype,u)}var O={kernelName:a.Prelu,backendName:"cpu",kernelFunc:S},F=g(a.Relu,(function(e){return Math.max(0,e)})),A={kernelName:a.Relu,backendName:"cpu",kernelFunc:F},E=g(a.Relu6,(function(e){return Math.min(Math.max(0,e),6)})),_={kernelName:a.Relu6,backendName:"cpu",kernelFunc:E};function D(e,n,t,a,r){if("linear"===t)return I({inputs:{x:n},backend:e});if("relu"===t)return F({inputs:{x:n},backend:e});if("elu"===t)return x({inputs:{x:n},backend:e});if("relu6"===t)return E({inputs:{x:n},backend:e});if("prelu"===t)return S({inputs:{x:n,alpha:a},backend:e});if("leakyrelu"===t)return C({inputs:{x:n},backend:e,attrs:{alpha:r}});throw new Error("Activation ".concat(t," has not been implemented for the CPU backend."))}function P(e){var n=e.inputs,t=e.backend,a=n.real,r=n.imag,o=t.data.get(a.dataId).values,i=t.data.get(r.dataId).values,c=t.makeTensorInfo(a.shape,"complex64");return t.data.get(c.dataId).complexTensorInfos={real:t.makeTensorInfo(a.shape,"float32",o),imag:t.makeTensorInfo(r.shape,"float32",i)},c}var M={kernelName:a.Complex,backendName:"cpu",kernelFunc:P};function L(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===t){var r=L(e,n,"float32"),o=L(e,n,"float32");return P({inputs:{real:r,imag:o},backend:e})}var i=a.util.makeZerosTypedArray(a.util.sizeFromShape(n),t);return e.makeTensorInfo(n,t,i)}function B(e){var n=e.inputs,t=e.backend,a=n.input,r=t.data.get(a.dataId).complexTensorInfos.real,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}var W={kernelName:a.Real,backendName:"cpu",kernelFunc:B};function j(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.dtype;if("complex64"===i){if("complex64"===o.dtype)return I({inputs:{x:o},backend:t});var c=L(t,o.shape,o.dtype),s=j({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=P({inputs:{real:s,imag:c},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(s),u}if("complex64"===o.dtype){var l=B({inputs:{input:o},backend:t}),d=j({inputs:{x:l},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(l),d}if(!a.util.hasEncodingLoss(o.dtype,i)){var p=I({inputs:{x:o},backend:t});return{dataId:p.dataId,shape:p.shape,dtype:i}}if("int32"===i){var h=t.data.get(o.dataId).values,f=Int32Array.from(h);return t.makeTensorInfo(o.shape,"int32",f)}if("bool"===i){var v=t.data.get(o.dataId).values,m=a.util.toTypedArray([0],o.dtype),g=R((function(e,n){return e!==n?1:0}))(o.shape,[],v,m,"bool"),b=Object(T.a)(g,2),x=b[0],k=b[1];return t.makeTensorInfo(k,"bool",x)}throw new Error("Error in Cast: failed to cast ".concat(o.dtype," to ").concat(i))}var V={kernelName:a.Cast,backendName:"cpu",kernelFunc:j};function z(e,n,t,a){return null==t?function(t){var r=t.inputs,o=t.backend,i=r.a,c=r.b,s=o;f([i,c],e);var u=s.data.get(i.dataId).values,l=s.data.get(c.dataId).values,d=a||i.dtype,p=n(i.shape,c.shape,u,l,d),h=Object(T.a)(p,2),v=h[0],m=h[1];return s.makeTensorInfo(m,d,v)}:function(e){var r=e.inputs,o=e.backend,i=r.a,c=r.b,s=o;if("complex64"===i.dtype||"complex64"===c.dtype){var u=j({inputs:{x:i},backend:s,attrs:{dtype:"complex64"}}),l=s.data.get(u.dataId),d=l.complexTensorInfos.real,p=l.complexTensorInfos.imag,h=s.data.get(d.dataId).values,f=s.data.get(p.dataId).values,v=j({inputs:{x:c},backend:s,attrs:{dtype:"complex64"}}),m=s.data.get(v.dataId),g=m.complexTensorInfos.real,b=m.complexTensorInfos.imag,x=s.data.get(g.dataId).values,k=s.data.get(b.dataId).values,I=t(i.shape,c.shape,h,f,x,k),y=Object(T.a)(I,3),C=y[0],N=y[1],R=y[2],w=s.makeTensorInfo(R,"float32",C),S=s.makeTensorInfo(R,"float32",N),O=P({inputs:{real:w,imag:S},backend:s});return s.disposeIntermediateTensorInfo(u),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(S),O}var F=s.data.get(i.dataId).values,A=s.data.get(c.dataId).values,E=a||i.dtype,_=n(i.shape,c.shape,F,A,E),D=Object(T.a)(_,2),M=D[0],L=D[1];return s.makeTensorInfo(L,E,M)}}function G(e){return function(n,t,r,o,i,c){var s=a.backend_util.assertAndGetBroadcastShape(n,t),u=a.util.sizeFromShape(s),l=s.length,d=a.util.computeStrides(s),p=a.util.getTypedArrayFromDType("float32",u),h=a.util.getTypedArrayFromDType("float32",u),f=a.backend_util.getBroadcastDims(n,s),v=a.backend_util.getBroadcastDims(t,s),m=a.backend_util.mergeRealAndImagArrays(r,o),g=a.backend_util.mergeRealAndImagArrays(i,c),b=n.length,x=a.util.computeStrides(n),k=t.length,I=a.util.computeStrides(t);if(f.length+v.length===0)for(var y=0;y<p.length;y++){var C=y%m.length,N=y%g.length,T=e(m[2*C],m[2*C+1],g[2*N],g[2*N+1]);p[y]=T.real,h[y]=T.imag}else for(var R=function(n){var t=a.util.indexToLoc(n,l,d),r=t.slice(-b);f.forEach((function(e){return r[e]=0}));var o=a.util.locToIndex(r,b,x),i=t.slice(-k);v.forEach((function(e){return i[e]=0}));var c=a.util.locToIndex(i,k,I),s=e(m[2*o],m[2*o+1],g[2*c],g[2*c+1]);p[n]=s.real,h[n]=s.imag},w=0;w<p.length;w++)R(w);return[p,h,s]}}var U=R((function(e,n){return e+n})),H=G((function(e,n,t,a){return{real:e+t,imag:n+a}})),X=z(a.Add,U,H),q={kernelName:a.Add,backendName:"cpu",kernelFunc:X};function K(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.shape,c=a.util.sizeFromShape(o.shape),s=a.util.inferFromImplicitShape(i,c),u=a.util.sizeFromShape(s);a.util.assert(c===u,(function(){return"The new shape (".concat(s,") has ").concat(u," elements and the old ")+"shape (".concat(o.shape,") has ").concat(c," elements. The new shape and old ")+"shape must have the same number of elements."})),t.incRef(o.dataId);var l=t.data.get(o.dataId);if(null!=l.complexTensorInfos){var d=l.complexTensorInfos.real,p=l.complexTensorInfos.imag;d.shape=s,p.shape=s}return{dataId:o.dataId,shape:s,dtype:o.dtype}}var Y={kernelName:a.Reshape,backendName:"cpu",kernelFunc:K};function Q(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.a,i=n.b,c=r.transposeA,s=r.transposeB;f([o,i],"matMul");var u=o.shape.length,l=i.shape.length,d=c?o.shape[u-2]:o.shape[u-1],p=s?i.shape[l-1]:i.shape[l-2],h=c?o.shape[u-1]:o.shape[u-2],v=s?i.shape[l-2]:i.shape[l-1],m=o.shape.slice(0,-2),g=i.shape.slice(0,-2),b=a.util.sizeFromShape(m),x=a.util.sizeFromShape(g),k=b===x||1===b||1===x;a.util.assert(u>=2&&l>=2&&k,(function(){return"Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input "+"batch dimensions of (".concat(m,") and (").concat(g,").")}));var I=(b>x?o.shape.slice(0,-2):i.shape.slice(0,-2)).concat([h,v]);a.util.assert(d===p,(function(){return"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(o.shape," and ")+"".concat(i.shape," and transposeA=").concat(c)+" and transposeB=".concat(s," must match.")}));for(var y=s?[x,v,p]:[x,p,v],C=K({inputs:{x:o},backend:t,attrs:{shape:c?[b,d,h]:[b,h,d]}}),N=K({inputs:{x:i},backend:t,attrs:{shape:y}}),R=c?C.shape[1]:C.shape[2],w=c?C.shape[2]:C.shape[1],S=s?N.shape[1]:N.shape[2],O=Math.max(b,x),F=t.data.get(C.dataId).values,A=t.data.get(N.dataId).values,E=a.util.computeStrides(C.shape),_=a.util.computeStrides(N.shape),D=c?[E[0],1,E[1]]:[E[0],E[1],1],P=Object(T.a)(D,3),M=P[0],L=P[1],B=P[2],W=s?[1,_[1],_[0]]:[_[1],1,_[0]],j=Object(T.a)(W,3),V=j[0],z=j[1],G=j[2],U=w*S,H=Object(a.buffer)([O,w,S],C.dtype),X=H.values,q=t.blockSize,Y=0;Y<O;Y++)for(var Q=0;Q<w;Q+=q)for(var Z=0;Z<S;Z+=q)for(var J=0;J<R;J+=q)for(var $=Math.min(Q+q,w),ee=Math.min(Z+q,S),ne=Math.min(J+q,R),te=Q;te<$;te++)for(var ae=Z;ae<ee;ae++){for(var re=0,oe=J;oe<ne;oe++){var ie=Math.min(Y,b-1)*M,ce=Math.min(Y,x-1)*G;re+=F[ie+te*L+oe*B]*A[oe*V+ae*z+ce]}X[Y*U+(te*S+ae)]+=re}return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(N),t.makeTensorInfo(I,H.dtype,H.values)}var Z={kernelName:a.BatchMatMul,backendName:"cpu",kernelFunc:Q};var J={kernelName:a._FusedMatMul,backendName:"cpu",kernelFunc:function(e){var n,t,a,r=e.inputs,o=e.backend,i=e.attrs,c=r.a,s=r.b,u=r.bias,l=r.preluActivationWeights,d=i.transposeA,p=i.transposeB,h=i.activation,f=i.leakyreluAlpha,v=[];n=Q({inputs:{a:c,b:s},attrs:{transposeA:d,transposeB:p},backend:o}),u&&(t=X({inputs:{a:n,b:u},backend:o}),v.push(n),n=t),h&&(a=D(o,n,h,l,f),v.push(n),n=a);for(var m=0,g=v;m<g.length;m++){var b=g[m];o.disposeIntermediateTensorInfo(b)}return n}};var $={kernelName:a.Abs,backendName:"cpu",kernelFunc:function(e){var n=e.inputs.x,t=e.backend;f(n,"abs");var r=new Float32Array(a.util.sizeFromShape(n.shape));return r=function(e){for(var n=new Float32Array(e.length),t=0;t<e.length;++t)n[t]=Math.abs(e[t]);return n}(t.data.get(n.dataId).values),t.makeOutput(r,n.shape,"float32")}},ee=g(a.Acos,(function(e){return Math.acos(e)})),ne={kernelName:a.Acos,backendName:"cpu",kernelFunc:ee},te=g(a.Acosh,(function(e){return Math.acosh(e)})),ae={kernelName:a.Acosh,backendName:"cpu",kernelFunc:te};var re={kernelName:a.AddN,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n;f(n,"addN");for(var o=r.map((function(e){return t.data.get(e.dataId).values})),i=Object(a.buffer)(r[0].shape,r[0].dtype),c=i.values,s=0;s<r.length;s++)for(var u=o[s],l=0;l<c.length;l++)c[l]+=u[l];return t.makeTensorInfo(i.shape,i.dtype,i.values)}};function oe(e,n,t,r,o){for(var i=n.length,c=a.util.sizeFromShape(n),s=a.util.computeStrides(n),u=a.util.computeStrides(o),l=a.util.getTypedArrayFromDType(t,a.util.sizeFromShape(o)),d=0;d<c;++d){for(var p=a.util.indexToLoc(d,i,s),h=new Array(p.length),f=0;f<h.length;f++)h[f]=p[r[f]];l[a.util.locToIndex(h,i,u)]=e[d]}return l}function ie(e){var n=e.inputs,t=e.attrs,a=e.backend,r=n.x,o=t.perm;f(r,"transpose");for(var i=r.shape.length,c=new Array(i),s=0;s<c.length;s++)c[s]=r.shape[o[s]];var u=oe(a.data.get(r.dataId).values,r.shape,r.dtype,o,c);return{dataId:a.write(u,c,r.dtype),shape:c,dtype:r.dtype}}var ce={kernelName:a.Transpose,backendName:"cpu",kernelFunc:ie};var se={kernelName:a.All,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.keepDims;f(o,"all");var s=a.util.parseAxisParam(i,o.shape),u=s,l=a.backend_util.getAxesPermutation(u,o.shape.length),d=o;null!=l&&(d=ie({inputs:{x:o},backend:t,attrs:{perm:l}}),u=a.backend_util.getInnerMostAxes(u.length,o.shape.length)),a.backend_util.assertAxesAreInnerMostDims("all",u,d.shape.length);for(var p=a.backend_util.computeOutAndReduceShapes(d.shape,u),h=Object(T.a)(p,2),v=h[0],m=h[1],g=a.util.sizeFromShape(m),b=a.util.makeZerosTypedArray(a.util.sizeFromShape(v),d.dtype),x=t.data.get(d.dataId).values,k=0;k<b.length;++k){for(var I=k*g,y=x[I],C=0;C<g;++C){var N=x[I+C];y=y&&N}b[k]=y}null!=l&&t.disposeIntermediateTensorInfo(d);var R=t.makeTensorInfo(v,d.dtype,b);if(c){var w=K({inputs:{x:R},backend:t,attrs:{shape:a.backend_util.expandShapeToKeepDim(v,s)}});return t.disposeIntermediateTensorInfo(R),w}return R}};var ue={kernelName:a.Any,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.keepDims;f(o,"any");var s=a.util.parseAxisParam(i,o.shape),u=s,l=a.backend_util.getAxesPermutation(u,o.shape.length),d=o;null!=l&&(d=ie({inputs:{x:o},backend:t,attrs:{perm:l}}),u=a.backend_util.getInnerMostAxes(u.length,o.shape.length)),a.backend_util.assertAxesAreInnerMostDims("any",u,d.shape.length);for(var p=a.backend_util.computeOutAndReduceShapes(d.shape,u),h=Object(T.a)(p,2),v=h[0],m=h[1],g=a.util.sizeFromShape(m),b=a.util.makeZerosTypedArray(a.util.sizeFromShape(v),d.dtype),x=t.data.get(d.dataId).values,k=0;k<b.length;++k){for(var I=k*g,y=x[I],C=0;C<g;++C){var N=x[I+C];y=y||N}b[k]=y}null!=l&&t.disposeIntermediateTensorInfo(d);var R=t.makeTensorInfo(v,d.dtype,b);if(c){var w=K({inputs:{x:R},backend:t,attrs:{shape:a.backend_util.expandShapeToKeepDim(v,s)}});return t.disposeIntermediateTensorInfo(R),w}return R}};var le={kernelName:a.ArgMax,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis;f(o,"argMax");var c=a.util.parseAxisParam(i,o.shape),s=a.backend_util.getAxesPermutation(c,o.shape.length),u=o,l=[];null!=s&&(u=ie({inputs:{x:o},backend:t,attrs:{perm:s}}),l.push(u),c=a.backend_util.getInnerMostAxes(c.length,u.shape.length)),c=[c[0]],a.backend_util.assertAxesAreInnerMostDims("argMax",c,u.shape.length);for(var d=a.backend_util.computeOutAndReduceShapes(u.shape,c),p=Object(T.a)(d,2),h=p[0],v=p[1],m=a.util.sizeFromShape(h),g=a.util.makeZerosTypedArray(m,"int32"),b=a.util.sizeFromShape(v),x=t.data.get(u.dataId).values,k=0;k<g.length;++k){for(var I=k*b,y=x[I],C=0,N=0;N<b;++N){var R=x[I+N];R>y&&(y=R,C=N)}g[k]=C}return l.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.makeTensorInfo(h,"int32",g)}};var de={kernelName:a.ArgMin,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis;f(o,"argMin");var c=a.util.parseAxisParam(i,o.shape),s=a.backend_util.getAxesPermutation(c,o.shape.length),u=o,l=[];null!=s&&(u=ie({inputs:{x:o},backend:t,attrs:{perm:s}}),l.push(u),c=a.backend_util.getInnerMostAxes(c.length,u.shape.length)),c=[c[0]],a.backend_util.assertAxesAreInnerMostDims("argMin",c,u.shape.length);for(var d=a.backend_util.computeOutAndReduceShapes(u.shape,c),p=Object(T.a)(d,2),h=p[0],v=p[1],m=a.util.sizeFromShape(h),g=a.util.makeZerosTypedArray(m,"int32"),b=a.util.sizeFromShape(v),x=t.data.get(u.dataId).values,k=0;k<g.length;++k){for(var I=k*b,y=x[I],C=0,N=0;N<b;++N){var R=x[I+N];R<y&&(y=R,C=N)}g[k]=C}return l.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.makeTensorInfo(h,"int32",g)}},pe=g(a.Asin,(function(e){return Math.asin(e)})),he={kernelName:a.Asin,backendName:"cpu",kernelFunc:pe},fe=g(a.Asinh,(function(e){return Math.asinh(e)})),ve={kernelName:a.Asinh,backendName:"cpu",kernelFunc:fe},me=g(a.Atan,(function(e){return Math.atan(e)})),ge={kernelName:a.Atan,backendName:"cpu",kernelFunc:me},be=R((function(e,n){return Math.atan2(e,n)})),xe=z(a.Atan2,be),ke={kernelName:a.Atan2,backendName:"cpu",kernelFunc:xe},Ie=g(a.Atanh,(function(e){return Math.atanh(e)})),ye={kernelName:a.Atanh,backendName:"cpu",kernelFunc:Ie};function Ce(e,n,t,r,o,i){for(var c=o.strideHeight,s=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,d=o.effectiveFilterHeight,p=o.effectiveFilterWidth,h=o.padInfo.top,f=o.padInfo.left,v="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Object(a.buffer)(o.outShape,t),g=m.values,b=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],k=o.outShape[3],I=0;I<o.batchSize;++I)for(var y=I*b,C=I*r[0],N=0;N<o.inChannels;++N)for(var T=0;T<o.outHeight;++T)for(var R=T*c-h,w=Math.max(0,R),S=Math.min(o.inHeight,d+R),O=y+T*x,F=0;F<o.outWidth;++F){for(var A=F*s-f,E=Math.max(0,A),_=Math.min(o.inWidth,p+A),D=v,P=0,M=0,L=w;L<S;L+=u){for(var B=C+L*r[1],W=E;W<_;W+=l){var j=e[B+W*r[2]+N];"max"===i&&j>D?D=j:"avg"===i&&(P+=j,M++)}if(isNaN(D))break}g[O+F*k+N]="avg"===i?P/M:D}return m}function Ne(e,n,t,r){for(var o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],c=Object(a.buffer)(r.outShape,"int32"),s=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterHeight,h=r.effectiveFilterWidth,f=r.padInfo.top,v=r.padInfo.left,m=Object(a.buffer)(n,t,e),g=0;g<r.batchSize;++g)for(var b=0;b<r.inChannels;++b)for(var x=0;x<r.outHeight;++x){for(var k=x*s-f,I=k;I<0;)I+=l;for(var y=Math.min(r.inHeight,p+k),C=0;C<r.outWidth;++C){for(var N=C*u-v,T=N;T<0;)T+=d;for(var R=Math.min(r.inWidth,h+N),w=Number.NEGATIVE_INFINITY,S=-1,O=I;O<y;O+=l)for(var F=O-k,A=T;A<R;A+=d){var E=A-N,_=m.get(g,O,A,b);_>w&&(w=_,S=o?i?((g*r.inHeight+O)*r.inWidth+A)*r.inChannels+b:(O*r.inWidth+A)*r.inChannels+b:F*h+E)}c.set(S,g,x,C,b)}}return c}function Te(e,n,t,r,o,i){for(var c=o.strideDepth,s=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,d=o.dilationHeight,p=o.dilationWidth,h=o.effectiveFilterDepth,f=o.effectiveFilterHeight,v=o.effectiveFilterWidth,m=o.padInfo.front,g=o.padInfo.top,b=o.padInfo.left,x="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,k=Object(a.buffer)(o.outShape,t),I=k.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],C=o.outShape[2]*o.outShape[3]*o.outShape[4],N=o.outShape[3]*o.outShape[4],T=o.outShape[4],R=0;R<o.batchSize;++R)for(var w=R*y,S=R*r[0],O=0;O<o.inChannels;++O)for(var F=0;F<o.outDepth;++F){for(var A=F*c-m,E=A;E<0;)E+=l;for(var _=Math.min(o.inDepth,h+A),D=w+F*C,P=0;P<o.outHeight;++P){for(var M=P*s-g,L=M;L<0;)L+=d;for(var B=Math.min(o.inHeight,f+M),W=D+P*N,j=0;j<o.outWidth;++j){for(var V=j*u-b,z=V;z<0;)z+=p;for(var G=Math.min(o.inWidth,v+V),U=W+j*T,H=x,X=0,q=0,K=E;K<_;K+=l){for(var Y=S+K*r[1],Q=L;Q<B;Q+=d){for(var Z=Y+Q*r[2],J=z;J<G;J+=p){var $=e[Z+J*r[3]+O];if("max"===i&&$>H?H=$:"avg"===i&&(X+=$,q++),isNaN(H))break}if(isNaN(H))break}if(isNaN(H))break}I[U+O]="avg"===i?X/q:H}}}return k}var Re={kernelName:a.AvgPool,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x;f(o,"avgPool");var i=r.filterSize,c=r.strides,s=r.pad,u=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(c,1),(function(){return"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(c," and dilations '").concat(1,"'")}));var l,d=a.backend_util.computePool2DInfo(o.shape,i,c,1,s,u);if(1===d.filterWidth&&1===d.filterHeight&&a.util.arraysEqual(d.inShape,d.outShape))l=I({inputs:{x:o},backend:t});else{var p=t.data.get(o.dataId).values,h=a.util.computeStrides(o.shape),v=Ce(p,o.shape,o.dtype,h,d,"avg");l=t.makeTensorInfo(d.outShape,o.dtype,v.values)}return l}};var we={kernelName:a.AvgPool3D,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.filterSize,c=r.strides,s=r.pad,u=r.dimRoundingMode,l=r.dataFormat;f(o,"avgPool3d");var d=a.backend_util.computePool3DInfo(o.shape,i,c,1,s,u,l),p=Te(t.data.get(o.dataId).values,o.shape,o.dtype,a.util.computeStrides(o.shape),d,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}};var Se={kernelName:a.AvgPool3DGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.input,c=r.filterSize,s=r.strides,u=r.pad,l=r.dimRoundingMode;f([o,i],"avgPool3DGrad");for(var d=a.backend_util.computePool3DInfo(i.shape,c,s,1,u,l),p=d.strideDepth,h=d.strideHeight,v=d.strideWidth,m=d.filterDepth,g=d.filterHeight,b=d.filterWidth,x=d.dilationDepth,k=d.dilationHeight,I=d.dilationWidth,y=d.effectiveFilterDepth,C=d.effectiveFilterHeight,N=d.effectiveFilterWidth,T=y-1-d.padInfo.front,R=N-1-d.padInfo.left,w=C-1-d.padInfo.top,S=Object(a.buffer)(i.shape,"float32"),O=1/(m*g*b),F=t.bufferSync(o),A=0;A<d.batchSize;++A)for(var E=0;E<d.inChannels;++E)for(var _=0;_<d.inDepth;++_)for(var D=0;D<d.inHeight;++D)for(var P=0;P<d.inWidth;++P){for(var M=_-T,L=D-w,B=P-R,W=0,j=0;j<y;j+=x){var V=(M+j)/p;if(!(V<0||V>=d.outDepth||Math.floor(V)!==V))for(var z=0;z<C;z+=k){var G=(L+z)/h;if(!(G<0||G>=d.outHeight||Math.floor(G)!==G))for(var U=0;U<N;U+=I){var H=(B+U)/v;if(!(H<0||H>=d.outWidth||Math.floor(H)!==H))W+=F.get(A,V,G,H,E)}}}S.set(W*O,A,_,D,P,E)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}};var Oe={kernelName:a.AvgPoolGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.input,c=i;f([o,i],"avgPoolGrad");for(var s=r.filterSize,u=r.strides,l=r.pad,d=a.backend_util.computePool2DInfo(c.shape,s,u,1,l),p=d.strideHeight,h=d.strideWidth,v=d.filterHeight,m=d.filterWidth,g=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,k=d.effectiveFilterWidth,I=k-1-d.padInfo.left,y=x-1-d.padInfo.top,C=Object(a.buffer)(c.shape,"float32"),N=1/(v*m),T=t.data.get(o.dataId).values,R=Object(a.buffer)(o.shape,"float32",T),w=0;w<d.batchSize;++w)for(var S=0;S<d.inChannels;++S)for(var O=0;O<d.inHeight;++O)for(var F=0;F<d.inWidth;++F){for(var A=O-y,E=F-I,_=0,D=0;D<x;D+=g){var P=(A+D)/p;if(!(P<0||P>=d.outHeight||Math.floor(P)!==P))for(var M=0;M<k;M+=b){var L=(E+M)/h;if(!(L<0||L>=d.outWidth||Math.floor(L)!==L))_+=R.get(w,P,L,S)}}C.set(_*N,w,O,F,S)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}};var Fe={kernelName:a.FusedBatchNorm,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.scale,c=n.offset,s=n.mean,u=n.variance;a.util.assert(s.shape.length===u.shape.length,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),a.util.assert(null==c||s.shape.length===c.shape.length,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),a.util.assert(null==i||s.shape.length===i.shape.length,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),f([o,s,u,i,c],"batchNorm");var l=r.varianceEpsilon;null==l&&(l=.001);for(var d=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,h=t.data.get(u.dataId).values,v=i?t.data.get(i.dataId).values:new Float32Array([1]),m=c?t.data.get(c.dataId).values:new Float32Array([0]),g=new Float32Array(d.length),b=m.length,x=v.length,k=h.length,I=p.length,y=0,C=0,N=0,T=0,R=0;R<d.length;++R)g[R]=m[y++]+(d[R]-p[C++])*v[N++]/Math.sqrt(h[T++]+l),y>=b&&(y=0),C>=I&&(C=0),N>=x&&(N=0),T>=k&&(T=0);return t.makeTensorInfo(o.shape,o.dtype,g)}},Ae=t(181);function Ee(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.begin,c=r.size;f(o,"slice");var s=a.slice_util.parseSliceParams(o,i,c),u=Object(T.a)(s,2),l=u[0],d=u[1];a.slice_util.assertParamsValid(o,l,d);var p=function(e,n,t,r,o){var i=a.slice_util.isSliceContinous(r,n,t),c=a.util.sizeFromShape(t),s=a.util.computeStrides(r);if(i){var u=a.slice_util.computeFlatOffset(n,s);return"string"===o?e.slice(u,u+c):e.subarray(u,u+c)}for(var l="string"===o?a.backend_util.fromUint8ToStringArray(e):e,d=Object(a.buffer)(r,o,l),p=Object(a.buffer)(t,o),h=0;h<p.size;++h){var f=p.indexToLoc(h),v=f.map((function(e,t){return e+n[t]}));p.set.apply(p,[d.get.apply(d,Object(Ae.a)(v))].concat(Object(Ae.a)(f)))}return"string"===o?a.backend_util.fromStringArrayToUint8(p.values):p.values}(t.data.get(o.dataId).values,l,d,o.shape,o.dtype);return t.makeTensorInfo(d,o.dtype,p)}var _e={kernelName:a.Slice,backendName:"cpu",kernelFunc:Ee};var De={kernelName:a.BatchToSpaceND,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.blockShape,c=r.crops;f([o],"batchToSpaceND");var s=i.reduce((function(e,n){return e*n})),u=a.backend_util.getReshaped(o.shape,i,s),l=a.backend_util.getPermuted(u.length,i.length),d=a.backend_util.getReshapedPermuted(o.shape,i,s),p=a.backend_util.getSliceBeginCoords(c,i.length),h=a.backend_util.getSliceSize(d,c,i.length),v=K({inputs:{x:o},backend:t,attrs:{shape:u}}),m=ie({inputs:{x:v},backend:t,attrs:{perm:l}}),g=K({inputs:{x:m},backend:t,attrs:{shape:d}}),b=Ee({inputs:{x:g},backend:t,attrs:{begin:p,size:h}});return t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),b}};function Pe(e,n,t,r,o){for(var i=a.util.sizeFromShape(r),c=a.util.makeZerosTypedArray(o,t),s=0;s<e.length;s++){var u=e[s];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(c[u]+=i>0?n[s]:1)}return c}var Me={kernelName:a.Bincount,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.weights,i=a.size,c=Pe(t.data.get(r.dataId).values,t.data.get(o.dataId).values,o.dtype,o.shape,i);return t.makeTensorInfo([i],o.dtype,c)}};function Le(e){return function(n,t,r){for(var o=a.util.getTypedArrayFromDType(t,n.length),i=0;i<n.length;++i)o[i]=e(n[i],r);return o}}var Be=Le((function(e){return Math.ceil(e)})),We=b(a.Ceil,Be),je={kernelName:a.Ceil,backendName:"cpu",kernelFunc:We},Ve=g(a.ClipByValue,(function(e,n){var t=n;return e>t.clipValueMax?t.clipValueMax:e<t.clipValueMin?t.clipValueMin:e})),ze={kernelName:a.ClipByValue,backendName:"cpu",kernelFunc:Ve},Ge={kernelName:a.ComplexAbs,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs.x,t=e.backend,r=new Float32Array(a.util.sizeFromShape(n.shape)),o=t.data.get(n.dataId),i=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,s=t.data.get(i.dataId).values,u=t.data.get(c.dataId).values,l=0;l<s.length;l++){var d=s[l],p=u[l];r[l]=Math.hypot(d,p)}return t.makeOutput(r,n.shape,"float32")}};function Ue(e){var n=e.inputs,t=e.backend,a=n.input,r=t.data.get(a.dataId).complexTensorInfos.imag,o=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,o)}var He={kernelName:a.Imag,backendName:"cpu",kernelFunc:Ue};function Xe(e){var n=e.inputs,t=e.backend,r=e.attrs.axis,o=a.util.parseAxisParam(r,n[0].shape)[0],i=a.backend_util.computeOutShape(n.map((function(e){return e.shape})),o);if(0===a.util.sizeFromShape(i))return t.makeTensorInfo(i,n[0].dtype,[]);var c=n.filter((function(e){return a.util.sizeFromShape(e.shape)>0}));if(1===c.length)return I({inputs:{x:c[0]},backend:t});var s=c.map((function(e){return e.shape}));if(a.backend_util.assertParamsConsistent(s,o),"complex64"===c[0].dtype){var u=c.map((function(e){return B({inputs:{input:e},backend:t})})),l=c.map((function(e){return Ue({inputs:{input:e},backend:t})})),d=Xe({inputs:u,backend:t,attrs:{axis:o}}),p=Xe({inputs:l,backend:t,attrs:{axis:o}}),h=P({inputs:{real:d,imag:p},backend:t});return u.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),l.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),h}var f=c.map((function(e){var n=a.util.sizeFromShape(e.shape.slice(o));return K({inputs:{x:e},backend:t,attrs:{shape:[-1,n]}})})),v=f.map((function(e){return{vals:t.data.get(e.dataId).values,shape:e.shape}}));i=a.backend_util.computeOutShape(f.map((function(e){return e.shape})),1);var m=1===f[0].shape[0],g=function(e,n,t,r){var o=a.util.getArrayFromDType(t,a.util.sizeFromShape(n));if(r&&"string"!==t){var i=0;e.forEach((function(e){var n=a.util.sizeFromShape(e.shape);o.set(e.vals,i),i+=n}))}else{var c=0;e.forEach((function(e){for(var r="string"===t?a.backend_util.fromUint8ToStringArray(e.vals):e.vals,i=0,s=0;s<e.shape[0];++s)for(var u=s*n[1]+c,l=0;l<e.shape[1];++l)o[u+l]=r[i++];c+=e.shape[1]}))}return o}(v,i,n[0].dtype,m),b=a.backend_util.computeOutShape(c.map((function(e){return e.shape})),o),x=t.makeTensorInfo(b,n[0].dtype,g);return f.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),x}var qe={kernelName:a.Concat,backendName:"cpu",kernelFunc:Xe};function Ke(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=r.strides,s=r.pad,u=r.dataFormat,l=r.dilations,d=r.dimRoundingMode;f([o,i],"conv2d");for(var p=a.backend_util.convertConv2DDataFormat(u),h=a.backend_util.computeConv2DInfo(o.shape,i.shape,c,l,s,d,!1,p),v=h.filterHeight,m=h.filterWidth,g=h.dilationHeight,b=h.dilationWidth,x=h.padInfo.left,k=h.padInfo.top,I="channelsLast"===h.dataFormat,y=new a.TensorBuffer(h.outShape,o.dtype),C=a.util.computeStrides(o.shape),N=a.util.computeStrides(i.shape),T=C[0],R=I?C[1]:C[2],w=I?C[2]:1,S=I?1:C[1],O=y.strides[0],F=I?y.strides[1]:y.strides[2],A=I?y.strides[2]:1,E=I?1:y.strides[1],_=t.data.get(o.dataId).values,D=t.data.get(i.dataId).values,P=y.values,M=0;M<h.batchSize;++M)for(var L=M*T,B=M*O,W=0;W<h.outHeight;++W)for(var j=B+W*F,V=W*h.strideHeight-k,z=0;z<v;++z){var G=V+z*g;if(!(G<0||G>=h.inHeight))for(var U=z*N[0],H=L+G*R,X=0;X<h.outWidth;++X)for(var q=j+X*A,K=X*h.strideWidth-x,Y=0;Y<m;++Y){var Q=K+Y*b;if(!(Q<0||Q>=h.inWidth))for(var Z=H+Q*w,J=U+Y*N[1],$=0;$<h.inChannels;++$){for(var ee=_[Z+$*S],ne=0;ne<h.outChannels;++ne)P[q+ne*E]+=ee*D[J+ne];J+=h.outChannels}}}return t.makeTensorInfo(y.shape,y.dtype,P)}var Ye={kernelName:a.Conv2D,backendName:"cpu",kernelFunc:Ke};var Qe={kernelName:a.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.dy,c=r.strides,s=r.pad,u=r.dataFormat,l=r.dimRoundingMode,d=r.filterShape;f([o,i],"conv2dBackpropFilter");for(var p=a.backend_util.convertConv2DDataFormat(u),h=a.backend_util.computeConv2DInfo(o.shape,d,c,1,s,l,!1,p),v=h.strideHeight,m=h.strideWidth,g=h.filterHeight,b=h.filterWidth,x="channelsLast"===h.dataFormat,k=new a.TensorBuffer(h.filterShape,"float32"),I=h.padInfo.left,y=h.padInfo.top,C=t.data.get(o.dataId).values,N=t.data.get(i.dataId).values,T=new a.TensorBuffer(o.shape,o.dtype,C),R=new a.TensorBuffer(i.shape,i.dtype,N),w=0;w<g;++w)for(var S=Math.max(0,Math.ceil((y-w)/v)),O=Math.min(h.outHeight,(h.inHeight+y-w)/v),F=0;F<b;++F)for(var A=Math.max(0,Math.ceil((I-F)/m)),E=Math.min(h.outWidth,(h.inWidth+I-F)/m),_=0;_<h.inChannels;++_)for(var D=0;D<h.outChannels;++D){for(var P=0,M=0;M<h.batchSize;++M)for(var L=S;L<O;++L)for(var B=w+L*v-y,W=A;W<E;++W){var j=F+W*m-I;P+=x?T.get(M,B,j,_)*R.get(M,L,W,D):T.get(M,_,B,j)*R.get(M,D,L,W)}k.set(P,w,F,_,D)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}};var Ze={kernelName:a.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.filter,c=r.inputShape,s=r.strides,u=r.pad,l=r.dataFormat,d=r.dimRoundingMode;f([o,i],"conv2dBackpropInput");var p=a.util.computeStrides(i.shape),h=a.util.computeStrides(o.shape),v=a.backend_util.convertConv2DDataFormat(l),m=a.backend_util.computeConv2DInfo(c,i.shape,s,1,u,d,!1,v),g=new a.TensorBuffer(m.inShape,"float32"),b=g.values,x=t.data.get(o.dataId).values,k=t.data.get(i.dataId).values,I=Object(T.a)(p,3),y=I[0],C=I[1],N=I[2],R=m.batchSize,w=m.filterHeight,S=m.filterWidth,O=m.inChannels,F=m.inHeight,A=m.inWidth,E=m.outChannels,_=m.outHeight,D=m.outWidth,P=m.strideHeight,M=m.strideWidth;v=m.dataFormat;for(var L=w-1-m.padInfo.top,B=S-1-m.padInfo.left,W="channelsLast"===v,j=g.strides[0],V=W?g.strides[1]:g.strides[2],z=W?g.strides[2]:1,G=W?1:g.strides[1],U=h[0],H=W?h[1]:h[2],X=W?h[2]:1,q=W?1:h[1],K=0;K<R;++K)for(var Y=0;Y<O;++Y)for(var Q=0;Q<F;++Q)for(var Z=Q-L,J=Math.max(0,Math.ceil(Z/P)),$=Math.min(_,(w+Z)/P),ee=0;ee<A;++ee){for(var ne=ee-B,te=Math.max(0,Math.ceil(ne/M)),ae=Math.min(D,(S+ne)/M),re=0,oe=J;oe<$;++oe)for(var ie=oe*P-Z,ce=te;ce<ae;++ce)for(var se=U*K+H*oe+X*ce,ue=y*(w-1-ie)+C*(S-1-(ce*M-ne))+N*Y,le=0;le<E;++le){re+=x[se+q*le]*k[ue+le]}b[j*K+V*Q+z*ee+G*Y]=re}return t.makeTensorInfo(g.shape,g.dtype,g.values)}};var Je={kernelName:a.Conv3D,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=r.strides,s=r.pad,u=r.dilations;f([o,i],"conv3d");for(var l=a.backend_util.computeConv3DInfo(o.shape,i.shape,c,u,s),d=l.filterDepth,p=l.filterHeight,h=l.filterWidth,v=l.dilationDepth,m=l.dilationHeight,g=l.dilationWidth,b=l.padInfo,x=b.front,k=b.left,I=b.top,y=new a.TensorBuffer(l.outShape,o.dtype),C=t.data.get(o.dataId).values,N=t.data.get(i.dataId).values,T=y.values,R=a.util.computeStrides(o.shape),w=a.util.computeStrides(i.shape),S=0;S<l.batchSize;++S)for(var O=S*R[0],F=S*y.strides[0],A=0;A<l.outDepth;++A)for(var E=F+A*y.strides[1],_=A*l.strideDepth-x,D=0;D<d;++D){var P=_+D*v;if(!(P<0||P>=l.inDepth))for(var M=D*w[0],L=O+P*R[1],B=0;B<l.outHeight;++B)for(var W=E+B*y.strides[2],j=B*l.strideHeight-I,V=0;V<p;++V){var z=j+V*m;if(!(z<0||z>=l.inHeight))for(var G=M+V*w[1],U=L+z*R[2],H=0;H<l.outWidth;++H)for(var X=W+H*l.outChannels,q=H*l.strideWidth-k,K=0;K<h;++K){var Y=q+K*g;if(!(Y<0||Y>=l.inWidth))for(var Q=G+K*w[2],Z=U+Y*l.inChannels,J=Q,$=0;$<l.inChannels;++$){for(var ee=C[Z+$],ne=0;ne<l.outChannels;++ne)T[X+ne]+=ee*N[J+ne];J+=l.outChannels}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}};var $e={kernelName:a.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.dy,c=r.strides,s=r.pad,u=r.filterShape;f([o,i],"conv3dBackpropFilterV2");for(var l=a.util.computeStrides(o.shape),d=a.util.computeStrides(i.shape),p=a.backend_util.computeConv3DInfo(o.shape,u,c,1,s),h=p.strideDepth,v=p.strideHeight,m=p.strideWidth,g=p.filterDepth,b=p.filterHeight,x=p.filterWidth,k=new a.TensorBuffer(p.filterShape,"float32"),I=k.values,y=Object(T.a)(k.strides,4),C=y[0],N=y[1],R=y[2],w=y[3],S=t.data.get(i.dataId).values,O=Object(T.a)(d,4),F=O[0],A=O[1],E=O[2],_=O[3],D=t.data.get(o.dataId).values,P=Object(T.a)(l,4),M=P[0],L=P[1],B=P[2],W=P[3],j=p.padInfo.front,V=p.padInfo.left,z=p.padInfo.top,G=0;G<g;++G)for(var U=Math.max(0,Math.ceil((j-G)/h)),H=Math.min(p.outDepth,(p.inDepth+j-G)/h),X=G*C,q=0;q<b;++q)for(var K=Math.max(0,Math.ceil((z-q)/v)),Y=Math.min(p.outHeight,(p.inHeight+z-q)/v),Q=q*N+X,Z=0;Z<x;++Z)for(var J=Math.max(0,Math.ceil((V-Z)/m)),$=Math.min(p.outWidth,(p.inWidth+V-Z)/m),ee=Z*R+Q,ne=0;ne<p.inChannels;++ne)for(var te=ne*w+ee,ae=0;ae<p.outChannels;++ae){for(var re=0,oe=0;oe<p.batchSize;++oe)for(var ie=oe*M,ce=oe*F,se=U;se<H;++se)for(var ue=(G+se*h-j)*L+ie,le=se*A+ce,de=K;de<Y;++de)for(var pe=(q+de*v-z)*B+ue,he=de*E+le,fe=J;fe<$;++fe){var ve=fe*_+he;re+=D[(Z+fe*m-V)*W+pe+ne]*S[ve+ae]}I[te+ae]=re}return t.makeTensorInfo(k.shape,k.dtype,k.values)}};var en={kernelName:a.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.filter,c=r.pad,s=r.strides,u=r.inputShape;f([o],"conv3dBackpropInputV2");for(var l=a.util.computeStrides(o.shape),d=a.util.computeStrides(i.shape),p=a.backend_util.computeConv3DInfo(u,i.shape,s,1,c),h=new a.TensorBuffer(p.inShape,"float32"),v=h.values,m=Object(T.a)(h.strides,4),g=m[0],b=m[1],x=m[2],k=m[3],I=t.data.get(o.dataId).values,y=Object(T.a)(l,4),C=y[0],N=y[1],R=y[2],w=y[3],S=t.data.get(i.dataId).values,O=Object(T.a)(d,4),F=O[0],A=O[1],E=O[2],_=O[3],D=p.batchSize,P=p.filterDepth,M=p.filterHeight,L=p.filterWidth,B=p.inChannels,W=p.inDepth,j=p.inHeight,V=p.inWidth,z=p.outChannels,G=p.outDepth,U=p.outHeight,H=p.outWidth,X=p.strideDepth,q=p.strideHeight,K=p.strideWidth,Y=P-1-p.padInfo.front,Q=M-1-p.padInfo.top,Z=L-1-p.padInfo.left,J=0;J<D;++J)for(var $=0;$<B;++$)for(var ee=0;ee<W;++ee)for(var ne=ee-Y,te=Math.max(0,Math.ceil(ne/X)),ae=Math.min(G,(P+ne)/X),re=0;re<j;++re)for(var oe=re-Q,ie=Math.max(0,Math.ceil(oe/q)),ce=Math.min(U,(M+oe)/q),se=0;se<V;++se){for(var ue=se-Z,le=Math.max(0,Math.ceil(ue/K)),de=Math.min(H,(L+ue)/K),pe=0,he=te;he<ae;++he)for(var fe=he*X-ne,ve=ie;ve<ce;++ve)for(var me=ve*q-oe,ge=le;ge<de;++ge)for(var be=C*J+N*he+R*ve+w*ge,xe=F*(P-1-fe)+A*(M-1-me)+E*(L-1-(ge*K-ue))+_*$,ke=0;ke<z;++ke){pe+=I[be+ke]*S[xe+ke]}v[g*J+b*ee+x*re+k*se+$]=pe}return t.makeTensorInfo(h.shape,h.dtype,h.values)}},nn=g(a.Cos,(function(e){return Math.cos(e)})),tn={kernelName:a.Cos,backendName:"cpu",kernelFunc:nn},an=g(a.Cosh,(function(e){return Math.cosh(e)})),rn={kernelName:a.Cosh,backendName:"cpu",kernelFunc:an};var on={kernelName:a.CropAndResize,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs,t=e.backend,r=e.attrs,o=n.image,i=n.boxes,c=n.boxInd,s=r.cropSize,u=r.method,l=r.extrapolationValue,d=Object(T.a)(o.shape,4),p=d[0],h=d[1],f=d[2],v=d[3],m=i.shape[0],g=Object(T.a)(s,2),b=g[0],x=g[1],k=Object(a.buffer)([m,b,x,v],"float32"),I=t.data.get(i.dataId).values,y=t.data.get(c.dataId).values,C=t.data.get(o.dataId).values,N=a.util.computeStrides(o.shape),R=a.util.computeStrides(k.shape),w=0;w<m;w++){var S=4*w,O=I[S],F=I[S+1],A=I[S+2],E=I[S+3],_=y[w];if(!(_>=p))for(var D=b>1?(A-O)*(h-1)/(b-1):0,P=x>1?(E-F)*(f-1)/(x-1):0,M=0;M<b;M++){var L=b>1?O*(h-1)+M*D:.5*(O+A)*(h-1);if(L<0||L>h-1)for(var B=0;B<x;B++)for(var W=0;W<v;W++){var j=W+B*R[2]+M*R[1]+w*R[0];k.values[j]=l}else if("bilinear"===u)for(var V=Math.floor(L),z=Math.ceil(L),G=L-V,U=0;U<x;U++){var H=x>1?F*(f-1)+U*P:.5*(F+E)*(f-1);if(H<0||H>f-1)for(var X=0;X<v;X++){var q=X+U*R[2]+M*R[1]+w*R[0];k.values[q]=l}else for(var K=Math.floor(H),Y=Math.ceil(H),Q=H-K,Z=0;Z<v;Z++){var J=Z+K*N[2]+V*N[1]+_*N[0],$=C[J],ee=C[J=Z+Y*N[2]+V*N[1]+_*N[0]],ne=C[J=Z+K*N[2]+z*N[1]+_*N[0]],te=$+(ee-$)*Q,ae=ne+(C[J=Z+Y*N[2]+z*N[1]+_*N[0]]-ne)*Q;J=Z+U*R[2]+M*R[1]+w*R[0],k.values[J]=te+(ae-te)*G}}else for(var re=0;re<x;++re){var oe=x>1?F*(f-1)+re*P:.5*(F+E)*(f-1);if(oe<0||oe>f-1)for(var ie=0;ie<v;ie++){var ce=ie+re*R[2]+M*R[1]+w*R[0];k.values[ce]=l}else for(var se=Math.round(oe),ue=Math.round(L),le=0;le<v;le++){var de=le+se*N[2]+ue*N[1]+_*N[0],pe=le+re*R[2]+M*R[1]+w*R[0];k.values[pe]=C[de]}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}};var cn={kernelName:a.Cumsum,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.exclusive,s=r.reverse;f(o,"cumsum");var u=a.backend_util.getAxesPermutation([i],o.shape.length),l=o;null!=u&&(l=ie({inputs:{x:o},backend:t,attrs:{perm:u}}));var d=a.backend_util.getInnerMostAxes(1,o.shape.length)[0];if(d!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(d));for(var p=Object(a.upcastType)(l.dtype,"int32"),h=a.util.makeZerosTypedArray(a.util.sizeFromShape(l.shape),p),v=t.data.get(l.dataId).values,m=l.shape[l.shape.length-1],g=s?function(e,n){return e+m-n-1}:function(e,n){return e+n},b=0;b<v.length;b+=m)for(var x=0;x<m;x++){var k=g(b,x);if(0===x)h[k]=c?0:v[k];else{var I=g(b,x-1);h[k]=c?v[I]+h[I]:v[k]+h[I]}}var y=t.makeTensorInfo(l.shape,p,h);if(null!=u){var C=ie({inputs:{x:y},backend:t,attrs:{perm:a.backend_util.getUndoAxesPermutation(u)}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(l),C}return y}};var sn={kernelName:a.DenseBincount,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.weights,c=r.size,s=r.binaryOutput;if(1===o.shape.length){var u=Pe(t.data.get(o.dataId).values,t.data.get(i.dataId).values,i.dtype,i.shape,c);return t.makeTensorInfo([c],i.dtype,u)}if(2===o.shape.length){var l=function(e,n,t){for(var r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=e.shape[0],i=e.shape[1],c=Object(a.buffer)([o,t],n.dtype),s=0;s<o;s++)for(var u=0;u<i;u++){var l=e.get(s,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?c.set(1,s,l):n.size>0?c.set(c.get(s,l)+n.get(s,u),s,l):c.set(c.get(s,l)+1,s,l))}return c}(t.bufferSync(o),t.bufferSync(i),c,s);return t.makeTensorInfo(l.shape,i.dtype,l.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(o.shape.length,"."))}};var un={kernelName:a.DepthToSpace,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.blockSize,c=r.dataFormat;a.util.assert("NHWC"===c,(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(c)})),a.util.assert(i>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: ".concat(i)}));for(var s=o.shape[0],u=o.shape[1],l=o.shape[2],d=o.shape[3],p=u*i,h=l*i,f=d/(i*i),v=t.data.get(o.dataId).values,m=new Float32Array(s*p*h*f),g=0,b=0;b<s;++b)for(var x=0;x<p;++x)for(var k=Math.floor(x/i),I=x%i,y=0;y<h;++y)for(var C=Math.floor(y/i),N=(I*i+y%i)*f,T=0;T<f;++T){var R=T+N+d*(C+l*(k+u*b));m[g++]=v[R]}return t.makeTensorInfo([s,p,h,f],o.dtype,m)}};function ln(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=r.strides,s=r.pad,u=r.dilations,l=r.dimRoundingMode;f([o,i],"depthwiseConv2DNative");var d=a.util.computeStrides(o.shape),p=a.util.computeStrides(i.shape),h=u;null==h&&(h=[1,1]),a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(c,h),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(h,"'")}));for(var v=a.backend_util.computeConv2DInfo(o.shape,i.shape,c,h,s,l,!0),m=v.filterHeight,g=v.filterWidth,b=v.dilationHeight,x=v.dilationWidth,k=v.padInfo,I=k.left,y=k.top,C=v.outChannels/v.inChannels,N=new a.TensorBuffer(v.outShape,o.dtype),T=t.data.get(o.dataId).values,R=t.data.get(i.dataId).values,w=N.values,S=0;S<v.batchSize;++S)for(var O=S*d[0],F=S*N.strides[0],A=0;A<v.outHeight;++A)for(var E=F+A*N.strides[1],_=A*v.strideHeight-I,D=0;D<m;++D){var P=_+D*b;if(!(P<0||P>=v.inHeight))for(var M=D*p[0],L=O+P*d[1],B=0;B<v.outWidth;++B)for(var W=E+B*N.strides[2],j=B*v.strideWidth-y,V=0;V<g;++V){var z=j+V*x;if(!(z<0||z>=v.inWidth))for(var G=M+V*p[1],U=L+z*v.inChannels,H=W,X=G,q=0;q<v.inChannels;++q){for(var K=T[U+q],Y=0;Y<C;++Y)w[H+Y]+=K*R[X+Y];H+=C,X+=C}}}return t.makeTensorInfo(N.shape,N.dtype,N.values)}var dn={kernelName:a.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:ln};var pn={kernelName:a.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.dy,c=r.strides,s=r.dilations,u=r.pad,l=r.dimRoundingMode,d=r.filterShape;f([o,i],"depthwiseConv2dNativeBackpropFilter");for(var p=a.backend_util.computeConv2DInfo(o.shape,d,c,s,u,l,!0),h=p.strideHeight,v=p.strideWidth,m=p.filterHeight,g=p.filterWidth,b=new a.TensorBuffer(p.filterShape,"float32"),x=p.padInfo.left,k=p.padInfo.top,I=p.outChannels/p.inChannels,y=t.data.get(o.dataId).values,C=new a.TensorBuffer(o.shape,o.dtype,y),N=t.data.get(i.dataId).values,T=new a.TensorBuffer(i.shape,i.dtype,N),R=0;R<m;++R)for(var w=Math.max(0,Math.ceil((k-R)/h)),S=Math.min(p.outHeight,(p.inHeight+k-R)/h),O=0;O<g;++O)for(var F=Math.max(0,Math.ceil((x-O)/v)),A=Math.min(p.outWidth,(p.inWidth+x-O)/v),E=0;E<p.outChannels;++E){for(var _=Math.trunc(E/I),D=E%I,P=0,M=0;M<p.batchSize;++M)for(var L=w;L<S;++L)for(var B=R+L*h-k,W=F;W<A;++W){var j=O+W*v-x;P+=C.get(M,B,j,_)*T.get(M,L,W,E)}b.set(P,R,O,_,D)}return t.makeTensorInfo(b.shape,b.dtype,b.values)}};var hn={kernelName:a.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.filter,c=r.strides,s=r.dilations,u=r.pad,l=r.dimRoundingMode,d=r.inputShape;f([o,i],"depthwiseConv2DNativeBackpropInput");for(var p=a.util.computeStrides(o.shape),h=a.util.computeStrides(i.shape),v=a.backend_util.computeConv2DInfo(d,i.shape,c,s,u,l,!0),m=new a.TensorBuffer(v.inShape,"float32"),g=m.values,b=Object(T.a)(m.strides,3),x=b[0],k=b[1],I=b[2],y=t.data.get(o.dataId).values,C=Object(T.a)(p,3),N=C[0],R=C[1],w=C[2],S=t.data.get(i.dataId).values,O=Object(T.a)(h,3),F=O[0],A=O[1],E=O[2],_=v.batchSize,D=v.filterHeight,P=v.filterWidth,M=v.inChannels,L=v.inHeight,B=v.inWidth,W=v.outChannels,j=v.outHeight,V=v.outWidth,z=v.strideHeight,G=v.strideWidth,U=D-1-v.padInfo.top,H=P-1-v.padInfo.left,X=W/M,q=0;q<_;++q)for(var K=0;K<M;++K)for(var Y=0;Y<L;++Y)for(var Q=Y-U,Z=Math.max(0,Math.ceil(Q/z)),J=Math.min(j,(D+Q)/z),$=0;$<B;++$){for(var ee=$-H,ne=Math.max(0,Math.ceil(ee/G)),te=Math.min(V,(P+ee)/G),ae=0,re=Z;re<J;++re)for(var oe=re*z-Q,ie=ne;ie<te;++ie)for(var ce=N*q+R*re+w*ie,se=F*(D-1-oe)+A*(P-1-(ie*G-ee))+E*K,ue=0;ue<X;++ue){ae+=y[ce+(K*X+ue)]*S[se+ue]}g[x*q+k*Y+I*$+K]=ae}return t.makeTensorInfo(m.shape,m.dtype,m.values)}};var fn={kernelName:a.Diag,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs,t=e.backend,r=n.x,o=a.util.sizeFromShape(r.shape),i=t.data.get(r.dataId).values,c=Object(a.buffer)([o,o],r.dtype),s=c.values,u=0;u<i.length;u++)s[u*o+u]=i[u];var l=[].concat(Object(Ae.a)(r.shape),Object(Ae.a)(r.shape));return t.makeTensorInfo(l,c.dtype,c.values)}},vn={kernelName:a.Dilation2D,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=r.strides,s=r.pad,u=r.dilations,l=t,d=l.data.get(o.dataId).values,p=o.shape.length,h=l.data.get(i.dataId).values,f=i.shape.length,v=a.backend_util.computeDilation2DInfo(o.shape,i.shape,c,s,"NHWC",u),m=v.batchSize,g=v.inHeight,b=v.inWidth,x=v.inChannels,k=v.outHeight,I=v.outWidth,y=v.padInfo,C=v.strideHeight,N=v.strideWidth,T=v.filterHeight,R=v.filterWidth,w=v.dilationHeight,S=v.dilationWidth,O=v.outShape,F=a.util.sizeFromShape(O),A=O.length,E=a.util.getArrayFromDType(o.dtype,F),_=0;_<m;++_)for(var D=0;D<k;++D)for(var P=D*C-y.top,M=0;M<I;++M)for(var L=M*N-y.left,B=0;B<x;++B){for(var W=Number.MIN_SAFE_INTEGER,j=0;j<T;++j){var V=P+j*w;if(V>=0&&V<g)for(var z=0;z<R;++z){var G=L+z*S;if(G>=0&&G<b){var U=a.util.locToIndex([_,V,G,B],p,a.util.computeStrides(o.shape)),H=a.util.locToIndex([j,z,B],f,a.util.computeStrides(i.shape)),X=d[U]+h[H];X>W&&(W=X)}}}E[a.util.locToIndex([_,D,M,B],A,a.util.computeStrides(O))]=W}return{dataId:l.write(a.util.toTypedArray(E,o.dtype),O,o.dtype),shape:O,dtype:o.dtype}}},mn={kernelName:a.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=n.dy,s=r.strides,u=r.pad,l=r.dilations,d=t,p=a.util.toNestedArray(o.shape,d.data.get(o.dataId).values),h=a.util.toNestedArray(i.shape,d.data.get(i.dataId).values),f=a.backend_util.computeDilation2DInfo(o.shape,i.shape,s,u,"NHWC",l),v=f.batchSize,m=f.inHeight,g=f.inWidth,b=f.inChannels,x=f.outHeight,k=f.outWidth,I=f.padInfo,y=f.strideHeight,C=f.strideWidth,N=f.filterHeight,T=f.filterWidth,R=f.dilationHeight,w=f.dilationWidth,S=f.outShape;a.util.assert(c.rank===S.length,(function(){return"Error in ".concat(a.Dilation2DBackpropFilter,", dy ")+"must have the same rank as output ".concat(S.length,", but got ")+"".concat(c.rank)}));for(var O=a.util.toNestedArray(S,d.data.get(c.dataId).values),F=a.util.makeZerosNestedTypedArray(i.shape,i.dtype),A=0;A<v;++A)for(var E=0;E<x;++E)for(var _=E*y-I.top,D=0;D<k;++D)for(var P=D*C-I.left,M=0;M<b;++M){for(var L=Number.MIN_SAFE_INTEGER,B=0,W=0,j=0;j<N;++j){var V=_+j*R;if(V>=0&&V<m)for(var z=0;z<T;++z){var G=P+z*w;if(G>=0&&G<g){var U=p[A][V][G][M]+h[j][z][M];U>L&&(L=U,B=j,W=z)}}}F[B][W][M]+=O[A][E][D][M]}return{dataId:d.write(a.util.toTypedArray(F,o.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},gn={kernelName:a.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.filter,c=n.dy,s=r.strides,u=r.pad,l=r.dilations,d=t,p=a.util.toNestedArray(o.shape,d.data.get(o.dataId).values),h=a.util.toNestedArray(i.shape,d.data.get(i.dataId).values),f=a.backend_util.computeDilation2DInfo(o.shape,i.shape,s,u,"NHWC",l),v=f.batchSize,m=f.inHeight,g=f.inWidth,b=f.inChannels,x=f.outHeight,k=f.outWidth,I=f.padInfo,y=f.strideHeight,C=f.strideWidth,N=f.filterHeight,T=f.filterWidth,R=f.dilationHeight,w=f.dilationWidth,S=f.outShape;a.util.assert(c.rank===S.length,(function(){return"Error in ".concat(a.Dilation2DBackpropInput,", dy ")+"must have the same rank as output ".concat(S.length,", but got ")+"".concat(c.rank)}));for(var O=a.util.toNestedArray(S,d.data.get(c.dataId).values),F=a.util.makeZerosNestedTypedArray(o.shape,o.dtype),A=0;A<v;++A)for(var E=0;E<x;++E)for(var _=E*y-I.top,D=0;D<k;++D)for(var P=D*C-I.left,M=0;M<b;++M){for(var L=Number.MIN_SAFE_INTEGER,B=_<0?0:_,W=P<0?0:P,j=0;j<N;++j){var V=_+j*R;if(V>=0&&V<m)for(var z=0;z<T;++z){var G=P+z*w;if(G>=0&&G<g){var U=p[A][V][G][M]+h[j][z][M];U>L&&(L=U,B=V,W=G)}}}F[A][B][W][M]+=O[A][E][D][M]}return{dataId:d.write(a.util.toTypedArray(F,o.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var bn={kernelName:a.EluGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.dy,o=n.y;f([r,o],"eluGrad");for(var i=new Float32Array(a.util.sizeFromShape(o.shape)),c=t.data.get(o.dataId).values,s=t.data.get(r.dataId).values,u=0;u<c.length;++u){var l=c[u];i[u]=l>=1?s[u]:s[u]*(l+1)}return t.makeTensorInfo(o.shape,"float32",i)}},xn=R((function(e,n){return e===n?1:0})),kn=z(a.Equal,xn,null,"bool"),In={kernelName:a.Equal,backendName:"cpu",kernelFunc:kn},yn=a.backend_util.ERF_P,Cn=a.backend_util.ERF_A1,Nn=a.backend_util.ERF_A2,Tn=a.backend_util.ERF_A3,Rn=a.backend_util.ERF_A4,wn=a.backend_util.ERF_A5,Sn=g(a.Erf,(function(e){var n=Math.sign(e),t=Math.abs(e),a=1/(1+yn*t);return n*(1-((((wn*a+Rn)*a+Tn)*a+Nn)*a+Cn)*a*Math.exp(-t*t))})),On={kernelName:a.Erf,backendName:"cpu",kernelFunc:Sn},Fn=Le((function(e){return Math.exp(e)})),An=b(a.Exp,Fn),En={kernelName:a.Exp,backendName:"cpu",kernelFunc:An};function _n(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.input,i=r.dim,c=o.shape.length,s=o.shape.slice(),u=i;return i<0&&(a.util.assert(-(c+1)<=i,(function(){return"Axis must be in the interval [".concat(-(c+1),", ").concat(c,"]")})),u=c+i+1),s.splice(u,0,1),K({inputs:{x:o},backend:t,attrs:{shape:s}})}var Dn={kernelName:a.ExpandDims,backendName:"cpu",kernelFunc:_n},Pn=Le((function(e){return Math.expm1(e)})),Mn=b(a.Expm1,Pn),Ln={kernelName:a.Expm1,backendName:"cpu",kernelFunc:Mn},Bn=R((function(e,n){return e*n})),Wn=G((function(e,n,t,a){return{real:e*t-n*a,imag:e*a+n*t}})),jn=z(a.Multiply,Bn,Wn),Vn={kernelName:a.Multiply,backendName:"cpu",kernelFunc:jn},zn=R((function(e,n){return e/n})),Gn=z(a.RealDiv,zn),Un={kernelName:a.RealDiv,backendName:"cpu",kernelFunc:Gn},Hn=R((function(e,n){return e-n})),Xn=G((function(e,n,t,a){return{real:e-t,imag:n-a}})),qn=z(a.Sub,Hn,Xn),Kn={kernelName:a.Sub,backendName:"cpu",kernelFunc:qn};function Yn(e,n,t){for(var r=e.shape,o=r[0],i=r[1],c=t.data.get(e.dataId),s=c.complexTensorInfos.real,u=c.complexTensorInfos.imag,l=[o,i],d=a.util.sizeFromShape(l),p=a.util.getTypedArrayFromDType("float32",d),h=a.util.getTypedArrayFromDType("float32",d),f=0;f<o;f++){for(var v=Ee({inputs:{x:s},backend:t,attrs:{begin:[f,0],size:[1,i]}}),m=Ee({inputs:{x:u},backend:t,attrs:{begin:[f,0],size:[1,i]}}),g=P({inputs:{real:v,imag:m},backend:t}),b=Qn(g,n,t),x=b.real,k=b.imag,I=a.backend_util.mergeRealAndImagArrays(x,k),y=0;y<i;y++){var C=a.backend_util.getComplexWithIndex(I,y);p[f*i+y]=C.real,h[f*i+y]=C.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g)}var N=t.makeTensorInfo(l,"float32",p),T=t.makeTensorInfo(l,"float32",h),R=P({inputs:{real:N,imag:T},backend:t});return t.disposeIntermediateTensorInfo(N),t.disposeIntermediateTensorInfo(T),R}function Qn(e,n,t){var r=a.util.sizeFromShape(e.shape),o=t.data.get(e.dataId),i=t.data.get(o.complexTensorInfos.real.dataId).values,c=t.data.get(o.complexTensorInfos.imag.dataId).values;if(0===((b=r)&b-1)){var s=Zn(i,c,r,n,t),u=[e.shape[0],e.shape[1]];if(n){var l=t.makeTensorInfo(u,"float32",s.real),d=t.makeTensorInfo(u,"float32",s.imag),p=t.makeTensorInfo([],"float32",a.util.createScalarValue(r,"float32")),h=I({inputs:{x:p},backend:t}),f=Un.kernelFunc({inputs:{a:l,b:p},backend:t}),v=Un.kernelFunc({inputs:{a:d,b:h},backend:t}),m=t.data.get(f.dataId).values,g=t.data.get(v.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(v),{real:m,imag:g}}return s}var b,x=function(e,n,t){for(var r=new Float32Array(2*n),o=0;o<n;o++){for(var i=0,c=0,s=0;s<n;s++){var u=a.backend_util.exponent(o*s,n,t),l=a.backend_util.getComplexWithIndex(e,s);i+=l.real*u.real-l.imag*u.imag,c+=l.real*u.imag+l.imag*u.real}t&&(i/=n,c/=n),a.backend_util.assignToTypedArray(r,i,c,o)}return r}(a.backend_util.mergeRealAndImagArrays(i,c),r,n);return a.backend_util.splitRealAndImagArrays(x)}function Zn(e,n,t,r,o){if(1===t)return{real:e,imag:n};var i=a.backend_util.mergeRealAndImagArrays(e,n),c=t/2,s=a.backend_util.complexWithEvenIndex(i),u=s.real,l=s.imag,d=[u.length],p=o.makeTensorInfo(d,"float32",u),h=o.makeTensorInfo(d,"float32",l),f=P({inputs:{real:p,imag:h},backend:o}),v=a.backend_util.complexWithOddIndex(i),m=v.real,g=v.imag,b=[m.length],x=o.makeTensorInfo(b,"float32",m),k=o.makeTensorInfo(b,"float32",g),I=P({inputs:{real:x,imag:k},backend:o}),y=Zn(u,l,c,r,o),C=y.real,N=y.imag,T=[C.length],R=o.makeTensorInfo(T,"float32",C),w=o.makeTensorInfo(T,"float32",N),S=P({inputs:{real:R,imag:w},backend:o}),O=Zn(m,g,c,r,o),F=O.real,A=O.imag,E=[F.length],_=o.makeTensorInfo(E,"float32",F),D=o.makeTensorInfo(E,"float32",A),M=P({inputs:{real:_,imag:D},backend:o}),L=a.backend_util.exponents(t,r),W=[L.real.length],j=o.makeTensorInfo(W,"float32",L.real),V=o.makeTensorInfo(W,"float32",L.imag),z=P({inputs:{real:j,imag:V},backend:o}),G=jn({inputs:{a:z,b:M},backend:o}),U=X({inputs:{a:S,b:G},backend:o}),H=qn({inputs:{a:S,b:G},backend:o}),q=B({inputs:{input:U},backend:o}),K=B({inputs:{input:H},backend:o}),Y=Ue({inputs:{input:U},backend:o}),Q=Ue({inputs:{input:H},backend:o}),Z=Xe({inputs:[q,K],backend:o,attrs:{axis:0}}),J=Xe({inputs:[Y,Q],backend:o,attrs:{axis:0}}),$=o.data.get(Z.dataId).values,ee=o.data.get(J.dataId).values;return o.disposeIntermediateTensorInfo(p),o.disposeIntermediateTensorInfo(h),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(w),o.disposeIntermediateTensorInfo(S),o.disposeIntermediateTensorInfo(_),o.disposeIntermediateTensorInfo(D),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(G),o.disposeIntermediateTensorInfo(U),o.disposeIntermediateTensorInfo(H),o.disposeIntermediateTensorInfo(q),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(K),o.disposeIntermediateTensorInfo(Q),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(J),{real:$,imag:ee}}var Jn={kernelName:a.FFT,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.input,o=a.util.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],c=K({inputs:{x:r},backend:t,attrs:{shape:[o/i,i]}}),s=Yn(c,!1,t),u=K({inputs:{x:s},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(s),u}};function $n(e){var n=e.backend,t=e.attrs,r=t.shape,o=t.value,i=t.dtype||a.util.inferDtype(o),c=a.util.getArrayFromDType(i,a.util.sizeFromShape(r));return function(e,n,t){e.fill(n)}(c,o),n.makeTensorInfo(r,i,c)}var et={kernelName:a.Fill,backendName:"cpu",kernelFunc:$n};var nt={kernelName:a.FlipLeftRight,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs,t=(e.attrs,e.backend),r=n.image,o=t,i=a.util.getTypedArrayFromDType(r.dtype,a.util.sizeFromShape(r.shape)),c=Object(T.a)(r.shape,4),s=c[0],u=c[1],l=c[2],d=c[3],p=o.data.get(r.dataId).values,h=0;h<s;h++)for(var f=h*l*u*d,v=0;v<u;v++)for(var m=v*(l*d),g=0;g<l;g++)for(var b=g*d,x=0;x<d;x++){var k=[s,v,g,x][2],I=Math.round(l-k),y=f+m+b+x,C=p[y];if(I>=0&&I<l)C=p[f+m+I*d+x];i[y]=C}return{dataId:o.write(i,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},tt=Le((function(e){return Math.floor(e)})),at=b(a.Floor,tt),rt={kernelName:a.Floor,backendName:"cpu",kernelFunc:at},ot=R((function(e,n){return Math.floor(e/n)})),it=z(a.FloorDiv,ot,null,"int32"),ct={kernelName:a.FloorDiv,backendName:"cpu",kernelFunc:it};var st={kernelName:a.FusedConv2D,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,i=n.bias,c=n.preluActivationWeights,s=a.strides,u=a.pad,l=a.dataFormat,d=a.dilations,p=a.dimRoundingMode,h=a.activation,f=a.leakyreluAlpha,v=Ke({inputs:{x:r,filter:o},backend:t,attrs:{strides:s,pad:u,dataFormat:l,dilations:d,dimRoundingMode:p}});if(i){var m=v;v=X({inputs:{a:v,b:i},backend:t}),t.disposeIntermediateTensorInfo(m)}if(h){var g=v;v=D(t,v,h,c,f),t.disposeIntermediateTensorInfo(g)}return v}};var ut={kernelName:a.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.x,o=n.filter,i=n.bias,c=n.preluActivationWeights,s=a.strides,u=a.pad,l=a.dataFormat,d=a.dilations,p=a.dimRoundingMode,h=a.activation,f=a.leakyreluAlpha,v=ln({inputs:{x:r,filter:o},backend:t,attrs:{strides:s,pad:u,dataFormat:l,dilations:d,dimRoundingMode:p}});if(i){var m=v;v=X({inputs:{a:v,b:i},backend:t}),t.disposeIntermediateTensorInfo(m)}if(h){var g=v;v=D(t,v,h,c,f),t.disposeIntermediateTensorInfo(g)}return v}};var lt={kernelName:a.GatherNd,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.params,o=n.indices,i=a.util.sizeFromShape(r.shape),c=o.shape,s=c[c.length-1],u=a.backend_util.prepareAndValidate(r,o),l=Object(T.a)(u,4),d=l[0],p=l[1],h=l[2],f=l[3];if(0===p)return t.makeTensorInfo(d,r.dtype,[]);for(var v=Object(a.buffer)([p,h],r.dtype),m=t.data.get(o.dataId).values,g=t.data.get(r.dataId).values,b=0;b<p;b++){for(var x=[],k=0,I=0;I<s;I++){var y=m[b*s+I];k+=y*f[I],x.push(y)}if(k<0||k>=i/h)throw new Error("Invalid indices: ".concat(x," does not index into ").concat(r.shape));for(var C=0;C<h;C++)v.values[b*h+C]=g[k*h+C]}return t.makeTensorInfo(d,v.dtype,v.values)}};var dt={kernelName:a.GatherV2,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.indices,c=r.axis,s=r.batchDims;f([o,i],"gatherV2");var u=s;null==s&&(u=0);var l=a.util.sizeFromShape(i.shape),d=a.util.parseAxisParam(c,o.shape)[0],p=a.backend_util.segment_util.collectGatherOpShapeInfo(o,i,d,u),h=K({inputs:{x:o},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),v=K({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,l/p.batchSize]}}),m=[p.batchSize,p.outerSize,l/p.batchSize,p.sliceSize],g=t.bufferSync(v),b=function(e,n,t){for(var r=Object(a.buffer)(t,e.dtype),o=0;o<r.size;++o){var i=r.indexToLoc(o).slice(),c=i[0],s=i[2],u=n.locToIndex([c,s]);i[2]=n.values[u];var l=e.locToIndex(i);r.values[o]=e.values[l]}return r}(t.bufferSync(h),g,m);return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(v),t.makeTensorInfo(p.outputShape,b.dtype,b.values)}},pt=R((function(e,n){return e>n?1:0})),ht=z(a.Greater,pt,null,"bool"),ft={kernelName:a.Greater,backendName:"cpu",kernelFunc:ht},vt=R((function(e,n){return e>=n?1:0})),mt=z(a.GreaterEqual,vt,null,"bool"),gt={kernelName:a.GreaterEqual,backendName:"cpu",kernelFunc:mt};var bt={kernelName:a.IFFT,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.input,o=a.util.sizeFromShape(r.shape),i=r.shape[r.shape.length-1],c=K({inputs:{x:r},backend:t,attrs:{shape:[o/i,i]}}),s=Yn(c,!0,t),u=K({inputs:{x:s},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(s),u}},xt=g(a.IsFinite,(function(e){return Number.isFinite(e)?1:0}),"bool"),kt={kernelName:a.IsFinite,backendName:"cpu",kernelFunc:xt},It=g(a.IsInf,(function(e){return Math.abs(e)===1/0?1:0}),"bool"),yt={kernelName:a.IsInf,backendName:"cpu",kernelFunc:It},Ct=g(a.IsNan,(function(e){return Number.isNaN(e)?1:0}),"bool"),Nt={kernelName:a.IsNan,backendName:"cpu",kernelFunc:Ct},Tt=R((function(e,n){return e<n?1:0})),Rt=z(a.Less,Tt,null,"bool"),wt={kernelName:a.Less,backendName:"cpu",kernelFunc:Rt},St=R((function(e,n){return e<=n?1:0})),Ot=z(a.LessEqual,St,null,"bool"),Ft={kernelName:a.LessEqual,backendName:"cpu",kernelFunc:Ot};var At={kernelName:a.LinSpace,backendName:"cpu",kernelFunc:function(e){var n=e.backend,t=e.attrs,r=function(e,n,t){var r=(n-e)/(t-1),o=a.util.makeZerosTypedArray(t,"float32");o[0]=e;for(var i=1;i<o.length;i++)o[i]=o[i-1]+r;return o}(t.start,t.stop,t.num);return n.makeTensorInfo([r.length],"float32",r)}},Et=Le((function(e){return Math.log(e)})),_t=b(a.Log,Et),Dt={kernelName:a.Log,backendName:"cpu",kernelFunc:_t},Pt=g(a.Log1p,(function(e){return Math.log1p(e)})),Mt={kernelName:a.Log1p,backendName:"cpu",kernelFunc:Pt},Lt=R((function(e,n){return e&&n})),Bt=z(a.LogicalAnd,Lt,null,"bool"),Wt={kernelName:a.LogicalAnd,backendName:"cpu",kernelFunc:Bt},jt=g(a.LogicalNot,(function(e){return e?0:1}),"bool"),Vt={kernelName:a.LogicalNot,backendName:"cpu",kernelFunc:jt},zt=R((function(e,n){return e||n})),Gt=z(a.LogicalOr,zt,null,"bool"),Ut={kernelName:a.LogicalOr,backendName:"cpu",kernelFunc:Gt};var Ht={kernelName:a.LRN,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.depthRadius,c=r.bias,s=r.alpha,u=r.beta;f(o,"LRN");var l=o.shape[3],d=l-1,p=t.data.get(o.dataId).values,h=a.util.sizeFromShape(o.shape),v=new Float32Array(h);function m(e){for(var n=e%l,t=e-n+Math.max(0,n-i),a=e-n+Math.min(n+i,d),r=0;t<=a;t++){var o=p[t];r+=o*o}return r}for(var g=0;g<h;g++){var b=m(g),x=p[g]*Math.pow(c+s*b,-u);v[g]=x}return t.makeTensorInfo(o.shape,o.dtype,v)}};var Xt={kernelName:a.LRNGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.y,c=n.dy,s=r.depthRadius,u=r.bias,l=r.alpha,d=r.beta;f(c,"LRNGrad");for(var p=a.util.sizeFromShape(c.shape),h=c.shape[3],v=t.data.get(c.dataId).values,m=t.data.get(o.dataId).values,g=t.data.get(i.dataId).values,b=new Float32Array(p),x=p,k=0;k<x;k++){for(var I=k%h,y=k-I+Math.max(0,I-s),C=k-I+Math.min(h,I+s+1),N=0,T=y;T<C;T++)N+=Math.pow(m[T],2);N=l*N+u;for(var R=y;R<C;R++){var w=-2*l*d*m[R]*g[k]/N;k===R&&(w+=Math.pow(N,-d)),w*=v[k],b[R]+=w}}return t.makeTensorInfo(c.shape,o.dtype,b)}};function qt(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.reductionIndices,c=r.keepDims,s=t,u=o.shape,l=u.length,d=a.util.parseAxisParam(i,u),p=d,h=a.backend_util.getAxesPermutation(p,l),v=s.data.get(o.dataId).values;if(null!=h){for(var m=new Array(l),g=0;g<m.length;g++)m[g]=u[h[g]];v=oe(v,u,o.dtype,h,m),p=a.backend_util.getInnerMostAxes(p.length,l),u=m}f(o,"max"),a.backend_util.assertAxesAreInnerMostDims("max",p,l);var b=a.backend_util.computeOutAndReduceShapes(u,p),x=Object(T.a)(b,2),k=x[0],I=x[1],y=function(e,n,t,r){for(var o=a.util.getTypedArrayFromDType(r,a.util.sizeFromShape(t)),i=0;i<o.length;++i){for(var c=i*n,s=e[c],u=0;u<n;++u){var l=e[c+u];l>s&&(s=l)}o[i]=s}return o}(v,a.util.sizeFromShape(I),k,o.dtype),C=s.write(y,k,o.dtype),N=k;c&&(N=a.backend_util.expandShapeToKeepDim(k,d));return{dataId:C,shape:N,dtype:o.dtype}}var Kt={kernelName:a.Max,backendName:"cpu",kernelFunc:qt},Yt=R((function(e,n){return Math.max(e,n)})),Qt=z(a.Maximum,Yt),Zt={kernelName:a.Maximum,backendName:"cpu",kernelFunc:Qt};var Jt={kernelName:a.MaxPool,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x;f(o,"maxPool");var i=r.filterSize,c=r.strides,s=r.pad,u=r.dimRoundingMode;a.util.assert(a.backend_util.eitherStridesOrDilationsAreOne(c,1),(function(){return"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(c," and dilations '").concat(1,"'")}));var l,d=a.backend_util.computePool2DInfo(o.shape,i,c,1,s,u);if(1===d.filterWidth&&1===d.filterHeight&&a.util.arraysEqual(d.inShape,d.outShape))l=I({inputs:{x:o},backend:t});else{var p=t.data.get(o.dataId).values,h=a.util.computeStrides(o.shape),v=Ce(p,o.shape,o.dtype,h,d,"max");l=t.makeTensorInfo(d.outShape,o.dtype,v.values)}return l}};var $t={kernelName:a.MaxPool3D,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.filterSize,c=r.strides,s=r.pad,u=r.dimRoundingMode,l=r.dataFormat;f(o,"maxPool3d");var d=a.backend_util.computePool3DInfo(o.shape,i,c,1,s,u,l),p=Te(t.data.get(o.dataId).values,o.shape,o.dtype,a.util.computeStrides(o.shape),d,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}};var ea={kernelName:a.MaxPool3DGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.input,c=r.filterSize,s=r.strides,u=r.pad,l=r.dimRoundingMode;f([o,i],"maxPool3DGrad");for(var d=a.backend_util.computePool3DInfo(i.shape,c,s,1,u,l),p=function(e,n){for(var t=Object(a.buffer)(n.outShape,"int32"),r=n.strideDepth,o=n.strideHeight,i=n.strideWidth,c=n.dilationDepth,s=n.dilationHeight,u=n.dilationWidth,l=n.effectiveFilterDepth,d=n.effectiveFilterHeight,p=n.effectiveFilterWidth,h=n.padInfo.front,f=n.padInfo.top,v=n.padInfo.left,m=0;m<n.batchSize;++m)for(var g=0;g<n.inChannels;++g)for(var b=0;b<n.outDepth;++b){for(var x=b*r-h,k=x;k<0;)k+=c;for(var I=Math.min(n.inDepth,l+x),y=0;y<n.outHeight;++y){for(var C=y*o-f,N=C;N<0;)N+=s;for(var T=Math.min(n.inHeight,d+C),R=0;R<n.outWidth;++R){for(var w=R*i-v,S=w;S<0;)S+=u;for(var O=Math.min(n.inWidth,p+w),F=Number.NEGATIVE_INFINITY,A=-1,E=k;E<I;E+=c)for(var _=E-x,D=N;D<T;D+=s)for(var P=D-C,M=S;M<O;M+=u){var L=M-w,B=e.get(m,E,D,M,g);B>=F&&(F=B,A=_*d*p+P*d+L)}t.set(A,m,b,y,R,g)}}}return t}(t.bufferSync(i),d),h=d.strideDepth,v=d.strideHeight,m=d.strideWidth,g=d.dilationDepth,b=d.dilationHeight,x=d.dilationWidth,k=d.effectiveFilterDepth,I=d.effectiveFilterHeight,y=d.effectiveFilterWidth,C=k-1-d.padInfo.front,N=y-1-d.padInfo.left,T=I-1-d.padInfo.top,R=Object(a.buffer)(i.shape,"float32"),w=t.bufferSync(o),S=0;S<d.batchSize;++S)for(var O=0;O<d.inChannels;++O)for(var F=0;F<d.inDepth;++F)for(var A=0;A<d.inHeight;++A)for(var E=0;E<d.inWidth;++E){for(var _=F-C,D=A-T,P=E-N,M=0,L=0;L<k;L+=g){var B=(_+L)/h;if(!(B<0||B>=d.outDepth||Math.floor(B)!==B))for(var W=0;W<I;W+=b){var j=(D+W)/v;if(!(j<0||j>=d.outHeight||Math.floor(j)!==j))for(var V=0;V<y;V+=x){var z=(P+V)/m;if(!(z<0||z>=d.outWidth||Math.floor(z)!==z)){var G=k*I*y-1-p.get(S,B,j,z,O)===L*I*y+W*y+V?1:0;if(0!==G)M+=w.get(S,B,j,z,O)*G}}}}R.set(M,S,F,A,E,O)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}};var na={kernelName:a.MaxPoolGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.dy,i=n.input,c=i;f([i,n.output],"maxPoolGrad");for(var s=r.filterSize,u=r.strides,l=r.pad,d=r.dimRoundingMode,p=a.backend_util.computePool2DInfo(c.shape,s,u,1,l,d),h=t.data.get(c.dataId).values,v=Object(a.buffer)(p.outShape,c.dtype,Ne(h,c.shape,c.dtype,p).values),m=p.strideHeight,g=p.strideWidth,b=p.dilationHeight,x=p.dilationWidth,k=p.effectiveFilterHeight,I=p.effectiveFilterWidth,y=I-1-p.padInfo.left,C=k-1-p.padInfo.top,N=Object(a.buffer)(c.shape,"float32"),T=t.data.get(o.dataId).values,R=Object(a.buffer)(o.shape,"float32",T),w=0;w<p.batchSize;++w)for(var S=0;S<p.inChannels;++S)for(var O=0;O<p.inHeight;++O)for(var F=0;F<p.inWidth;++F){for(var A=O-C,E=F-y,_=0,D=0;D<k;D+=b){var P=(A+D)/m;if(!(P<0||P>=p.outHeight||Math.floor(P)!==P))for(var M=0;M<I;M+=x){var L=(E+M)/g;if(!(L<0||L>=p.outWidth||Math.floor(L)!==L)){var B=k*I-1-v.get(w,P,L,S)===D*I+M?1:0;if(0!==B)_+=R.get(w,P,L,S)*B}}}N.set(_,w,O,F,S)}return t.makeTensorInfo(N.shape,N.dtype,N.values)}};var ta={kernelName:a.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.attrs,r=e.backend,o=n.x,i=t.filterSize,c=t.strides,s=t.pad,u=t.includeBatchInIndex,l=r;f(o,"MaxPoolWithArgmax");var d=l.data.get(o.dataId).values,p=a.backend_util.computePool2DInfo(o.shape,i,c,[1,1],s),h=function(e,n,t,r,o){var i=Ce(e,0,t,a.util.computeStrides(n),o,"max"),c=Ne(e,n,t,o,!0,r);return[i.values,c.values]}(d,o.shape,o.dtype,u,p),v=Object(T.a)(h,2),m=v[0],g=v[1],b=l.write(m,p.outShape,o.dtype),x=l.write(g,p.outShape,o.dtype);return[{dataId:b,shape:p.outShape,dtype:o.dtype},{dataId:x,shape:p.outShape,dtype:"int32"}]}};function aa(e){var n,t=e.inputs,r=e.backend,o=e.attrs,i=t.x,c=o.axis,s=o.keepDims;f(i,"sum");var u=(n="bool"===i.dtype?j({inputs:{x:i},backend:r,attrs:{dtype:"int32"}}):I({inputs:{x:i},backend:r})).shape.length,l=a.util.parseAxisParam(c,n.shape),d=a.backend_util.getAxesPermutation(l,u),p=l,h=n;null!=d&&(h=ie({inputs:{x:n},backend:r,attrs:{perm:d}}),p=a.backend_util.getInnerMostAxes(p.length,u)),a.backend_util.assertAxesAreInnerMostDims("sum",p,h.shape.length);for(var v=a.backend_util.computeOutAndReduceShapes(h.shape,p),m=Object(T.a)(v,2),g=m[0],b=m[1],x=L(r,g,a.backend_util.upcastType(h.dtype,"int32")),k=a.util.sizeFromShape(b),y=r.data.get(x.dataId).values,C=r.data.get(h.dataId).values,N=0;N<y.length;++N){for(var R=N*k,w=0,S=0;S<k;++S)w+=C[R+S];y[N]=w}if(s){var O=x;x=K({inputs:{x:x},backend:r,attrs:{shape:a.backend_util.expandShapeToKeepDim(x.shape,l)}}),r.disposeIntermediateTensorInfo(O)}return r.disposeIntermediateTensorInfo(n),null!=d&&r.disposeIntermediateTensorInfo(h),x}var ra={kernelName:a.Sum,backendName:"cpu",kernelFunc:aa};var oa={kernelName:a.Mean,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.keepDims,s=a.util.parseAxisParam(i,o.shape),u=a.backend_util.computeOutAndReduceShapes(o.shape,s)[1],l=a.util.sizeFromShape(u),d=[],p=t.makeTensorInfo([],"float32",new Float32Array([l]));d.push(p);var h=j({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});d.push(h);var f=Gn({inputs:{a:h,b:p},backend:t});d.push(f);var v=aa({inputs:{x:f},backend:t,attrs:{axis:i,keepDims:c}});return d.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),v}};var ia={kernelName:a.Min,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.keepDims;f(o,"min");var s=a.util.parseAxisParam(i,o.shape),u=s,l=a.backend_util.getAxesPermutation(u,o.shape.length),d=o;null!=l&&(d=ie({inputs:{x:o},backend:t,attrs:{perm:l}}),u=a.backend_util.getInnerMostAxes(u.length,o.shape.length)),a.backend_util.assertAxesAreInnerMostDims("min",u,d.shape.length);for(var p=a.backend_util.computeOutAndReduceShapes(d.shape,u),h=Object(T.a)(p,2),v=h[0],m=h[1],g=a.util.sizeFromShape(m),b=a.util.makeZerosTypedArray(a.util.sizeFromShape(v),d.dtype),x=t.data.get(d.dataId).values,k=0;k<b.length;++k){for(var I=k*g,y=x[I],C=0;C<g;++C){var N=x[I+C];N<y&&(y=N)}b[k]=y}null!=l&&t.disposeIntermediateTensorInfo(d);var R=t.makeTensorInfo(v,d.dtype,b);if(c){var w=K({inputs:{x:R},backend:t,attrs:{shape:a.backend_util.expandShapeToKeepDim(v,s)}});return t.disposeIntermediateTensorInfo(R),w}return R}},ca=R((function(e,n){return Math.min(e,n)})),sa=z(a.Minimum,ca),ua={kernelName:a.Minimum,backendName:"cpu",kernelFunc:sa};var la={kernelName:a.MirrorPad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.paddings,c=r.mode;f(o,"mirrorPad");for(var s=i.map((function(e,n){return e[0]+o.shape[n]+e[1]})),u=i.map((function(e){return e[0]})),l=i.map((function(e,n){return e[0]+o.shape[n]})),d="reflect"===c?0:1,p=t.data.get(o.dataId).values,h=o.shape.length,v=a.util.computeStrides(o.shape),m=a.util.sizeFromShape(s),g=s.length,b=a.util.computeStrides(s),x=a.util.getTypedArrayFromDType(o.dtype,m),k=0;k<m;k++){for(var I=a.util.indexToLoc(k,g,b),y=0;y<g;y++)I[y]<u[y]?I[y]=2*u[y]-I[y]-d:I[y]>=l[y]&&(I[y]=2*(l[y]-1)-I[y]+d);I=I.map((function(e,n){return e-u[n]}));var C=a.util.locToIndex(I,h,v);x[k]=p[C]}return{dataId:t.write(x,s,o.dtype),shape:s,dtype:o.dtype}}},da=R((function(e,n){var t=e%n;return e<0&&n<0||e>=0&&n>=0?t:(t+n)%n})),pa=z(a.Mod,da),ha={kernelName:a.Mod,backendName:"cpu",kernelFunc:pa},fa=t(242);function va(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.logits,i=r.dim,c=o.shape.length,s=i;if(-1===s&&(s=c-1),s!==c-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(c," and dim was ").concat(s));var u=a.util.parseAxisParam([s],o.shape),l=qt({inputs:{x:o},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),d=a.backend_util.expandShapeToKeepDim(l.shape,u),p=K({inputs:{x:l},backend:t,attrs:{shape:d}}),h=qn({inputs:{a:o,b:p},backend:t}),f=An({inputs:{x:h},backend:t}),v=aa({inputs:{x:f},backend:t,attrs:{axis:u,keepDims:!1}}),m=K({inputs:{x:v},backend:t,attrs:{shape:d}}),g=Gn({inputs:{a:f,b:m},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(m),g}var ma={kernelName:a.Softmax,backendName:"cpu",kernelFunc:va};var ga={kernelName:a.Multinomial,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.logits,i=r.numSamples,c=r.seed,s=r.normalized;f(o,"multinomial");for(var u=s?o:va({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=u.shape[0],d=u.shape[1],p=t.data.get(u.dataId).values,h=[l,i],v=a.util.makeZerosTypedArray(a.util.sizeFromShape(h),"int32"),m=0;m<l;++m){var g=m*d,b=new Float32Array(d-1);b[0]=p[g];for(var x=1;x<b.length;++x)b[x]=b[x-1]+p[g+x];for(var k=fa.alea(c.toString()),I=m*i,y=0;y<i;++y){var C=k();v[I+y]=b.length;for(var N=0;N<b.length;N++)if(C<b[N]){v[I+y]=N;break}}}return s||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(h,"int32",v)}};var ba={kernelName:a.Neg,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.x;f(r,"neg");var o=function(e,n,t){var r=a.util.createScalarValue(-1,t);return Bn([],n,r,e,t)}(t.data.get(r.dataId).values,r.shape,r.dtype),i=Object(T.a)(o,2),c=i[0],s=i[1];return t.makeTensorInfo(s,r.dtype,c)}},xa=a.kernel_impls.nonMaxSuppressionV3Impl;var ka={kernelName:a.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold;f(r,"NonMaxSuppression");var u=t.data.get(r.dataId).values,l=t.data.get(o.dataId).values,d=xa(u,l,i,c,s).selectedIndices;return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Ia=a.kernel_impls.nonMaxSuppressionV4Impl;var ya={kernelName:a.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold,u=a.padToMaxOutputSize;f(r,"NonMaxSuppressionPadded");var l=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,p=Ia(l,d,i,c,s,u),h=p.selectedIndices,v=p.validOutputs;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([],"int32",new Int32Array([v]))]}},Ca=a.kernel_impls.nonMaxSuppressionV5Impl;var Na={kernelName:a.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.boxes,o=n.scores,i=a.maxOutputSize,c=a.iouThreshold,s=a.scoreThreshold,u=a.softNmsSigma;f(r,"NonMaxSuppressionWithScore");var l=t.data.get(r.dataId).values,d=t.data.get(o.dataId).values,p=Ca(l,d,i,c,s,u),h=p.selectedIndices,v=p.selectedScores;return[t.makeTensorInfo([h.length],"int32",new Int32Array(h)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}},Ta=R((function(e,n){return e!==n?1:0})),Ra=z(a.NotEqual,Ta,null,"bool"),wa={kernelName:a.NotEqual,backendName:"cpu",kernelFunc:Ra};var Sa={kernelName:a.OneHot,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.indices,i=r.depth,c=r.onValue,s=r.offValue;f(o,"oneHot");var u=a.util.sizeFromShape(o.shape),l=new Float32Array(u*i);l.fill(s);for(var d=t.data.get(o.dataId).values,p=0;p<u;++p)d[p]>=0&&d[p]<i&&(l[p*i+d[p]]=c);return t.makeTensorInfo([].concat(Object(Ae.a)(o.shape),[i]),"int32",l)}};function Oa(e){var n=e.inputs,t=e.backend,a=n.x;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){var r=B({inputs:{input:a},backend:t}),o=Oa({inputs:{x:r},backend:t}),i=Ue({inputs:{input:a},backend:t}),c=Oa({inputs:{x:i},backend:t}),s=P({inputs:{real:o,imag:c},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),s}return $n({backend:t,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}var Fa={kernelName:a.ZerosLike,backendName:"cpu",kernelFunc:Oa};var Aa={kernelName:a.OnesLike,backendName:"cpu",kernelFunc:function e(n){var t=n.inputs,a=n.backend,r=t.x;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){var o=B({inputs:{input:r},backend:a}),i=e({inputs:{x:o},backend:a}),c=Ue({inputs:{input:r},backend:a}),s=Oa({inputs:{x:c},backend:a}),u=P({inputs:{real:i,imag:s},backend:a});return a.disposeIntermediateTensorInfo(o),a.disposeIntermediateTensorInfo(i),a.disposeIntermediateTensorInfo(c),a.disposeIntermediateTensorInfo(s),u}return $n({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function Ea(e){var n=e.inputs,t=e.backend,r=e.attrs.axis;if(1===n.length)return _n({inputs:{input:n[0]},backend:t,attrs:{dim:r}});var o=n[0].shape,i=n[0].dtype;n.forEach((function(e){a.util.assertShapesMatch(o,e.shape,"All tensors passed to stack must have matching shapes"),a.util.assert(i===e.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var c=[],s=Xe({inputs:n.map((function(e){var n=_n({inputs:{input:e},backend:t,attrs:{dim:r}});return c.push(n),n})),backend:t,attrs:{axis:r}});return c.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),s}var _a={kernelName:a.Pack,backendName:"cpu",kernelFunc:Ea};var Da={kernelName:a.PadV2,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.paddings,c=r.constantValue;f(o,"pad");var s=i.map((function(e,n){return e[0]+o.shape[n]+e[1]})),u=i.map((function(e){return e[0]})),l=t.data.get(o.dataId).values,d=a.util.sizeFromShape(o.shape),p=o.shape.length,h=a.util.computeStrides(o.shape),v=a.util.sizeFromShape(s),m=s.length,g=a.util.computeStrides(s),b=a.util.getTypedArrayFromDType(o.dtype,v);0!==c&&b.fill(c);for(var x=0;x<d;x++){var k=a.util.indexToLoc(x,p,h).map((function(e,n){return e+u[n]}));b[a.util.locToIndex(k,m,g)]=l[x]}return{dataId:t.write(b,s,o.dtype),shape:s,dtype:o.dtype}}},Pa=R((function(e,n){return Math.pow(e,n)})),Ma=z(a.Pow,Pa),La={kernelName:a.Pow,backendName:"cpu",kernelFunc:Ma};var Ba={kernelName:a.Prod,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.axis,c=r.keepDims;f(o,"prod");var s=o.shape.length,u=a.util.parseAxisParam(i,o.shape),l=a.backend_util.getAxesPermutation(u,s),d=u,p=o,h=[];null!=l&&(p=ie({inputs:{x:o},backend:t,attrs:{perm:l}}),h.push(p),d=a.backend_util.getInnerMostAxes(d.length,s));var v=t.data.get(p.dataId).values,m=function(e,n,t,r){for(var o=a.backend_util.computeOutAndReduceShapes(e,r),i=Object(T.a)(o,2),c=i[0],s=i[1],u=Object(a.upcastType)(n,"int32"),l=a.util.makeZerosTypedArray(a.util.sizeFromShape(c),u),d=a.util.sizeFromShape(s),p=0;p<l.length;++p){for(var h=p*d,f=1,v=0;v<d;++v)f*=t[h+v];l[p]=f}return{outVals:l,outShape:c,outDtype:u}}(p.shape,p.dtype,v,d),g=m.outVals,b=m.outShape,x=m.outDtype,k=b;return c&&(k=a.backend_util.expandShapeToKeepDim(b,u)),h.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),t.makeTensorInfo(k,x,g)}};var Wa={kernelName:a.Range,backendName:"cpu",kernelFunc:function(e){var n=e.backend,t=e.attrs,r=t.start,o=t.stop,i=t.dtype,c=function(e,n,t,r){if(e===n||e<n&&t<0||n<e&&t>1)return a.util.makeZerosTypedArray(0,r);var o=Math.abs(Math.ceil((n-e)/t)),i=a.util.makeZerosTypedArray(o,r);n<e&&1===t&&(t=-1),i[0]=e;for(var c=1;c<i.length;c++)i[c]=i[c-1]+t;return i}(r,o,t.step,i);return n.makeTensorInfo([c.length],i,c)}},ja=g(a.Reciprocal,(function(e){return 1/e})),Va={kernelName:a.Reciprocal,backendName:"cpu",kernelFunc:ja};var za={kernelName:a.ResizeBilinear,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.images,i=r.alignCorners,c=r.halfPixelCenters,s=r.size;f(o,"resizeBilinear");for(var u=a.util.computeStrides(o.shape),l=Object(T.a)(s,2),d=l[0],p=l[1],h=Object(T.a)(o.shape,4),v=h[0],m=h[1],g=h[2],b=h[3],x=t.data.get(o.dataId).values,k=new Float32Array(a.util.sizeFromShape([v,d,p,b])),I=[i&&d>1?m-1:m,i&&p>1?g-1:g],y=[i&&d>1?d-1:d,i&&p>1?p-1:p],C=0,N=I[0]/y[0],R=I[1]/y[1],w=0;w<v;w++)for(var S=0;S<d;S++){var O=void 0;O=c?N*(S+.5)-.5:N*S;for(var F=Math.max(0,Math.floor(O)),A=O-F,E=Math.min(m-1,Math.ceil(O)),_=w*u[0]+F*u[1],D=w*u[0]+E*u[1],P=0;P<p;P++){var M=void 0;M=c?R*(P+.5)-.5:R*P;for(var L=Math.max(0,Math.floor(M)),B=M-L,W=Math.min(g-1,Math.ceil(M)),j=_+L*u[2],V=D+L*u[2],z=_+W*u[2],G=D+W*u[2],U=0;U<b;U++){var H=x[j+U],X=x[V+U],q=H+(x[z+U]-H)*B,K=q+(X+(x[G+U]-X)*B-q)*A;k[C++]=K}}}return t.makeTensorInfo([v,d,p,b],"float32",k)}};var Ga={kernelName:a.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.images,i=n.dy,c=r.alignCorners;f([i,o],"resizeBilinearGrad");for(var s=a.util.computeStrides(o.shape),u=Object(T.a)(o.shape,4),l=u[0],d=u[1],p=u[2],h=u[3],v=Object(T.a)(i.shape,3),m=v[1],g=v[2],b=new Float32Array(l*d*p*h),x=[c&&m>1?d-1:d,c&&g>1?p-1:p],k=[c&&m>1?m-1:m,c&&g>1?g-1:g],I=x[0]/k[0],y=x[1]/k[1],C=t.data.get(i.dataId).values,N=0,R=0;R<l;R++)for(var w=R*s[0],S=0;S<m;S++)for(var O=S*I,F=Math.floor(O),A=Math.min(Math.ceil(O),d-1),E=w+F*s[1],_=w+A*s[1],D=O-F,P=1-D,M=0;M<g;M++)for(var L=M*y,B=Math.floor(L),W=Math.min(Math.ceil(L),p-1),j=L-B,V=1-j,z=E+B*s[2],G=E+W*s[2],U=_+B*s[2],H=_+W*s[2],X=P*V,q=P*j,K=D*V,Y=D*j,Q=0;Q<h;Q++){var Z=C[N++];b[z+Q]+=Z*X,b[G+Q]+=Z*q,b[U+Q]+=Z*K,b[H+Q]+=Z*Y}return t.makeTensorInfo([l,p,d,h],"float32",b)}};var Ua={kernelName:a.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.images,i=r.alignCorners,c=r.halfPixelCenters,s=r.size;f(o,"resizeNearestNeighbor");for(var u=a.util.computeStrides(o.shape),l=Object(T.a)(s,2),d=l[0],p=l[1],h=Object(T.a)(o.shape,4),v=h[0],m=h[1],g=h[2],b=h[3],x=t.data.get(o.dataId).values,k=new Float32Array(v*d*p*b),I=[i&&d>1?m-1:m,i&&p>1?g-1:g],y=[i&&d>1?d-1:d,i&&p>1?p-1:p],C=I[0]/y[0],N=I[1]/y[1],R=0,w=0;w<v;w++)for(var S=w*u[0],O=0;O<d;O++){var F=c?C*(O+.5):C*O,A=Math.min(m-1,i?Math.round(F):Math.floor(F));c&&(A=Math.max(0,A));for(var E=S+A*u[1],_=0;_<p;_++){var D=c?N*(_+.5):N*_,P=Math.min(g-1,i?Math.round(D):Math.floor(D));c&&(P=Math.max(0,P));for(var M=E+P*u[2],L=0;L<b;L++){var B=x[M+L];k[R++]=B}}}return t.makeTensorInfo([v,d,p,b],o.dtype,k)}};var Ha={kernelName:a.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.images,i=n.dy,c=r.alignCorners;f([i,o],"resizeNearestNeighborGrad");for(var s=a.util.computeStrides(o.shape),u=a.util.computeStrides(i.shape),l=Object(T.a)(o.shape,4),d=l[0],p=l[1],h=l[2],v=l[3],m=Object(T.a)(i.shape,3),g=m[1],b=m[2],x=new Float32Array(d*p*h*v),k=t.data.get(i.dataId).values,I=[c&&g>1?p-1:p,c&&b>1?h-1:h],y=[c&&g>1?g-1:g,c&&b>1?b-1:b],C=I[0]/y[0],N=I[1]/y[1],R=1/C,w=1/N,S=2*Math.ceil(R)+2,O=2*Math.ceil(w)+2,F=0;F<d;F++)for(var A=F*s[0],E=0;E<p;E++)for(var _=A+E*s[1],D=Math.floor(E*R),P=Math.floor(D-S/2),M=0;M<h;M++)for(var L=_+M*s[2],B=Math.floor(M*w),W=Math.floor(B-O/2),j=0;j<v;j++){for(var V=0,z=0;z<S;z++){var G=z+P;if(!(G<0||G>=g)){var U=A+G*u[1],H=G*C;if(E===Math.min(p-1,c?Math.round(H):Math.floor(H)))for(var X=0;X<O;X++){var q=X+W;if(!(q<0||q>=b)){var K=U+q*u[2],Y=q*N;M===Math.min(h-1,c?Math.round(Y):Math.floor(Y))&&(V+=k[K+j])}}}}x[L+j]=V}return t.makeTensorInfo(o.shape,o.dtype,x)}};var Xa={kernelName:a.Reverse,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.dims;f(o,"reverse");var c=o.shape.length,s=a.util.parseAxisParam(i,o.shape);if(0===c)return I({inputs:{x:o},backend:t});for(var u=new a.TensorBuffer(o.shape,o.dtype),l=t.bufferSync(o),d=function(e){var n=u.indexToLoc(e),t=n.slice();s.forEach((function(e){return t[e]=o.shape[e]-1-t[e]})),u.set.apply(u,[l.get.apply(l,Object(Ae.a)(t))].concat(Object(Ae.a)(n)))},p=0;p<u.size;p++)d(p);return t.makeTensorInfo(u.shape,u.dtype,u.values)}},qa={kernelName:a.RotateWithOffset,backendName:"cpu",kernelFunc:function(e){for(var n=e.inputs,t=e.attrs,r=e.backend,o=n.image,i=t.radians,c=t.fillValue,s=t.center,u=r,l=a.util.getTypedArrayFromDType(o.dtype,a.util.sizeFromShape(o.shape)),d=Object(T.a)(o.shape,4),p=d[0],h=d[1],f=d[2],v=d[3],m=a.backend_util.getImageCenter(s,h,f),g=Object(T.a)(m,2),b=g[0],x=g[1],k=Math.sin(i),I=Math.cos(i),y=u.data.get(o.dataId).values,C=0;C<p;C++)for(var N=C*f*h*v,R=0;R<h;R++)for(var w=R*(f*v),S=0;S<f;S++)for(var O=S*v,F=0;F<v;F++){var A=[p,R,S,F],E=A[2],_=A[1],D=(E-b)*I-(_-x)*k,P=(E-b)*k+(_-x)*I;D=Math.round(D+b),P=Math.round(P+x);var M=c;if("number"!==typeof c&&(M=3===F?255:c[F]),D>=0&&D<f&&P>=0&&P<h)M=y[N+P*(f*v)+D*v+F];l[N+w+O+F]=M}return{dataId:u.write(l,o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}},Ka=g(a.Round,(function(e){var n=Math.floor(e);return e-n<.5?Math.floor(e):e-n>.5?Math.ceil(e):n%2===0?n:n+1})),Ya={kernelName:a.Round,backendName:"cpu",kernelFunc:Ka},Qa=Le((function(e){return 1/Math.sqrt(e)})),Za=b(a.Rsqrt,Qa),Ja={kernelName:a.Rsqrt,backendName:"cpu",kernelFunc:Za};function $a(e,n,t,r,o,i,c,s,u,l){var d=[r/o,o],p=e.values,h=n.values;if(0===r)return Object(a.buffer)(t,n.dtype);var f=Object(a.buffer)(d,n.dtype);f.values.fill(u);for(var v=0;v<i;v++){for(var m=[],g=0,b=0;b<c;b++){var x=p[v*c+b];m.push(x),g+=x*s[b]}if(g<0||g>=r/o)throw new Error("Invalid indices: ".concat(m," does not index into ").concat(t));for(var k=0;k<o;k++)l?f.values[g*o+k]+=h[v*o+k]:f.values[g*o+k]=0===n.rank?h[0]:h[v*o+k]}return f}var er={kernelName:a.ScatterNd,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.indices,i=n.updates,c=r.shape,s=a.backend_util.calculateShapes(i,o,c),u=s.sliceRank,l=s.numUpdates,d=s.sliceSize,p=s.strides,h=s.outputSize,f=$a(t.bufferSync(o),t.bufferSync(i),c,h,d,l,u,p,0,!0);return t.makeTensorInfo(c,f.dtype,f.values)}};var nr={kernelName:a.Select,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=n.condition,o=n.t,i=n.e;f([r,o,i],"select");for(var c=r.shape.length,s=t.data.get(r.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(i.dataId).values,d=Object(a.upcastType)(o.dtype,i.dtype),p=a.util.makeZerosTypedArray(a.util.sizeFromShape(o.shape),d),h=0,v=0===c||c>1||1===o.shape.length?1:a.util.sizeFromShape(o.shape.slice(1)),m=0;m<s.length;m++)for(var g=0;g<v;g++)1===s[m]?p[h++]=u[m]:p[h++]=l[m];return t.makeTensorInfo(o.shape,d,p)}},tr=a.backend_util.SELU_SCALEALPHA,ar=a.backend_util.SELU_SCALE,rr=g(a.Selu,(function(e){return e>=0?ar*e:tr*(Math.exp(e)-1)})),or={kernelName:a.Selu,backendName:"cpu",kernelFunc:rr},ir=g(a.Sigmoid,(function(e){return 1/(1+Math.exp(-e))})),cr={kernelName:a.Sigmoid,backendName:"cpu",kernelFunc:ir},sr=g(a.Sign,(function(e){return e<0?-1:e>0?1:0})),ur={kernelName:a.Sign,backendName:"cpu",kernelFunc:sr},lr=g(a.Sin,(function(e){return Math.sin(e)})),dr={kernelName:a.Sin,backendName:"cpu",kernelFunc:lr},pr=g(a.Sinh,(function(e){return Math.sinh(e)})),hr={kernelName:a.Sinh,backendName:"cpu",kernelFunc:pr},fr=Math.log(1.1920928955078125e-7)+2,vr=g(a.Softplus,(function(e){var n=e>-fr,t=e<fr,a=Math.exp(e);return t?a:n?e:Math.log(1+a)})),mr={kernelName:a.Softplus,backendName:"cpu",kernelFunc:vr};var gr={kernelName:a.SpaceToBatchND,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.blockShape,c=r.paddings;f([o],"spaceToBatchND");var s=a.util.sizeFromShape(i),u=[[0,0]];u.push.apply(u,Object(Ae.a)(c));for(var l=1+i.length;l<o.shape.length;++l)u.push([0,0]);var d=Da.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=a.backend_util.getReshaped(d.shape,i,s,!1),h=a.backend_util.getPermuted(p.length,i.length,!1),v=a.backend_util.getReshapedPermuted(d.shape,i,s,!1),m=K({inputs:{x:d},backend:t,attrs:{shape:p}}),g=ie({inputs:{x:m},backend:t,attrs:{perm:h}}),b=K({inputs:{x:g},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),b}};var br={kernelName:a.SparseToDense,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.sparseIndices,i=n.sparseValues,c=n.defaultValue,s=r.outputShape,u=a.backend_util.calculateShapes(i,o,s),l=u.sliceRank,d=u.numUpdates,p=u.sliceSize,h=u.strides,f=u.outputSize,v=$a(t.bufferSync(o),t.bufferSync(i),s,f,p,d,l,h,t.data.get(c.dataId).values[0],!1);return t.makeTensorInfo(s,v.dtype,v.values)}};var xr={kernelName:a.SplitV,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.numOrSizeSplits,c=r.axis,s=a.util.parseAxisParam(c,o.shape)[0],u=a.backend_util.prepareSplitSize(o,i,s),l=new Array(o.shape.length).fill(0),d=o.shape.slice();return u.map((function(e){var n=Object(Ae.a)(d);n[s]=e;var a=Ee({inputs:{x:o},backend:t,attrs:{begin:l,size:n}});return l[s]+=e,a}))}},kr=g(a.Sqrt,(function(e){return Math.sqrt(e)})),Ir={kernelName:a.Sqrt,backendName:"cpu",kernelFunc:kr},yr={kernelName:a.Square,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=n.x,r=t;f(a,"square");for(var o=r.data.get(a.dataId).values,i=new Float32Array(o.length),c=0;c<o.length;++c){var s=o[c];i[c]=s*s}return{dataId:r.write(i,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},Cr=R((function(e,n){var t=e-n;return t*t})),Nr=z(a.SquaredDifference,Cr),Tr={kernelName:a.SquaredDifference,backendName:"cpu",kernelFunc:Nr},Rr=g(a.Step,(function(e,n){var t=n;return isNaN(e)?NaN:e>0?1:t.alpha})),wr={kernelName:a.Step,backendName:"cpu",kernelFunc:Rr};var Sr={kernelName:a.StridedSlice,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.begin,c=r.end,s=r.strides,u=r.beginMask,l=r.endMask,d=r.ellipsisMask,p=r.newAxisMask,h=r.shrinkAxisMask;f(o,"stridedSlice");var v,m=a.slice_util.sliceInfo(o.shape,i,c,s,u,l,d,p,h),g=m.nonStrided,b=m.$begin,x=m.$strides,k=m.size,I=m.newShape,y=m.outShape,C=K({inputs:{x:o},backend:t,attrs:{shape:I}});if(g){var N=Ee({inputs:{x:C},backend:t,attrs:{begin:b,size:k}});v=K({inputs:{x:N},backend:t,attrs:{shape:y}}),t.disposeIntermediateTensorInfo(N)}else if(y.some((function(e){return 0===e})))v=t.makeTensorInfo(y,o.dtype,[]);else{var T=function(e,n,t,r){for(var o=Object(a.buffer)(e,n.dtype),i=0;i<o.size;i++){for(var c=o.indexToLoc(i),s=new Array(c.length),u=0;u<s.length;u++)s[u]=c[u]*t[u]+r[u];o.set.apply(o,[n.get.apply(n,s)].concat(Object(Ae.a)(c)))}return o}(y,t.bufferSync(C),x,b);v=t.makeTensorInfo(T.shape,T.dtype,T.values)}var R=K({inputs:{x:v},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(C),t.disposeIntermediateTensorInfo(v),R}},Or=g(a.Tan,(function(e){return Math.tan(e)})),Fr={kernelName:a.Tan,backendName:"cpu",kernelFunc:Or},Ar=g(a.Tanh,(function(e){return Math.tanh(e)})),Er={kernelName:a.Tanh,backendName:"cpu",kernelFunc:Ar};var _r={kernelName:a.Tile,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.reps;f(o,"tile");var c=function(e,n){for(var t=new Array(e.rank),r=0;r<t.length;r++)t[r]=e.shape[r]*n[r];for(var o=Object(a.buffer)(t,e.dtype),i=0;i<o.values.length;++i){for(var c=o.indexToLoc(i),s=new Array(e.rank),u=0;u<s.length;u++)s[u]=c[u]%e.shape[u];var l=e.locToIndex(s);o.values[i]=e.values[l]}return o}(t.bufferSync(o),i);return t.makeTensorInfo(c.shape,c.dtype,c.values)}};var Dr={kernelName:a.TopK,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=r.k;r.sorted,f(o,"topk");var c=function(e,n,t,r,o){for(var i=n[n.length-1],c=e.length/i,s=i,u=a.util.getTypedArrayFromDType(t,c*r),l=a.util.getTypedArrayFromDType("int32",c*r),d=0;d<c;d++){for(var p=d*s,h=e.subarray(p,p+s),f=[],v=0;v<h.length;v++)f.push({value:h[v],index:v});f.sort((function(e,n){return n.value-e.value}));for(var m=d*r,g=u.subarray(m,m+r),b=l.subarray(m,m+r),x=0;x<r;x++)g[x]=f[x].value,b[x]=f[x].index}var k=n.slice();return k[k.length-1]=r,[Object(a.buffer)(k,t,u),Object(a.buffer)(k,"int32",l)]}(t.data.get(o.dataId).values,o.shape,o.dtype,i),s=Object(T.a)(c,2),u=s[0],l=s[1];return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}};var Pr={kernelName:a.Unique,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.attrs,r=e.backend,o=t.axis,i=n.x;f(i,"unique");var c=function(e,n,t,r){for(var o=a.util.parseAxisParam(n,t)[0],i=[1,t[0],1],c=0;c<o;c++)i[0]*=t[c];i[1]=t[o];for(var s=o+1;s<t.length;s++)i[2]*=t[s];for(var u={},l=new Int32Array(t[o]),d=new a.TensorBuffer(i,r,e),p=[],h=1===i[0]&&1===i[2],f=0;f<t[o];f++){var v=void 0;if(h)v=e[f].toString();else{for(var m=[],g=0;g<i[0];g++)for(var b=0;b<i[2];b++)m.push(d.get(g,f,b));v=m.join(",")}if(void 0!==u[v])l[f]=u[v];else{var x=Object.keys(u).length;u[v]=x,l[f]=x,p.push(f)}}var k=i.slice();k[1]=Object.keys(u).length;var I=new a.TensorBuffer(k,r);p.forEach((function(e,n){for(var t=0;t<i[0];t++)for(var a=0;a<i[2];a++)I.set(d.get(t,e,a),t,n,a)}));var y=t.slice();return y[o]=k[1],{outputValues:I.values,outputShape:y,indices:l}}(r.data.get(i.dataId).values,o,i.shape,i.dtype),s=c.outputValues,u=c.outputShape,l=c.indices;return[r.makeTensorInfo(u,i.dtype,s),r.makeTensorInfo([l.length],"int32",l)]}};var Mr={kernelName:a.Unpack,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,a=e.attrs,r=n.value,o=a.axis;o<0&&(o+=r.shape.length);for(var i=r.shape.length,c=r.shape[o],s=new Array(i-1),u=0,l=0;l<i;l++)l!==o&&(s[u++]=r.shape[l]);var d=new Array(i).fill(0),p=r.shape.slice();p[o]=1;for(var h=new Array(c),f=0;f<h.length;f++){d[o]=f;var v=Ee({inputs:{x:r},backend:t,attrs:{begin:d,size:p}});h[f]=K({inputs:{x:v},backend:t,attrs:{shape:s}}),t.disposeIntermediateTensorInfo(v)}return h}};for(var Lr={kernelName:a.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function(e){var n=e.inputs,t=e.backend,r=e.attrs,o=n.x,i=n.segmentIds,c=r.numSegments;f(o,"unsortedSegmentSum");for(var s=[],u=[],l=o.shape.length-i.shape.length,d=i,p=0;p<l;++p){var h=_n({inputs:{input:d},backend:t,attrs:{dim:p+1}});d=h,u.push(h)}for(var v=0;v<c;++v){var m=a.util.createScalarValue(v,"int32"),g=t.makeTensorInfo([],"int32",m),b=kn({inputs:{a:g,b:d},backend:t}),x=j({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),k=jn({inputs:{a:x,b:o},backend:t}),I=aa({inputs:{x:k},backend:t,attrs:{axis:0,keepDims:!1}});s.push(I),u.push(g),u.push(b),u.push(x),u.push(k),u.push(I)}var y=Ea({inputs:s,backend:t,attrs:{axis:0}});return u.forEach((function(e){return t.disposeIntermediateTensorInfo(e)})),y}},Br=0,Wr=[J,$,ne,ae,q,re,se,ue,le,de,he,ve,ge,ke,ye,Re,we,Se,Oe,Z,Fe,De,Me,V,je,ze,M,Ge,qe,Qe,Ze,Ye,$e,en,Je,tn,rn,on,cn,sn,un,dn,pn,hn,fn,vn,gn,mn,Un,k,bn,In,On,En,Dn,Ln,Jn,et,nt,rt,ct,st,ut,lt,dt,ft,gt,y,bt,He,kt,yt,Nt,N,wt,Ft,At,Dt,Mt,Wt,Vt,Ut,Ht,Xt,Zt,Jt,$t,ea,na,ta,Kt,oa,ia,ua,la,ha,ga,Vn,ba,ka,ya,Na,wa,Sa,Aa,_a,Da,La,O,Ba,Wa,W,Va,A,_,Y,za,Ga,Ua,Ha,Xa,qa,Ya,Ja,er,nr,or,cr,ur,dr,hr,_e,ma,mr,gr,br,xr,Ir,yr,Tr,wr,Sr,Kn,ra,Fr,Er,_r,Dr,ce,Pr,Mr,Lr,Fa];Br<Wr.length;Br++){var jr=Wr[Br];Object(a.registerKernel)(jr)}}}]);
//# sourceMappingURL=2.2905fbe5.chunk.js.map